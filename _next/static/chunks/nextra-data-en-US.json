{"/reactive-accilarator/React-js/module-1/React-installation-and-development-environment-setup":{"title":"React Installation and Development Environment Setup","data":{"":"রিয়াক্ট জে এস ইন্সটল করা এবং ইডীটর সেটআপ করা ।","কমান্ড-প্রমট-এর-মাদ্ধ্যমে-রিয়াক্ট-ইন্সটল-করা-#কমান্ড প্রমট এর মাদ্ধ্যমে রিয়াক্ট ইন্সটল করা ।":"npm create vite@latest --template react","follow-the-command#Follow the command":""}},"/reactive-accilarator/React-js/module-1/basics-of-react-component":{"title":"Basics of React Component","data":{"components-কি-#Components কি ?":"Component হলো রিয়াক্টের কোর কনসেপ্টগুলোর মধ্যে একটি । এটিকে UI বানানোর বিল্ডিং ব্লক বলা হয়ে থাকে । UI এর প্রতিটা অংশের কোড, যা বার বার রি-ইউজ করা যায় সেগুলোকে একেকটা কম্পোনেন্ট বলা যায়। একটি ছোট বাটনও একটা কম্পোনেট হতে পারে ।রিয়াক্ট আমাদের মার্কাপ গুলোকে ছোট ছোট রি-ইউজেবল কোড ব্লকে এ লিখতে সাহায্য করে,যার একেকটি ব্লক হলো একেকটি কম্পোনেন্ট।তবে কম্পোনেন্ট বানানোর জন্য কিছু নিয়ম রয়েছে যা নিচে দেখানো হয়েছে।","কিভাবে-একটি-রিয়াক্ট-component-বানাতে-হয়-#কিভাবে একটি রিয়াক্ট Component বানাতে হয় ?":"রিয়াক্ট কম্পোনেট হলো একটি জাভাস্ক্রিপ্ট ফাংশন। যাতে আমাদের মার্কাপের সাথে জাভাস্ক্রিপ্টের সংমিশ্রণ থাকে।রিয়াক্ট কম্পোনেন্টের সিনট্যাক্স\nexport default function Profile() {\n    return (\n        <img\n            src='https://i.imgur.com/MK3eW3Am.jpg'\n            alt='Katherine Johnson'\n        />\n    );\n}\nএকটি কম্পোনেন্ট বানাতে যেসব স্টেপ ফলো করতে হয়,তা হলোঃ","কম্পোনেন্টকে-এক্সপোর্ট-করা#কম্পোনেন্টকে এক্সপোর্ট করা":"export default ব্যাবহার করে একটা কম্পোনেন্টকে রি-ইউজেবল করতে হয়, যাতে আমরা অন্য ফাইলে কম্পোনেন্টটিকে import\nকরে ব্যাবহার করতে পারি।","ফাংশন-ডিফাইন-করা#ফাংশন ডিফাইন করা":"export default এর পর একটা নেমড ফাংশন ডিফাইন করতে হয়।\n    export default function Profile(){}\nReact Component বানাতে হলে অবশ্যই ফাংশনের নামের প্রথম অক্ষর Capital later এ লিখতে হবে,নাহলে তা কাজ করবেনা।","ফাংশনের-ভিতরে-মার্কাপ-যুক্ত-করা#ফাংশনের ভিতরে মার্কাপ যুক্ত করা":"ফাংশনের ভিতরে JSX (Javascript XML) সিনট্যাক্সে মার্কাপ রিটার্ন করতে হয়।\nexport default function Profile() {\n    return img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n}\nreturn Statement যদি এক লাইনের বেশি লিখতে হয় তাহলে () এর ভিতরে লিখতে হয়\nউদাহরণঃ\nexport default function Profile() {\n  return (\n  <div>\n       <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n  </div>\n  )\n}","কম্পোনেট-কিভাবে-ব্যাবহার-করতে-হয়ঃ#কম্পোনেট কিভাবে ব্যাবহার করতে হয়ঃ":"একটা কম্পোনেন্ট বানানোর পর সেম ফাইলে অন্য আরেকটা কম্পোনেন্ট এর ভিতরে অথবা চাইলে অন্য ফাইলে কম্পোনেন্ট import করে ব্যাবহার করা যায়।উদাহরনঃ\nimport Profile from \"Profile\";\nexport default function Gallery() {\n    return (\n        <section>\n            <h1>Amazing scientists</h1>\n            <Profile />\n            <Profile />\n            <Profile />\n        </section>\n    );\n}","কম্পোনেন্ট-নেস্টিং-করার-ক্ষেত্রে-যেসব-রুলস-মানতে-হয়ঃ#কম্পোনেন্ট নেস্টিং করার ক্ষেত্রে যেসব রুলস মানতে হয়ঃ":"Rules:1 - যদি এমন কম্পোনেন্ট হয়,যেটা খুব ছোট এবং রি-ইউজ হবেনা সেটা চাইলে একই ফাইলে লেখা যায়,এবং ব্যাবহার করা যায়। কিন্তু যদি কম্পোনেন্ট অনেক বড় হয় এবং interactivity বেশি হয়, এবং বিভিন্ন জায়গায় রি-ইউজ করতে হয় তাহলে আলাদা আলাদা ফাইলে কম্পোনেন্ট বানাতে হবে।Rules:2 - একটা কম্পোনেন্ট এর ভিতর আরেকটা কম্পোনেন্টকে নেস্টেড করা যাবে,কিন্তু একটা কম্পোনেট এর ভিতর অন্য আরেকটা ফাংশন ডেফিনেশন নেস্টেড করা যাবেনা।"}},"/reactive-accilarator/React-js/module-1/component-export-import":{"title":"Component Export Import","data":{"রিয়াক্টে-কিভাবে-import--export-করতে-হয়#রিয়াক্টে কিভাবে import & export করতে হয়?":"**রিয়াক্টে দুইভাবে কম্পোনেন্ট import & export করা যায়ঃ **\ndefault export and import\nnamed export and import","default-export-and-import#default export and import":"উদাহরনঃ","default-export#default export":"export default function Gallery() {\n    return; //Jsx will return\n}\nতাছাড়া আরেকভাবে default export করা যায়,\nfunction Gallery() {\n    return; //Jsx will return\n}\nexport default Gallery;","default-import#default import":"import Gallery from \"Gallery\"; // এখানে .js বা .jsx না লিখলেও কোন সমস্যা নেই\ndefault import এর ক্ষেত্রে আমরা যেকোন নামে কম্পোনেন্ট import করতে পারি। তবে, যেই নামে কম্পোনেন্ট import করা হবে সেই নামেই ব্যাবহার করতে হবে।","named-export-and-import#named export and import":"উদাহরনঃ","named-export#named export":"export function Gallery() {\n    return; //Jsx will return\n}\nnamed export এর মাধ্যমে আমরা চাইলে একটা ফাইল থেকে একাধিক কম্পোনেন্ট এক্সপোর্ট করতে পারি, যেমনঃ\nexport function Card() {\n    return; //Jsx will return\n}\nexport function Image() {\n    return; //Jsx will return\n}\nexport function Profile() {\n    return; //Jsx will return\n}","named-import#named import":"import { Card, Image, Profile } from \"Gallery\"; // এভাবে আমরা এক্লাইনেই একাধিক কম্পোনেন্ট ইম্পোর্ট করতে পারি।","alias-named-import#Alias Named Import":"named import এর ক্ষেত্রে আমরা চাইলে Alias দিয়ে রিনেম করেও কম্পোনেন্ট ইম্পোর্ট করতে পারি।\nimport { Card as ImageCard } from \"Gallery\";"}},"/reactive-accilarator/React-js/module-1/conditional-renderaing":{"title":"Conditional Renderaing","data":{"কন্ডিশনাল-রেন্ডারিং-কি-#কন্ডিশনাল রেন্ডারিং কি ?":"রিয়াক্টে আমরা কোন শর্তের উপর ডিপেন্ড করে কোন কিছু দেখাতে পারি। আমরা কি দেখাবো আর কি দেখাবোনা তা নির্দিষ্ট লজিকের উপর ভিত্তি করে করতে পারি। এটাকে রিয়াক্টে কন্ডিশনাল রেন্ডারিং বলা হয়।আমরা বেশ কিছু উপায়ে রিয়াক্টে কন্ডিশনাল রেন্ডারিং করতে পাড়িঃ\nif else statements\ncondition ? true : false - Ternery Operator\n&& - Logical AND Operator\n|| - Logical OR operator\n?? - Nullish Coalesing operator","if-else-statements#if else statements":"আমাদের যদি অনেক কমপ্লেক্স লজিক থাকে,এবং তার উপর ভিত্তি করে আমাদের কিছু রেন্ডার করা লাগে,তাহলে আমরা if else statements এর মাধ্যমে তা করতে পারি। সেক্ষেত্রে আমাদেরকে JSX এর বাহিরে if else statements ডিফাইন করতে হবে।** উদাহরণঃ**\nfunction Item({ name, isPacked }) {\n    if (isPacked) {\n        return <li className='item'>{name} ✅</li>;\n    }\n    return <li className='item'>{name}</li>;\n}\nexport default function PackingList() {\n    return (\n        <section>\n            <h1>Sally Ride's Packing List</h1>\n            <ul>\n                <Item\n                    isPacked={true}\n                    name='Space suit'\n                />\n                <Item\n                    isPacked={true}\n                    name='Helmet with a golden leaf'\n                />\n                <Item\n                    isPacked={false}\n                    name='Photo of Tam'\n                />\n            </ul>\n        </section>\n    );\n}","condition--true--false---ternery-operator#condition ? true : false - Ternery Operator":"আমাদের কন্ডিশন যদি অনেক বেশি কমপ্লেক্স না হয় এবং ম্যক্সিমাম ২-৩ লেবেলের বেশি ডিপ না হয় তাহলে আমরা খুব সহজেই JSX এর ভিতরেই Ternery Operator ব্যাবহার করে কন্ডিশনাল রেন্ডারিং করতে পারি।** উদাহরণঃ**\nfunction Item({ name, isPacked }) {\n    return <li className='item'>{isPacked ? name + \" ✅\" : name}</li>;\n}","---logical-and-operator#&& - Logical AND Operator":"যদি আমাদের কন্ডিশন এমন হয় যে, কন্ডিশন মিললে কিছু রেন্ডার করবো আর না মিললে কিছুই রেন্ডার করবোনা,তাহলে আমরা আরও শর্টকাটে && - Logical AND Operator ব্যাবহার করে সেটা করতে পারি।\nfunction Item({ name, isPacked }) {\n    return (\n        <li className='item'>\n            {name} {isPacked && \"✅\"}\n        </li>\n    );\n}\nলজিকাল && এর মানে হলো যে, && এর বাম পাশে truthy ভ্যালু হয় তাহলে ডান পাশের ভ্যালু রিটার্ন করবে,আর falsy হলে কিছুই রিটার্ন করবেনা।\nlet logic = \"true\";\nlogic && \"Something to Render\"; // এখানে লজিকের ভ্যালু `truthy` হলেই শুধ্যমাত্র `&&` এর ডান পাশে যা থাকবে তা রিটার্ন করবে,আর না হলে কিছুই রিটার্ন করবেনা।\nতবে এক্ষেত্র মনে রাখতে হবে যে, && এর বাম পাশের ডাটাটাইপ যেন নাম্বার না হয়,কেননা যদি নাম্বার হয় তাহলে নাম্বারের falsy ভ্যালু হিসেবে 0রিটার্ন করে দিবে।","---logical-or-operator#|| - Logical OR operator":"লজিকাল && এর মতো || - Logical OR operator ব্যাবহার করেও সেম কাজ করতে পারি।\nfunction Item({ name, isPacked }) {\n    return (\n        <li className='item'>\n            {name} {isPacked || \"✅\"}\n        </li>\n    );\n}\nতবে লজিকাল || এর মানে হলো যে, || এর বাম পাশে falsy (0,null,undefined,\"\",false,NaN) ভ্যালু হয় তাহলেই শুধুমাত্র ডান পাশের ভ্যালু রিটার্ন করবে,আর না হলে কিছুই রিটার্ন করবেনা।\nlet logic = \"false\";\nlogic || \"Something to Render\"; // এখানে লজিকের ভ্যালু `falsy` হলেই শুধ্যমাত্র `||` এর ডান পাশে যা থাকবে তা রিটার্ন করবে,আর না হলে কিছুই রিটার্ন করবেনা।","---nullish-coalesing-operator#?? - Nullish Coalesing operator":"যদি কোন ডাইনামিক ভ্যালু null অথবা undefined হয় তাহলে যদি আমরা কোন কিছু করতে চাই, তাহলে আমরা ?? - Nullish Coalesing operator ব্যাবহার করে তা করতে পারি।\nfunction Item({ name, isPacked, data }) {\n    return (\n        data ?? (\n            <li className='item'>\n                {name} {isPacked || \"✅\"}\n            </li>\n        )\n    );\n}"}},"/reactive-accilarator/React-js/module-1/introduction-to-react":{"title":"Introduction to React","data":{"react-কি-#React কি ?":"রিয়াক্ট হলো ফেসবুকের ডেভেলপ করা একটা জাভাস্ক্রিপ্ট লাইব্রেরি। যা একই সাথে ন্যটিভ এবং ওয়েব ইন্টারফেস ডিজাইন করতে সহায়তা করে থাকে। এটি জাভাস্ক্রিপ্ট এ লেখা জাভাস্ক্রিপ্ট এর ই একটা লাইব্রেরি।ফেসবুকের সফটওয়্যার ইঞ্জিনিয়ার Jordan Walke 2011 সালে PHP এর একটা Component Based Framework XHP-js থেকে ইন্সপায়ার হয়ে React.js তৈরি করেন। 2011 সালে এটা প্রথম ফেসবুকের নিউজফিডে ইম্পিলিমেন্ট করা হয় এবং ২০১২ সালে এটা ইন্সটাগ্রামে ব্যবহার করা হয়। ২০১৩ সালে React.js কে ওপেন সোর্স করে দেয় ফেসবুক কোম্পানি। রিয়্যাক্ট এর ওপেন সোর্স গিটহাব রিপোজিটরি React.js এ ভ্যানিলা জাভাস্ক্রিপ্ট ছাড়া আর কিচ্ছু নাই।","reactকেন-ব্যাবহার-করা-উচিতভ্যানিলা-জাভাস্ক্রিপ্ট-এ-কি-প্রব্লেম-#Reactকেন ব্যাবহার করা উচিত,ভ্যানিলা জাভাস্ক্রিপ্ট এ কি প্রব্লেম ?":"যখন আমরা ভ্যানিলা জাভাস্ক্রিপ্ট এ কাজ করি,তখন যেটা হয় যে, ইউজারের ইন্টারেকশনের কারনে যখন কোথাও কোন UI চেঞ্জ করা লাগে, তখন আমাদের প্রতিটা UI চেঞ্জ ম্যানুয়ালি করে দিতে হয়। কিন্তু React এ আমাদের তা করা লাগেনা। রিয়াক্টে ইউজারেরে কোন ইন্টারেকশনের কারনে যখনি কোন ডেটা বা স্টেট চেঞ্জ হয়,তখন UI টা অটোমেটিক রিয়াক্ট করে,এবং UI টা অটোমেটিক চেঞ্জ হয়। এইযে বার বার যেই UI আপডেট করার প্রসেস, এই প্রসেসটাই অটোমেটিক করার জন্যই মূলত রিয়াক্ট তৈরি করাব হয়েছে।","react-এবং-react-dom-কি-#React এবং React DOM কি ?":"একটা UI বানাতে আসলে তিনটা দিক ম্যানেজ করা লাগে,\nUI/ DOM টাকে বানানো।\nUser Interaction হ্যান্ডেল করা।\nDOM টা ব্রাউজারে রেন্ডার করা ।\nReact এবং React DOM এই দুইটা প্যাকেজ আসলে এই কাজগুলোই করে থাকে।React USER INTERFACE বানাতে হেল্প করে এবং ইউজারের ইন্টারেকশনের কারনে যদি কোন ডাটা চেঞ্জ হয় সেটা ম্যানেজ করে।React DOM এই প্যাকেজটা DOM টাকে ব্রাউজারে রেন্ডার করে,এবং একবার ব্রাউজারে রেন্ডার করানো হয়ে গেলে সে ডেটা চেঞ্জ এর জন্য অপেক্ষা করতে থাকে,যদি কোথাও কোন ডেটা চেঞ্জ হয়,তাহলে সে তার VERTUAL DOM এর সেই চেঞ্জটাকে শনাক্ত করে, UI এর যা যা চেঞ্জ করা লাগে তা করে সরাসরি ব্রাউজারে পেইন্ট করে দেয়। এবং ইউজার আপডেটেড UI তা দেখতে পারে।"}},"/reactive-accilarator/React-js/module-1/javascript-in-jsx":{"title":"JavaScript in JSX","data":{"":"JSXএ আমরা জাভাস্ক্রিপ্ট এবং HTML মার্কাপ একসাথে লিখতে পারি। যখনি মার্কাপে কোন ডাইয়ামিক ভ্যালু ব্যাবহার করতে হয়,অথবা কোন লজিকাল অপারেসন চালাতে হয় এমনকি যদি কোন ভ্যারিয়াবল বা অবজেক্টের ভ্যালু এক্সেস করার প্রয়োজন হয়,তখন তা { } ডাবল কার্লি ব্রেসেস এর ভিতরে লিখতে হয়।উদাহরনঃ\nexport default function Profile(name) {\n    let age = 30;\n    return (\n        <div className='profile-card'>\n            <h1>Hello Mr {name}</h1> // name হলো একটা ডাইনামিক ভ্যালূ যা {} দিয়ে\n            জাভাস্ক্রিপ্টের মাধ্যমে লেখা হয়েছে।\n            <p>Your age is {age}</p> // age একটা ভ্যারিয়েবল থেকে পাওয়া ডাইনামিক ভ্যালু\n            যা {} দিয়ে লেখা হয়েছে।\n            <p>\n                You are {age >= 21 ? \"Eligable\" : \"Not Eligable\"} for Marraige\n                // এই লাইনে জাভাস্ক্রিপ্টের মাধ্যমে লজিকাল অপারেশন করা হয়েছে\n            </p>\n        </div>\n    );\n}\nঅর্থাৎ { } দিয়ে এর ভিতরে আমরা জাভাস্ক্রিপ্টের এক্সপ্রেশন লিখতে পারি।","using-double-curlies-css-and-other-objects-in-jsx#Using “double curlies”: CSS and other objects in JSX":"উদাহরনঃ\nexport default function Profile(name) {\n    let age = 30;\n    return (\n        <div\n            className='profile-card'\n            style={{\n                // এই লাইনে অবজেক্ট লেখা হয়েছে\n                backgroundColor: \"gray\",\n                color: \"black\",\n                fontWeight: \"bold\",\n            }}>\n            <h1>Hello Mr {name}</h1> // name হলো একটা ডাইনামিক ভ্যালূ যা {} দিয়ে\n            জাভাস্ক্রিপ্টের মাধ্যমে লেখা হয়েছে।\n            <p>Your age is {age}</p> // age একটা ভ্যারিয়েবল থেকে পাওয়া ডাইনামিক ভ্যালু\n            যা {} দিয়ে লেখা হয়েছে।\n            <p>\n                You are {age >= 21 ? \"Eligable\" : \"Not Eligable\"} for Marraige\n                // এই লাইনে জাভাস্ক্রিপ্টের মাধ্যমে লজিকাল অপারেশন করা হয়েছে\n            </p>\n        </div>\n    );\n}\nযখন JSX এ { } এর ভিতরে কোন অবজেক্ট লিখা লাগবে তখনও একই স্টেপ ফলো করতে হবে, এতে হয়তো মনে হতে পারে যে আমরা দুইবার { } ব্যাবহার করছি, কিন্তু না, প্রথম { } টা হলো জাভাস্ক্রিপ্টের জন্য জায়গা বানানো এবং দ্বিতীয় { } টা হলো অবজেক্ট এর জন্য।"}},"/reactive-accilarator/React-js/module-1/jsx-markup":{"title":"JSX Markup","data":{"jsx-কি-#JSX কি ?":"JSX হলো জাভাস্ক্রিপ্টের একটি সিনট্যাক্স এক্সটেনশন যা আমাদেরকে HTML এর মতো মার্কাপ লিখতে সাহায্য করে । JSX এর বড় সুবিধা হলো এখানে একই জায়গায়(কম্পোনেন্টের ভিতর) জাভাস্ক্রিপ্টের লজিক ও HTML এর মার্কাপ লিখা যায়। যা পরবর্তিতে কোথাও কিছু চেঞ্জ করতে হলে আমাদের এক্সট্রা ফ্লেক্সিবিলিটি দেয়।JSX দেখতে একদম HTML এর মতো হলেও এটা কিন্তু HTML নয়,বরং HTML এর চাইতে অনেক বেশি Strict। JSX এ কোথাও কোন ভুল করলে তা সাথে সাথে Error দিয়ে দেয়।HTML এ আমরা শুধুমাত্র স্ট্যাটিক কন্টেন্ট লিখতে পারি,কিন্তু JSX এ আমারা ডাইনামিক ভ্যালু ব্যাবহার করতে পারি।","jsx-লিখার-রুলসগুলো-কি-কি-#JSX লিখার রুলসগুলো কি কি ?":"JSX এ বেশ কিছু রুলস ফলো করতে হয় তা হলোঃ","1-return-a-single-root-element#1. Return a Single root element:":"JSX এক্টিমাত্র সিঙ্গেল রুট এলিমেন্ট রিটার্ন করতে হবে, যদি মাল্টিপল এলিমেন্ট রিটার্ন করতে হয় তাহলে অবশ্যই একটি প্যারেন্ট এলিমেন্ট দিয়ে wrap করে দিতে হবে। এক্ষেত্র চাইলে <div> </div> এলিমেন্ট ব্যাবহার করা যায়। তবে <div> </div> ব্যাবহার করলে HTML এর Eliment Tree তে একটা অতিরিক্ত <div> </div> এলিমেন্ট রেন্ডার হয়।❌ ভুল\nexport default function Profile() {\n    return (\n            <h1>Hello Mr XX</h1>\n            <p>Your age is 30</p>\n        // এই কোডটা কাজ করবেনা,কারণ দুইটা এলিমেন্টকে রিটার্ন করা হয়েছে\n    );\n}\n✅ সঠিক\nexport default function Profile() {\n    return (\n        <div>\n            <h1>Hello Mr XX</h1>\n            <p>Your age is 30</p>\n        </div>\n        // এই কোডটা কাজ করবে,কারণ দুইটা এলিমেন্টকে একটা প্যারেন্ট `<div> </div>` দিয়ে wrap করা হয়েছে\n    );\n}\nতবে আপানর ইচ্ছা যদি হয় যে আপনি কোন অতিরিক্ত <div> </div> এলিমেন্ট রেন্ডার করবেন না তাহলে, <></> এভাবে ব্যাবহার করতে পারেন। এটাকে বলা হয় Fragment ট্যাগ। আবার যদি কখনও Fragment এর ভিতরে key পাস করা লাগে,তাহলে ফ্রাগমেন্ট <></> এভাবে না লিখে <Fragment></Fragment> এভাবে লিখতে হবে।","কেন-আমাদের-একটি-মূল-jsx-রিটার্ন-করতে-হয়#কেন আমাদের একটি মূল JSX রিটার্ন করতে হয়?":"Credit to : Saffaullah Shuvo\nWell, যে কোন প্রোগ্রামিং এই function থেকে কেবল একটি data type/structure এর ডেটা রিটার্ন করা যায়। যেমন একটি সিম্পল নাম্বার অথবা কোন কমপ্লেক্স ডেটা স্ট্রাকচার,\nfunction returnOne() { return 1; } // দুইটা নাম্বার রিটার্ন করা কি সম্ভব?\nfunction returnTwo() { return (100 500) } // এটা একটা syntax error // তারমানে Compiler এইরকম syntax সাপোর্ট করেনা\nতাহলে দুইটা নাম্বার কি রিটার্ন করা যাবে না? যাবে-\nfunction returnTwo() { return [100, 500]; // আরো অনেকভাবেই করা যায় }\nJSX গুলা যেহেতু javascript Object তাই\nfunction returnTwoJSX() {\nreturn (<h1>Hi</h1> <h2>Hello</h2>)\n }\n  // Behind the scene\n  function returnTwoJSX() {\n   return (\n    {type: 'h1', props: { children: 'Hi'}} // object1\n    {type: 'h2', props: { children: 'Hello'}} // object2\n    )\n    }\n     // তাই এটাও syntax error\nকিন্তু আমরা একটা Array এর ভিতরে রেখে কিংবা একটা প্যারেন্ট এলিমেন্টের ভিতরে রেখে একটা ডেটা হিসেবেই return করতে পারি।\nসল্যুশন ১ - প্যারেন্ট এলিমেন্ট দিয়ে Wrap করে দেয়া\nfunction returnParentJSX() {\n    return (\n        <div>\n            <h1>Hi</h1>\n            <h2>Hello</h2>\n        </div>\n    );\n}\n// Behind the scene\nfunction returnParentJSX() {\n    return {\n        type: \"div\",\n        props: { children: [object1, object2] },\n        // ...additional properties\n    };\n}\nসল্যুশন ২ - প্যারেন্ট হিসেবে Fragment ব্যবহার করা।\nfunction returnFragmentJSX() {\n    return (\n        <Fragment>\n            {\" \"}\n            // short form <></>\n            <h1>Hi</h1>\n            <h2>Hello</h2>\n        </Fragment>\n    );\n}\n// Behind the scene\nfunction returnFragmentJSX() {\n    return {\n        type: Symbol(react.fragment),\n        props: { children: [object1, object2] }, // ...additional property\n    };\n}\nJSX এর বদলে ডিরেক্ট Object Return করলে কি কাজ করবে? যেমনঃ\nfunction returnDirectObject() {\n    return {\n        type: \"div\",\n        props: {\n            className: \"bg-white\",\n            children: [\n                {\n                    type: \"h1\",\n                    props: { className: \"text-2xl\", children: \"Hi\" },\n                },\n                { type: \"p\", props: { children: \"Hello World\" } },\n            ],\n        },\n    };\n}\nনা, কারন এই Object টা React এর ওয়েতে বানানো হয়নি। রিয়েক্ট আরও Additional Property রাখে Object er ভিতর। রিয়েক্ট যেভাবে বানায় -\nimport { createElement } from \"react\";\nfunction returnDirectObject() {\n    return createElement(\n        \"div\",\n        { className: \"bg-white\" },\n        createElement(\"h1\", { className: \"text-2xl\" }, \"Hi\"),\n        createElement(\"p\", null, \"Hello World\")\n    );\n}","2-close-all-the-tags#2. Close all the tags:":"JSX এ ব্যাবহার করা প্রতিটা ট্যাগ অবশ্যই ক্লোজ করা লাগবে। সেলফ ক্লোজিং ট্যাগ যেগুলো আছে যেমনঃ <img>,<hr>,সেগুলোও অবশ্যই এভাবে <img />,<hr /> ক্লোজ করা লাগবে ।","3-camelcase-all-most-of-the-things#3. camelCase all most of the things!:":"JSX এ যেহেতু আমারা JavaScript লিখছি,সেহেতু আমাদের জাভাস্ক্রিপ্ট এর রুলস অনুযায়ী multiple-word এর Attribute গুলোকে camelCase এ লিখতে হবে।class Attribute টা যেহেতু জাভাস্ক্রিপ্টের রিজার্ভ কিওয়ার্ড,তাই আমরা class ব্যাবহার করতে পারবোনা। class এর পরিবর্তে আমদের className ব্যাবহার করতে হবে ।"}},"/reactive-accilarator/React-js/module-1/pure-components":{"title":"Pure Components","data":{"পিওর-ফাংশন-কী#পিওর ফাংশন কী?":"একটি ফাংশনকে পিওর (pure) বলা হয় যদি তা নিচের দুটি শর্ত পূরণ করে:\nসেম ইনপুটের জন্য সেম আউটপুট: পিওর ফাংশন সবসময় তার ইনপুট অনুযায়ী নির্দিষ্ট আউটপুট প্রদান করে। অর্থাৎ একই ইনপুটের জন্য সবসময় একই আউটপুট পাওয়া যাবে।\nসাইড-ইফেক্টের অনুপস্থিতি: পিওর ফাংশন বাইরের কোনো স্টেট বা ভ্যারিয়েবল পরিবর্তন করে না। এটি শুধুমাত্র ইনপুট অনুযায়ী কাজ করে এবং বাইরে কোনো পরিবর্তন আনে না।","পিওর-ফাংশনের-উদাহরণ#পিওর ফাংশনের উদাহরণ:":"function add(a, b) {\n    return a + b;\n}\nএখানে add ফাংশনটি পিওর, কারণ এটি কেবল তার ইনপুট অনুযায়ী আউটপুট দিচ্ছে এবং বাহ্যিক কোনো স্টেট পরিবর্তন করছে না।","ইমপিওর-ফাংশনের-উদাহরণ#ইমপিওর ফাংশনের উদাহরণ:":"let x = 10;\nfunction addWithSideEffect(a, b) {\n    x = a + b; // বাহিরের ভ্যারিয়েবল পরিবর্তন করা হচ্ছে\n    return x;\n}\nএই ফাংশনটি ইমপিওর, কারণ এটি বাহ্যিক ভ্যারিয়েবল x এর মান পরিবর্তন করছে, যা একটি সাইড-ইফেক্ট সৃষ্টি করছে।","কেন-react-এ-পিওর-ফাংশনাল-কম্পোনেন্ট-ব্যবহার-করা-উচিত#কেন React-এ পিওর ফাংশনাল কম্পোনেন্ট ব্যবহার করা উচিত?":"React কম্পোনেন্টগুলোকে পিওর রাখতে রিকমেন্ড, কারণ এতে বেশ কিছু সুবিধা রয়েছে। মূলত, পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের মাধ্যমে React এর পারফরম্যান্স ও ব্যবহারে সুবিধা পাওয়া যায়। আসুন, এই সুবিধাগুলো বিস্তারিতভাবে দেখি:","১-অপ্রয়োজনীয়-রেন্ডার-এড়ানো#১. অপ্রয়োজনীয় রেন্ডার এড়ানো":"React পিওর ফাংশনাল কম্পোনেন্টগুলোর ক্ষেত্রে ইনপুট বা প্রপসে কোনো পরিবর্তন না হলে কম্পোনেন্টটি পুনরায় রেন্ডার করে না। অর্থাৎ, ইনপুট এক থাকলে React আগের আউটপুট ব্যবহার করতে পারে, যা অ্যাপ্লিকেশনের রেন্ডারিংয়ের কার্যকারিতা বৃদ্ধি করে।","উদাহরণ#উদাহরণ:":"import React from \"react\";\nconst Greeting = React.memo(function Greeting({ name }) {\n    console.log(\"Rendering Greeting\");\n    return <h1>Hello, {name}!</h1>;\n});\nএখানে React.memo ব্যবহারের মাধ্যমে এই কম্পোনেন্টকে পিওর করা হয়েছে। যদি name প্রপসের কোনো পরিবর্তন না ঘটে, তাহলে React পূর্বের রেন্ডারকৃত আউটপুটই পুনরায় ব্যবহার করবে, নতুন করে রেন্ডার করা প্রয়োজন হবে না।","২-সহজ-এবং-ক্লিন-কোড#২. সহজ এবং ক্লিন কোড":"পিওর ফাংশনাল কম্পোনেন্টের ব্যবহারে কোড সহজ ও ক্লিন হয়। যেহেতু এগুলো শুধু ইনপুটের ওপর নির্ভরশীল এবং কোনো বাহ্যিক স্টেটের উপর নির্ভর করে না, তাই এগুলো সহজেই বোঝা যায় এবং প্রয়োগ করা যায়।","উদাহরণ-1#উদাহরণ:":"function WelcomeMessage({ user }) {\n    return <p>Welcome, {user}!</p>;\n}\nএই ধরনের কম্পোনেন্ট অত্যন্ত ক্লিন এবং সহজপাঠ্য, কারণ এটি কোনো বাহ্যিক স্টেট পরিবর্তন করে না, বরং শুধুমাত্র প্রপসের মাধ্যমে আউটপুট প্রদান করে।","৩-প্রেডিক্টেবল-আচরণ#৩. প্রেডিক্টেবল আচরণ":"পিওর ফাংশনাল কম্পোনেন্ট সবসময় নির্দিষ্ট ইনপুট অনুযায়ী নির্দিষ্ট আউটপুট দেয়। এতে করে এদের আচরণ প্রেডিক্টেবল হয়, অর্থাৎ আগেভাগেই অনুমান করা সম্ভব। এটি ডিবাগিং এবং বাগ সমাধানের ক্ষেত্রে গুরুত্বপূর্ণ, কারণ আচরণ সবসময় পূর্বানুমানযোগ্য থাকে।","৪-সহজ-টেস্টিং#৪. সহজ টেস্টিং":"পিওর ফাংশনাল কম্পোনেন্ট সহজেই টেস্ট করা যায়, কারণ এগুলো ইনপুট এবং আউটপুটের উপর নির্ভরশীল। ইনপুট অনুযায়ী আউটপুট পরীক্ষা করলেই সহজে বোঝা যায় যে ফাংশনটি সঠিকভাবে কাজ করছে কি না।","উদাহরণ-2#উদাহরণ:":"function sum(a, b) {\n    return a + b;\n}\n// টেস্টিং উদাহরণ:\nconsole.log(sum(2, 3)); // আউটপুট হবে: 5","৫-memoization-এর-সুবিধা#৫. Memoization এর সুবিধা":"React-এ পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের ফলে memoization সহজ হয়। একই ইনপুটের জন্য React আগের আউটপুট সংরক্ষণ করতে পারে, ফলে অপ্রয়োজনীয় রেন্ডার এড়িয়ে পারফরম্যান্স উন্নত করা যায়। React.memo এই কাজে বিশেষভাবে ব্যবহৃত হয়।React-এ পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের মাধ্যমে কোডের সহজ হয়, প্রেডিক্টেবিলিটি এবং পারফরম্যান্স বৃদ্ধি পায়। অপ্রয়োজনীয় রেন্ডারিং এড়ানো, সহজে টেস্ট করা, এবং কোড ক্লিন রাখার জন্য পিওর ফাংশন ব্যবহার অত্যন্ত গুরুত্বপূর্ণ। তাছাড়া, React এর memoization ফিচারের কারণে পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের মাধ্যমে অ্যাপ্লিকেশনের কার্যকারিতা উল্লেখযোগ্যভাবে বৃদ্ধি পায়।","যদি-আমাদেরকে-এমন-কোন-কাজ-করতেই-হয়-যাতে-কম্পোনেন্টের-পিওরিটি-নষ্ট-হলেও-করতে-হবেএমনবস্থায়-কি-করবো-#যদি আমাদেরকে এমন কোন কাজ করতেই হয় যাতে কম্পোনেন্টের পিওরিটি নষ্ট হলেও করতে হবে,এমনবস্থায় কি করবো ?":"হ্যা,এটা ঠিক যে সবসময় কম্পোনেন্টের পিওরিটি বজায় রাখা সম্ভব নাও হতে পারে,আমাদের এমন কিছু করা লাগতে পারে যাতে হয়তো কম্পোনেন্টের পিওরিটি নষ্ট হবে, এমন অবস্থায় আমরা দুটি কাজ করতে পাড়িঃ","manage-with-event-handler#Manage With Event Handler:":"যেসব সাইড-এফেক্টগুলো আমরা event-handler এর মাধ্যমে করতে পারবো,তা আমরা event-handler এর ভিতর করার চেষ্টা করবো। কারণ event-handler রিয়াক্টের রেন্ডারিং টাইমে একটিভ হয়না তাই event-handler পিওর হউয়ার প্রয়োজন নাই ।  event-handler Hydration (রিয়াক্টের কম্পোনেন্ট লোড হউয়ায়র পর যেই টাইমটায় জাভাস্ক্রিপ্ট একটিভ হয়, ওই প্রসেসটা হলো Hydration) টাইমে একটিভ হয়। মূল কোথা হলো যাতে রিয়াক্টের রেন্ডারিং টাইমে কোন সাইড-এফেক্ট না হয় ।","useeffect-হুকের-মাধ্যমে-সাইড-এফেক্ট-ম্যানেজ-করাঃ#useEffect হুকের মাধ্যমে সাইড-এফেক্ট ম্যানেজ করাঃ":"যদি আর কোন উপায় নাই থাকে,তাহলে একেবারে লাস্ট স্টেজ হিসেবে রিয়াক্ট সাইড-এফেক্ট হ্যান্ডেল করার জন্য একটা বিল্ট-ইন হুক দিয়ে দিয়েছে,যার নাম useEffect। এই হুক ব্যাবহার করে সাইড-এফেক্ট ম্যানেজ করতে হবে। এই হুকটাও রিয়াক্টের রেন্ডারিং শেষ হয়ে যাওয়ার পর একটিভ হয়। তাই সাইড-এফেক্ট হ্যান্ডেল করার জন্য এই হুকটা ইউজ করা যেতে পারে,তবে সেটা হলো একেবারে সর্বশেষ রাস্তা।","ফাংশনের-ভিতরের-ভ্যারিয়েবলগুলো-কি-চেঞ্জ-করা-যাবে#ফাংশনের ভিতরের ভ্যারিয়েবলগুলো কি চেঞ্জ করা যাবে?":"হ্যা,ফাংশনের ভিতরের ভ্যারিয়েবল চেঞ্জ করা যাবে। এতে কম্পোনেন্টের পিওরিটি নষ্ট হবেনা। এটাকে বলা হয় local mutation। লোকাল মিউটেশনে কোন সমস্যা নাই।"}},"/reactive-accilarator/React-js/module-1/rendering-list":{"title":"Rendering List","data":{"":"রিয়াক্টে আমাদেরকে প্রায় সময়ই লিস্ট অফ ডাটা বা ডাটা Array থেকে ডাটা রেন্ডার করার প্রয়োজন হয়। সেক্ষেত্রে আমারা map, filter ব্যাবহার করে তা দেখাতে পারি।উদাহরনঃ\nconst users = [\"Mr x\", \"Mr y\", \"Mr z\"];\nexport function ListOfUser() {\n    const user = users.map((person) => <li>{person}</li>);\n    return <ul>{user}</ul>;\n}","key-এর-ব্যাবহারঃ#key এর ব্যাবহারঃ":"লিস্ট অফ আইটেম map করে রেন্ডার করার সময় প্রতিটা লিস্ট এলিমেন্টে অবশ্যই key ব্যাবহার করতে হবে।\nconst users = [\n    {\n        id: 1,\n        name: \"Mr X\",\n    },\n    {\n        id: 2,\n        name: \"Mr XX\",\n    },\n];\nexport function ListOfUser() {\n    const user = users.map((person) => <li key={person.id}>{person.name}</li>);\n    return <ul>{user}</ul>;\n}","key-কিভাবে-পেতে-পারি-#key কিভাবে পেতে পারি ?":"বিভিন্ন ডাটা থেকে বিভিন্ন ভাবে key পেতে পারি, যেমনঃ\nডাটাবেস থেকে প্রাপ্ত ডাটাঃ যেসব ডাটা আমরা ডাটাবেস থেকে পাই সেগুলোর সাথে আমারা অটোমেটিক Id পেয়ে যাই, এই Id আমরা key হিসেবে ব্যাবহার করতে পারি।\nলোকাল ডাটার ক্ষেত্রেঃ যেসব ডাটা লোকালি অটোমেটিক জেনারেটেড হয় সেসব ডাটার ক্ষেত্রে আমারা crypto.randomUUID() অথবা uuid ব্যাবহার করে id/key জেনারেট করে সেভ করতে পারি।","রুলস-অফ-key#রুলস অফ key":"key অবশ্যই ইউনিক হতে হবে। একই লিস্টের বিভিন্ন এলিমেন্টে একই key ব্যাবহার করা যাবেনা।\nkey পরিবর্তন করা যাবেনা বা রেন্ডারিং এর সময়ে key জেনারেট করে ব্যবাহার করা যাবেনা।\nArrayর ইনডেক্সকে কখনো কি হিসেবে ব্যাবহার করা যাবেনা।","রিয়াক্টে-কেন-key-ব্যাবহার-করা-লাগে#রিয়াক্টে কেন key ব্যাবহার করা লাগে?":"রিয়াক্ট তার DOM TREEতে প্রতিটা আইটেমকে ইউনিকভাবে আইডেন্টিফাই করার জন্য keyর প্রয়োজন হয়। যাতে কখনও লিস্ট থেকে কোন আইটেম ডিলিট হয়ে গেলে,বা কখনো sort করা লাগলে যেন রিয়াক্ট সহজে বুঝতে পারে যে কোন আইটেমে পরিবর্তন হয়েছে।"}},"/reactive-accilarator/React-js/module-1/understanding-props":{"title":"Understanding Props","data":{"props-কি-#Props কি ?":"রিয়াক্টে Parent Component থেকে Child Component এ ডাটা প্রদানের জন্য Props ব্যাবহার করা হয়ে থাকে। Props অনেকটা ফাংশনের Parameters এর মতো।আমরা যেভাবে HTML এর Attributes লিখি সেভাবেই Parent Component থেকে Child Component এ Props পাঠাতে পারি।উদাহরনঃ\nexport default function Profile() {\n    return (\n        <Avater //imgurl এবং size নামে দুটি props পাঠানো হয়েছে চাইল্ড কম্পোনেন্ট Avater এ।\n            imgurl='https://example.com/image/1.png'\n            size={100}\n        />\n    );\n}\nexport default function Avater(props) {\n    // parent  Avater কম্পোনেন্ট থেকে props নামে একটা Object হিসেবে props গুলো রিসিভ করা হয়েছে\n    return (\n        <img\n            src={props.imgurl}\n            alt='Avater Image'\n            size={props.size}\n        />\n    );\n}\nProps এ আমরা যেকোন জাভাস্ক্রিপ্ট ভ্যালু পাঠাতে পারি,এমনকি ফাংশন ও পাঠাতে পারি।","কিভাবে-props-পাঠাতে-হয়-এবং-props-রিসিভ-করতে-হয়-#কিভাবে Props পাঠাতে হয় এবং Props রিসিভ করতে হয় ?":"যেভাবে Props পাঠাতে হয় এবং Props রিসিভ করতে হয় নিচে তা বিস্তারিত ব্যাখ্যা করছি।","step-1---pass-props-to-the-child-component#Step 1 :  Pass props to the child component":"export default function Profile() {\n        return (\n          <Avatar\n            person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}\n            size={100}\n          />\n        );\n      }\nএখানে Avatarকম্পোনেন্ট থেকে তার চাইল্ড কম্পোনেন্টে\nperson = যা একটি অবজেক্ট,\nsize = যা একটি নাম্বার,\nপাঠানো হয়েছে।","step-2--read-props-inside-the-child-component#Step 2 : Read props inside the child component":"export default function Avater(props) {\n    return (\n        <img\n            src={props.imgurl}\n            alt='Avater Image'\n            size={props.size}\n        />\n    );\n}\nparent Avater কম্পোনেন্ট থেকে props নামে একটা Object হিসেবে props গুলো রিসিভ করা হয়েছে","distructuring-পদ্ধতিতে-props-রিসিভ-করা-#Distructuring পদ্ধতিতে Props রিসিভ করা ।":"Distructuring পদ্ধতিতে Props রিসিভ করা যায়, সেক্ষেত্রে আমারা এভাবে করতে পারি।\nexport default function Avater({ imgurl, size }) {\n    return (\n        <img\n            src={imgurl}\n            alt='Avater Image'\n            size={size}\n        />\n    );\n}","props-এ-ডিফল্ট-ভ্যালু-ব্যাবহার-করা#Props এ ডিফল্ট ভ্যালু ব্যাবহার করা।":"কখনও কখনও Props এর ভ্যালু Undefined আসতে পারে,তখন আমাদের Props এর ডিফল্ট ভ্যালু সেট করা লাগতে পারে, সেক্ষেত্রে আমারা এভাবে = দিয়ে ডিফল্ট ভ্যালু সেট করতে পারি।\nexport default function Avater({ imgurl, size = 100 }) {\n    return (\n        <img\n            src={imgurl}\n            alt='Avater Image'\n            size={size}\n        />\n    );\n}","forwarding-props-with-the-jsx-spread-syntax#Forwarding props with the JSX spread syntax":"কখনও কখনও এমন হতে পারে যে আমরা কোন কম্পোনেন্ট এ যেই Props গুলো রিসিভ করেছি, তার সবগুলো Props ওই কম্পোনেন্টের ভিতরেই অন্য আরেকটা কম্পোনেন্টের চাইল্ড কম্পোনেন্টে পাঠানো বা ফরওয়ার্ড করা লাগতে পারে। তখন আমরা ওই Props গুলো বার বার না লিখে JSX spread syntax {...props}  পাস করে দিতে পারি।এক্ষেত্রে আমরা মেইন যে কম্পোনেন্ট এ Props গুলো রিসিভ করবো সেখানে আমাদের Distructuring Method রিসিভ না করে props নামক অবজেক্ট হিসেবে ধরতে হবে।উদাহরণঃ","step-1#Step 1:":"প্রথম App কম্পোনেন্ট থেকে Profile কম্পোনেন্টে name,age,gender নামে তিনটা Props পাস করা হয়েছে।\nexport default function App() {\n    return (\n        <div>\n            <div>\n                <Profile\n                    name='Ripon'\n                    age={30}\n                    gender='male'\n                />\n            </div>\n        </div>\n    );\n}","step-2#Step 2:":"এখানে Profile কম্পোনেন্ট এ সমস্ত propsগুলো props নামক অবজেক্ট হিসেবে রিসিভ করা হয়েছে।\nexport default function Profile(props) {\n    return (\n        <div>\n            <Card {...props} />\n        </div>\n    );\n}","step-3#Step 3:":"এখানে Card কম্পোনেন্ট এ সমস্ত propsগুলো {...props} করে Spread করে পাঠানো হয়েছে ।\nexport default function Profile(props) {\n    return (\n        <div>\n            <Card {...props} />\n        </div>\n    );\n}","চিলড্রেন-প্রপ্স-হিসেবে-jsxবা-component-পাঠানো#চিলড্রেন প্রপ্স হিসেবে JSXবা Component পাঠানো।":"আমরা একটা কম্পোনেন্ট দিয়ে wrap করে অন্য আরেকটা Component কে Props হিসেবে পাঠাতে পারি। এটাকে বলা হয় children Props। এবং রিসিভ করার সময়ও সেটাকে children নামেই রিসিভ করতে হয়।\nexport default function Profile() {\n    return (\n        <Card>\n            <Profile />\n        </Card>\n    );\n}\nexport default function Card({ children }) {\n    // এখানে `Profile` কম্পোনেন্টকে `children` হিসেবে রিসিভ করা হয়েছে।\n    return (\n        <div className='card'>\n            <h1>This is Profile Card</h1>\n            {children}\n        </div>\n    );\n}","props-are-immutable-why-#Props are Immutable: why ?":"Props গুলো সরাসরি চেঞ্জ করা যায়না। কারণ props হলো Immutable. props কে শুধুমাত্র Parent Component থেকে State দ্বারা ম্যানেজ করতে হয়। কখনো কোন ইউজারের ইন্টারেকশনের কারনে যদি props এর ভ্যালু চেঞ্জ করা লাগে, তাহলে রিয়াক্ট তখন নতুন Props পাস করে Child Component এ। কিন্তু কখনই আগের পাঠানো props কে পরিবর্তন করেনা।নতুন Props পাঠানোর পর আগের Propsটা কে জাভাস্ক্রিপ্ট মেমরি থেকে ফেলে দেয় বা গার্বেজ কালেক্টেড করে ফেলে।তাই কখনই Child Component এর ভিতর Props এর ভ্যালূ পরিবর্তন বা ওভাররাইড করা যাবেনা।"}},"/reactive-accilarator/React-js/module-1/vertual-dom":{"title":"Vertual Dom","data":{"dom-কি-আসলেই-স্লো#DOM কি আসলেই স্লো?":"নাহ, ডম কখনোই স্লো না । আসলে যদি ভালোভাবে কোড করা হয় তাহলে ডম যেকোন কিছুর থেকে ফাস্ট। কিন্তু বর্তমান বিশ্বে ওয়েব অ্যাপ্লিকেশনগুলো অনেক বেশি ইন্টারেক্টিভ,তাই যখনই ইউজার কোন ইন্টারেকশন করে তখন ব্রাউজারকে আবার তা নতুন করে পুরো ওয়েবসাইটটা রি-পেইন্ট করতে হয়। এইরকম যখন অনেকগুলো রিয়াকশনের কারনে ব্রাউজারকে বার বার রি পেইন্ট করতে হয় তখন সেই রি-পেইন্টিং প্রসেসটা স্লো হয়ে যায়,মুলত ডম কিন্তু স্লো নয় ।","ব্রাউজার-কিভাবে-dom-রেন্ডার-করে-#ব্রাউজার কিভাবে DOM রেন্ডার করে ?":"আমরা দেখতে পাচ্ছি যে উপরে একটা গ্রাফ এর মাদ্ধমে ব্রাউজার এর রেন্ডারিং প্রসেস দেখানো হয়েছে । এখানে আমরা কি দেখতে পাচ্ছি ? আমরা দেখতে পাচ্ছি যে, যখন ব্রাউজার কোন HTML CSS ফাইল পায়,তখন সেই ফাইলটা একটা পারসিং এর মদ্ধে দিয়ে নিয়ে যায়, এক্ষেত্রে HTML এর জন্য HTML PARSER ও CSS এর জন্য CSS PERSER ব্যাবহার হয়। এসব পারসার দিয়ে পারসিং এর পর ব্রাউসার HTML দিয়ে একটা DOM TREE বানায় এর CSS দিয়ে CSSOM নামে একটা STYLE RULES বানায় , এবং DOM TREE ও STYLE RULES একসাথে ATTACH হয়ে একটা RENDER TREE বানায়। এই RENDER TREE ব্রাউসারে একটা LAYOUT ফেস এর মদ্ধে দিয়ে যায়। এই LAYOUT ফেস এ DOM TREE টা ব্রাউসার এর কোথায় রেন্ডার হবে তার একটা CORDINATE রেডি হয়ে যায় । এবং ফাইনালি ব্রাউজার তার PAINTING মেকানিজম এর মাদ্ধমে তা ব্রাউসারে পেইন্ট করে দেয় এবং আমরা ফাইনাল আউটপুট দেখতে পাই।","ভার্চুয়াল-ডম-কি--কিভাবে-ভার্চুয়াল-ডম-কাজ-করে#ভার্চুয়াল ডম কি ? কিভাবে ভার্চুয়াল ডম কাজ করে?":"ভার্চুয়াল ডম রিয়াক্ট এর একটা ফান্ডামেন্টাল বিষয় । রিয়াক্ট এর ভিত্তিটাই মূলত এই ভার্চুয়াল ডম ।ব্রাউজারের রি-পেন্টিং প্রসেসটা এপ্লিকেশনকে স্লো ডাউন করে দেয়, এই সমস্যা এড়ানোর জন্য আমরা কি করতে পারি ভাবুনতো। আমরা মূলত দুইটা ভাবে এটার সমাধান করতে পারি :\nআমরা ব্যাচ আপডেট করতে পারি,\nআমরা ডম ম্যানুপুলেশন কম করতে পারি।\nরিয়াক্ট তার ভার্চুয়াল ডমের মাদ্ধমে সেই কাজটাই করে । রিয়াক্ট একেবারে মিনিমাম ডম ম্যানুপুলেশন করে ।যখন এপ্লিকেশনে কোন ইউজার কোন ইন্টারেকশন করে তখন যদি UI তে কোন চেঞ্জ করতে হয় তখন রিয়াক্ট সরাসরি HTML এর DOM TREE টাকে চেঞ্জ করে দেয়না। যখনি UI তে কোন চেঞ্জ আসে,রিয়াক্ট তার ভার্চুয়াল DOM এর সাহায্যে UI এর একটা রেপ্লিকা বা কপি বানিয়ে নেয় । তারপর রিয়াক্ট তার একটা নিজস্ব বানানো এলগরিদম Diffng বা Reconciliation এলগরিদম এর মাদ্ধমে চেক করে যে UI এর ঠিক কোন জায়গায় চেঞ্জ হয়েছে । এতে করে পুরো ওয়েবসাইটটা রি-রেন্ডার না করে শুধুমাত্র যেই অংশে পরিবর্তন হয়েছে,সেই অংশটুকু DOM এ আপডেট করে দেয়। এতে করে রিয়াক্ট মিনিমাম ডম অপারেশনের মাদ্ধমে এপ্লিকেশনএর পার্ফমেন্স ইম্প্রুভ করে ।"}},"/reactive-accilarator/React-js/module-1/your-ui-as-a-tree":{"title":"Your UI as a Tree","data":{"রেন্ডার-ট্রি-render-tree-এবং-মডিউল-ট্রি-module-tree--রিয়াক্টের-প্রেক্ষাপটে#রেন্ডার ট্রি (Render Tree) এবং মডিউল ট্রি (Module Tree) – রিয়াক্টের প্রেক্ষাপটে":"","১-রেন্ডার-ট্রি-render-tree-কী#১. রেন্ডার ট্রি (Render Tree) কী?":"রেন্ডার ট্রি হলো ডকুমেন্ট অবজেক্ট মডেল (DOM) এবং স্টাইলিং ইনফরমেশন (CSS) এর সম্মিলিত রূপ। এটি একটি ট্রি স্ট্রাকচার যেখানে প্রতিটি নোড একটি UI এলিমেন্টের প্রতিনিধিত্ব করে।রিয়াক্টে, আমরা JSX দিয়ে কম্পোনেন্ট লিখি, যা শেষে HTML DOM এ রূপান্তরিত হয়। রিয়াক্ট তখন একটি ভার্চুয়াল DOM তৈরি করে এবং সেই DOM এর ওপর কাজ করে।","রেন্ডার-ট্রি-কিভাবে-কাজ-করে#রেন্ডার ট্রি কিভাবে কাজ করে?":"DOM ও CSSOM তৈরি: প্রথমে ব্রাউজার HTML থেকে একটি DOM (ডকুমেন্ট অবজেক্ট মডেল) তৈরি করে। তারপর CSS থেকে CSSOM (CSS অবজেক্ট মডেল) তৈরি করে।\nরেন্ডার ট্রি নির্মাণ: DOM এবং CSSOM একসাথে মিলে রেন্ডার ট্রি তৈরি করে।\nলেআউট এবং পেইন্টিং: এরপর ব্রাউজার প্রতিটি এলিমেন্টকে তার যথাযথ জায়গায় বসিয়ে দেয় (লেআউট), এবং পরিশেষে সেই এলিমেন্টগুলোকে পেইন্ট করে।","রেন্ডার-ট্রির-প্রয়োজনীয়তা-ও-সুবিধা#রেন্ডার ট্রির প্রয়োজনীয়তা ও সুবিধা:":"রেন্ডার ট্রি প্রয়োজন, কারণ এটি ব্রাউজারের কাছে নির্দিষ্ট ভাবে জানায়, কিভাবে পেজটি দেখাবে।\nএর মাধ্যমে DOM এর পরিবর্তন হলে, ব্রাউজার শুধু সংশ্লিষ্ট অংশটুকু পুনরায় রেন্ডার করে। ফলে পারফরম্যান্স বৃদ্ধি পায়।\nরিয়াক্টের ভি-ডম (Virtual DOM) রেন্ডার ট্রির উপর ভিত্তি করে কাজ করে। ভি-ডম পারফরম্যান্স অপটিমাইজ করার জন্য রেন্ডার ট্রির শুধুমাত্র পরিবর্তিত অংশ পুনরায় আপডেট করে।","উদাহরণ#উদাহরণ:":"function App() {\n    return (\n        <div>\n            <h1>React Render Tree Example</h1>\n            <p>This is a paragraph.</p>\n        </div>\n    );\n}\ndiv এবং তার child nodes (h1 এবং p) একসাথে রেন্ডার ট্রি তৈরি করবে।\nযদি শুধু p ট্যাগ আপডেট হয়, রিয়াক্ট শুধুমাত্র সেই অংশে রেন্ডার করবে, বাকি অংশ অপরিবর্তিত থাকবে।","২-মডিউল-ট্রি-module-tree-কী#২. মডিউল ট্রি (Module Tree) কী?":"মডিউল ট্রি হলো আমাদের অ্যাপ্লিকেশনের সব জাভাস্ক্রিপ্ট মডিউলগুলোর একটি ডিপেনডেন্সি চেইন। এটি দেখায় কোন মডিউলটি কোন মডিউলের উপর নির্ভর করে।","মডিউল-ট্রি-কিভাবে-কাজ-করে#মডিউল ট্রি কিভাবে কাজ করে?":"রিয়াক্ট এবং অন্যান্য মডুলার ফ্রেমওয়ার্কে, বিভিন্ন ফাইল/মডিউল একে অপরের উপর নির্ভর করে কাজ করে। Webpack বা অন্য কোন মডিউল বান্ডলার, মডিউলগুলোকে একটি ট্রি স্ট্রাকচারে সাজায় যেখানে প্রতিটি মডিউল অন্য মডিউলের সাথে সম্পর্কিত হয়।","উদাহরণ-1#উদাহরণ:":"ধরা যাক, আপনার তিনটি ফাইল আছে: App.js, Header.js, এবং Footer.js। App.js তে আপনি Header.js এবং Footer.js কে ইম্পোর্ট করছেন।\n// App.js\nimport Header from \"./Header\";\nimport Footer from \"./Footer\";\nfunction App() {\n    return (\n        <>\n            <Header />\n            <Footer />\n        </>\n    );\n}\nexport default App;\nএখানে মডিউল ট্রি এরূপ হবে:\nApp.js\n  ├── Header.js\n  └── Footer.js","মডিউল-ট্রির-প্রয়োজনীয়তা-ও-সুবিধা#মডিউল ট্রির প্রয়োজনীয়তা ও সুবিধা:":"মডিউল ট্রির কারণে অ্যাপ্লিকেশনকে ছোট ছোট মডিউলে ভাগ করা সম্ভব হয়, যা রক্ষণাবেক্ষণ সহজ করে।\nএটি কোডের পুনরায় ব্যবহারযোগ্যতা বাড়ায়।\nমডিউল ডিপেনডেন্সি বুঝতে এবং অপ্রয়োজনীয় মডিউল বাদ দিতে সাহায্য করে।","রেন্ডার-ট্রি-এবং-মডিউল-ট্রির-সম্মিলিত-কাজ#রেন্ডার ট্রি এবং মডিউল ট্রির সম্মিলিত কাজ":"রিয়াক্ট অ্যাপ্লিকেশন যখন ব্রাউজারে চলে, তখন মডিউল ট্রি মডিউলগুলোকে লোড এবং রিজলভ করে এবং এরপর রেন্ডার ট্রি সেই সব মডিউল থেকে UI রেন্ডার করে।","ইলাস্ট্রেশন#ইলাস্ট্রেশন:":"রেন্ডার ট্রি: একটি গাছের মতো যেখানে প্রতিটি শাখা DOM এর একটি অংশ। শীর্ষে div থাকে এবং তার নিচে child elements।\nমডিউল ট্রি: একটি ডিপেনডেন্সি গাছ যেখানে App.js হলো মূল শাখা এবং অন্যান্য child modules তার সাথে যুক্ত থাকে।","সংক্ষেপে#সংক্ষেপে:":"রেন্ডার ট্রি UI কে ব্রাউজারে দেখানোর জন্য DOM এবং CSSOM এর সম্মিলিত অবস্থা।\nমডিউল ট্রি অ্যাপ্লিকেশনের মডিউলগুলো একে অপরের সাথে কিভাবে সংযুক্ত তা বুঝায়।"}},"/reactive-accilarator/React-js/module-2/how-rendering-works":{"title":"How Rendering Works","data":{"":"রিয়াক্ট এপ্লিকেশনে আমরা ব্রাউজার স্ক্রিনে যা কিছু দেখি তার সবকিছুই রিয়াক্টের দ্বারা রেন্ডার হয়ে আসতে হয় ।","রেন্ডার-এবং-কমিট#রেন্ডার এবং কমিট":"এই যে স্ক্রিনে আমরা UI দেখতে পাই তা রিয়াক্টের তিনটা প্রসেসের পর স্ক্রিনে ভিসিবল হয় । চলুন তাহলে জেনে নেই রিয়াক্টের রেন্ডারিং এর এই তিনটা প্রসেস কি আর কিভাবে কাজ করে ।\nTrigering a render:\nRendering the component:\nCommiting to the DOM:","trigger-a-render-ট্রিগারিং-স্টেপ#Trigger a render (ট্রিগারিং স্টেপ):":"মূলত দুইটা করনে রিয়াক্টের render মেথডটা কল হয় বা রেন্ডারিং ট্রিগার হয়ঃ\nইনিশিয়াল রেন্ডার (initial render): একদম সর্বপ্রথম যখন এপ্লিকেশন রান হয় তখন রিয়াক্ট HTML এর একটা root এলিমেন্টের ভিতর রিয়াক্টের সমস্ত কম্পোনেন্টকে রেন্ডার করে দেয় তার React.render() মেথডটাকে কল করার মাধ্যমে ।\nযখন কোন স্টেট আপডেট হয় (Re-render when state update): প্রথমবার সমস্ত কম্পোনেন্ট UI তে এসে যাওয়ার পর, যখন কোন কম্পোনেন্টের ভিতরে কোন স্টেট চেঞ্জ হয় তখন রিয়াক্ট অটেমেটিক ভাবে তার render() মেথডকে কল করে বা রি-রেন্ডার ট্রিগার হয় ।","react-render-your-component-রেন্ডারিং-স্টেপ#React render your component (রেন্ডারিং স্টেপ):":"যখন রিয়াক্টের রেন্ডারিং টা ট্রিগার হয় তখন রিয়াক্ট তার কম্পোনেন্টগুলোকে কল করে। যাতে সে বুঝতে পারে কোথায় পরিবর্তনটা হয়েছে।\nএক্ষেত্রে প্রথম রেন্ডারে রিয়াক্ট তার রুট (root) কম্পোনেন্টকে কল করে\nপরবর্তি সময়ে রি-রেন্ডার ট্রিগার হলে যেই কম্পোনেন্ট থেকে রি-রেন্ডার ট্রিগার হয়েছে সেই কম্পোনেন্টকে কল করে এবং তার প্রথম রেন্ডারের যে Render Tree তার একটা snapshot নিয়ে রাখে এবং পরবর্তি রেন্ডারেরে একটা snapshot নিয়ে তার ভার্চুয়াল ডম এ Diffing এলগরিদমের মাধ্যমে কেলকুলেট করে যে কোথায় পরিবর্তন হয়েছে । তারপর সে নেক্সট স্টেপে চলে যায় কমিট করার জন্য ।\nরেন্ডারিং প্রসেসটা রিকারসিভলি হয়ে থাকে, তার মানে হলো রিয়াক্ট রেন্ডারিং এ যেই কম্পোনেন্টকে কল করেছে তার ভিতর যদি নেস্টেড আরও কোন কম্পোনেন্ট থাকে সেগুলাও রি-রেন্ডার হয়","react-commits-changes-to-the-dom-কমিটিং-স্টেপ#React Commits changes to the DOM (কমিটিং স্টেপ):":"কমিটিং ফেজে এসে রিয়াক্ট DOM মডিফাই করে । এক্ষেত্রে,\nপ্রথম রেন্ডারে রিয়াক্ট DOM এর appendChild() কল করে সমস্ত DOM Nodesগুলোকে রুট এলিমেটে এড করে দেয়\nরি-রেন্ডারের ক্ষেত্রে রিয়াক্ট তার ভার্চুয়াল ডম এ যেই অংশটুকুর পরিবর্তন ডিটেক্ট করতে পারে শুধুমাত্র সেই অংশটুকু DOMএ চেঞ্জ করে দেয়\nপ্রথমবার রেন্ডার হয়ে যাওয়ার পর রিয়াক্ট শুধু তখনি DOM এ চেঞ্জ করে যখন সে দেখতে পারে আগের রেন্ডার এবং পরের রেন্ডারে কোন পার্থক্য আছে। যেই সকল কম্পোনেন্টে কোন প্রকার চেঞ্জ দেখা যায়না রিয়াক্ট সেই সকল কম্পোনেন্টে হাত ই দেয়না।","সবশেষে-ব্রাউজার-পেইন্ট-হয়ঃ#সবশেষে ব্রাউজার পেইন্ট হয়ঃ":"রেন্ডারিং এবং কমিট হয়ে যাওয়ার পর যখন রিয়াক্ট তার DOM টাকে আপডেট করে ফেলে,তখন সে Updated DOMটা ব্রাউজারকে দিয়ে দেয়। এবং ব্রাউজার তা স্ক্রিনে রি-পেইন্ট করে দেয়।"}},"/reactive-accilarator/React-js/module-2/event-propagation":{"title":"Event Propagation","data":{"ইভেন্ট-ডেলিগেশন-event-deligation-কি-#ইভেন্ট ডেলিগেশন (event deligation) কি ?":"ইভেন্ট ডেলিগেশন হলো একাধিক এলিমেন্টের জন্য একটাই ইভেন্ট লিসেনার রাখা এবং নতুন কোন এলিমেন্ট যুক্ত হলেও যেন লিসেনার কাজ করে ।ইভেন্ট ডেলিগেশন হলো এমন একটা টেকনিক যা মূলত দুইটা জিনিসে ফোকাস করেঃ-\nএকাধিক এলিমেন্টের জন্য একটাই ইভেন্ট লিসেনার থাকবে ।\nযদি কখনো নতুন এলিমেন্ট যুক্ত হয় তাতেও যেন ইভেন্ট লিসেনার ঠিকঠাক ভাবে কাজ করে।\nধরুন আমাদের একটি প্রোডাক্টের ডাটার লিস্ট আছে যা API থেকে আসতেছে। এবং আমরা চাই এই প্রতিটা ডাটার জন্য এমন একটা ফাংশনালিটি বানাতে যাতে প্রতিটা ডাটার নামে উপর ক্লিক করলেই সেই ডাটার নামের পিছনে একটা ব্যাকগ্রাউন্ড কালার যুক্ত হবে।এখন বিষয়টি এমন ভাবে করতে পারি যে আমরা প্রতিটা আইটেমকে ধরে ধরে তাতে ইভেন্ট লিসেনার লাগিয়ে কাজ করতে পারি। এতে হয়তো একটা সমাধান হতে পারে, কিন্তু যেহেতু ডাটাগুলো API থেকে আসছে তাই আমরা জানিনা হয়তো ডাটার সংখ্যা চেঞ্জ হয়ে যেতে পারে,বা ডাটা বারতে পারে। তখন কি প্রতিটা বারতি ডাটার জন্য আমরা প্রতিবার ইভেন্ট লিসেনার এড করবো ? এটা কখনই সম্ভব না। তাছাড়া প্রতিটা এলিমেন্টের জন্য আলাদা আলাদা লিসেনার এড করতে গেলেও ব্যাপারটা messy হয়ে যাবে। তাহলে উপায় ? উপায় হলো ইভেন্ট ডেলিগেশন টেকনিকচলুন জেনে নেই সেটা কিভাবে করেঃ\n<div class='list-of-item'>\n    <ul id='list'>\n        <li class='item'>Apple</li>\n        <li class='item'>Orange</li>\n        <li class='item'>Strawberry</li>\n        <li class='item'>Banana</li>\n    </ul>\n</div>\nউপরের এই লিস্ট অফ আইটেমগুলোতে আমরা ইভেন্ট ডেলিগেশন টেকনিক এপ্লাই করবো। এতে আমাদের item গুলোর প্যারেন্ট এলিমেন্ট ul এ গিয়ে ইভেন্ট লিসেনার এড করা লাগবে। যাতে আমরা একটা লিসেনার দিয়েই সমস্ত itemগুলোকে ধরতে পারি।\nconst list = document.getElimentById(\"list\");\nlist.addEventListener(\"click\", (e) => {\n    e.target.style.backgroundColor = \"yellow\";\n});\nএখানে আমরা itemগুলোর প্যারেন্ট এলিমেন্ট ulএ ইভেন্ট লিসেনার এড করেছি এবং প্রতিবার ক্লিক এ e.target করে যেটাতে ক্লিক করা হয়েছে সেটাতে ব্যাকগ্রাউন্ড কালার এড করেছি। এর মাধ্যমেই আমরা ইভেন্ট ডেলিগেশন করে ফেলেছি। মানে আমরা ইভেন্টটাকে প্যারেন্টের কাছে ডেলিগেট করেছি।এখন কথা হলো যে, এতে তো ul এর এরিয়াতে ক্লিক পড়লে ul এও ব্যকগ্রাউণ্ড কালার চেঞ্জ হয়ে যাবে।সেক্ষেত্রে আমাদের হেল্প করবে html DOM এর element.matches() মেথড।element.matches()মেথড string হিসেবে একটা ভ্যালু নেয় এবং তা ম্যাচ করে দেখে যে এলিমেন্টের সাথে ম্যাচ করেছে কিনা, এবং Boolean ভ্যালু রিটার্ন করে।তাহলে আমরা এভাবে করতে পারিঃ\nconst list = document.getElimentById(\"list\");\nlist.addEventListener(\"click\", (e) => {\n    if(e.target.matches(\"li\"){\n        e.target.style.backgroundColor = \"yellow\";\n    }\n});\nএভাবে করলে দেখবেন যদি লিস্ট এ নতুন আইটেম যুক্তও হয় তবুও এই একটা লিসেনারই ঠিকঠাক ভাবে কাজ করবে।এটাকেই মূলত ইভেন্ট ডেলিগেশন বলা হয়ে থাকে।","ইভেন্ট-প্রপাগেশন-event-propagation-কি-#ইভেন্ট প্রপাগেশন (event propagation) কি ?":"প্রপাগেশন শব্দের বাংলা অর্থ হলো বিস্তার করা বা প্রসারণ করা বা চলাচল করা।ইভেন্ট প্রপাগেশন হলো জাভাস্ক্রিপ্টের একটা টার্ম । মূলত ইভেন্ট প্রপাগেশন বলতে বুঝায়, যে যদি কোন নেস্টেড এলিমেন্ট থাকে এবং তার প্রতিটা এলিমেন্টেই একটা করে ইভেন্ড লিসেনার এড করা থাকে,তখন যদি একদম ভিতরের কোন এলিমেন্ট ইভেন্টটা ট্রিগার করা হয় তখন আসলে কি ঘটবে?যেমনঃউপরের ছবিতে আমরা তিনটা নেস্টেড এলিমেন্ট দেখতে পাচ্ছি যার প্রতিটাতেই ইভেন্ট লিসেনার এড করা আছে। এবং লিসেনার গুলো এলিমেন্টগুলোতে ক্লিক করলে ট্রিগার হবে।\n<div class='main'>\n    <div class='parent'>\n        <button>Click Me</button>\n    </div>\n</div>\nconst main = document.querySelector(\".main\");\nconst parent = main.querySelector(\".parent\");\nconst button = parent.querySelector(\"button\");\nmain.addEventListener(\"click\", listener);\nparent.addEventListener(\"click\", listener);\nbutton.addEventListener(\"click\", listener);\nfunction listener() {\n    console.log(e.target);\n}\nএখন যদি আমরা button এলিমেন্টে ক্লিক করবো তাহলে আমরা দেখতে পাবো প্রতিটা লিসেনার এ কল হয়ে গেছে এবং কনসল এ তিনটার আউটপুট এসেছে । এইযে একটা ব্যাপার যে ক্লিক করলাম একটাতে আর লিসেনার কল হয়ে গেল তিনটাই, এই ব্যাপারটাকেই বলা হয় event Propagation। মানে ইভেন্টগুলো বাকিদের মাঝেও ছড়িয়ে গেছে।","ইভেন্ট-বাবলিং-bubbling-কি-#ইভেন্ট বাবলিং (Bubbling) কি ?":"const main = document.querySelector(\".main\");\nconst parent = main.querySelector(\".parent\");\nconst button = parent.querySelector(\"button\");\nmain.addEventListener(\"click\", listener);\nparent.addEventListener(\"click\", listener);\nbutton.addEventListener(\"click\", listener);\nfunction listener() {\n    console.log(e.currentTarget);\n}\nআউটপুটঃউপরের কোডটার আউটপুট দেখলে আমরা বুঝতে পারবো যে প্রথমে button তারপর parent এবং সবশেষে main এলিমেন্টে ইভেন্ট লিসেনার ট্রিগার হয়েছে, তার মানে হলো প্রপাগেশন ভিতর থেকে শুরু হয়ে বাহিরের দিয়ে যায়। এটাই হলো প্রোপাগেশন এর ডিফল্ট বিহেবিয়ার। এই যে ভিতর থেকে শুরু হলে বাহিরের দিয়ে ছড়িয়ে যাওয়ার ব্যাপারটাকে অনেকটা বাবল এর মতো চিন্তা করা হয়, তাই একে বলা হয় ইভেন্ট বাবলিং (event bubbling)","ইভেন্ট-কেপচারিং-বা-ট্রিকলিং-capturing-or-trickling-কি-#ইভেন্ট কেপচারিং বা ট্রিকলিং (capturing or trickling) কি ?":"আমরা ইভেন্ট প্রপাগেশনের ডিফল্ট বিহেবিয়ার জানলাম যে প্রপাগেশন ভিতর থেকে শুরু হয়ে বাহিরের দিকে ছড়ায়, কিন্তু আমরা চাইলে এটাকে চেঞ্জ করতে পারি, আমরা চাইলে এটাকে পরিবর্তন করে বাহির থেকে শুরু করে ভিতর দিকে নিতে পারি।তারজন্য আমাদের ইভেন্ট লিসেনার এর তৃতীয় প্যারামিটার এ {capture:true} করে দিতে হয়। ডিফল্টভাবে {capture:false} করা থাকে।\nconst main = document.querySelector(\".main\");\nconst parent = main.querySelector(\".parent\");\nconst button = parent.querySelector(\"button\");\nmain.addEventListener(\"click\", listener, { capture: true });\nparent.addEventListener(\"click\", listener, { capture: true });\nbutton.addEventListener(\"click\", listener, { capture: true });\nfunction listener() {\n    console.log(e.currentTarget);\n}\nআউটপুটঃএইযে আমরা প্রপাগেশনকে capture করে এর ডিরেকশন চেঞ্জ করলাম এটাকে বলা হয় ইভেন্ট কেপচারিং বা ট্রিকলিং (capturing or trickling)।","propagation-in-react#Propagation in React":"রিয়াক্টে সকল ইভেন্ট ই প্রপাগেট হয়,শুধুমাত্র onScroll ইভেন্ট ছাড়া ।","কিভাবে-রিয়াক্টে-প্রপাগেশন-স্টপ-করতে-হয়-#কিভাবে রিয়াক্টে প্রপাগেশন স্টপ করতে হয় ?":"রিয়াক্টে প্রপাগেশন স্টপ করার জন্য event handler এর ভিতরে e.stopPropagation() মেথড কল করে দিতে হয় ।\nfunction Button({ onClick, children }) {\n    return (\n        <button\n            onClick={(e) => {\n                e.stopPropagation(); // এখানে প্রপাগেশন স্টপ করা হয়েছে\n                onClick();\n            }}>\n            {children}\n        </button>\n    );\n}\nexport default function Toolbar() {\n    // এই কম্পোনেন্টে তিনটা এলিমেট আছে নেস্টেড ভাবে এবং প্রতিটা এলিমেন্টেই ইভেন্ট হ্যান্ডেলার এড করা আছে। তার মানে ডিফল্ট ভাবে এখানে প্রপাগেশন হবে ।\n    return (\n        <div\n            className='Toolbar'\n            onClick={() => {\n                alert(\"You clicked on the toolbar!\");\n            }}>\n            <Button onClick={() => alert(\"Playing!\")}>Play Movie</Button>\n            <Button onClick={() => alert(\"Uploading!\")}>Upload Image</Button>\n        </div>\n    );\n}","preventing-the-default-behavior#Preventing the default behavior":"আমরা যখন কোন ফর্ম এর সাবমিট বাটনে ক্লিক করি,তখন ফর্মের ডিফল্ট বিহেবিয়ার হলো ফর্মটা সাবমিট হউয়ার সাথে সাথে ব্রাউজারে পেজটাও রিলোড হয়।আমরা যদি এই ডিফল্ট বিহেবিয়ার কে বন্ধ করতে চাই, তাহলে আমরা e.preventDefault() মেথড কল করে দিতে পারি।\nexport default function Signup() {\n    return (\n        <form\n            onSubmit={(e) => {\n                e.preventDefault();\n                alert(\"Submitting!\");\n            }}>\n            <input />\n            <button>Send</button>\n        </form>\n    );\n}"}},"/reactive-accilarator/React-js/module-2/queueing-state":{"title":"Queueing State","data":{"":"রিয়াক্ট প্রতিটা রেন্ডারে মাল্টিপল স্টেট আপডেটকে Queue হিসেবে নেয় এবং একসাথে ব্যাচ করে আপডেট করে । এজন্য বলা হয় React Queueing a Series of State Updates চলুন এ-ব্যাপেরে বিস্তারিত বুঝিঃ","react-batches-multiple-state-updates-রিয়াক্ট-মাল্টিপল-স্টেট-আপডেট-গুলোকে-ব্যাচ-করে#React batches multiple state updates (রিয়াক্ট মাল্টিপল স্টেট আপডেট গুলোকে ব্যাচ করে):":"চলুন একটা কোডের মাধ্যমে বুঝিঃচিন্তা করুন আপনি হোটেলে এসেছেন এবং হোটেলের ওয়েটারকে হয়তো কোন একটা ডিস অর্ডার করেছেন, এবং কিছুক্ষণ পর ওয়েটার আপনাকে আপনার ডিসের অবস্থা জানাবে বা পরিবেশন করবে ।চলুন এবার একটু কোডের দিকে তাকাই,\nimport { useState } from \"react\";\nexport default function App() {\n    const [disStatus, setDishStatus] = useState(\n        \"মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে\"\n    );\n    return (\n        <>\n            <h1>{disStatus}</h1>\n            <button\n                onClick={() => {\n                    setDishStatus(\"আপনার ডিশটি রান্না করা হচ্ছে\");\n                    setDishStatus(\"আপনার ডিসটি রান্না করা হয়ে গেছে\");\n                    setDishStatus(\n                        \"আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস\"\n                    );\n                }}>\n                আমাদের ডিসের কি অবস্থা ?\n            </button>\n        </>\n    );\n}\nআপনি যখন ওর্ডার দিয়েছেন তখন আপনার ডিশের স্টেট হলো মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে যা এই কোডে রিয়াক্টের ইনিশিয়াল স্টেট।এরপর আপনি আপনার ডিসের অবস্থা জানার জন্য আমাদের ডিসের কি অবস্থা ? button এ ক্লিক করলেন ।আপনি যখন বাটনে ক্লিক করলেন তখন বাটনের হেন্ডেলার ফাংশনের ভিতরে তিনটি ধাপে আপনার ডিসের স্ট্যাটাস চেঞ্জ হচ্ছে বা স্টেট আপডেট হচ্ছে।\nপ্রথম স্টেট আপডেটে ডিসের স্ট্যাটাস disStatus করা হয়েছে আপনার ডিশটি রান্না করা হচ্ছে\nদ্বিতীয় স্টেট আপডেটে ডিসের স্ট্যাটাস disStatus করা হয়েছে আপনার ডিসটি রান্না করা হয়ে গেছে\nতৃতীয় স্টেট আপডেটে ডিসের স্ট্যাটাস disStatus করা হয়েছে আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস\nএখন কি মনে হচ্ছে, আপনি কয়টি স্ট্যাটাস দেখতে পাবেন স্ক্রিনে ? পরপর তিনটি স্ট্যাটাস ই কি দেখতে পাওয়ার কথা যেহেতু এখানে তিনবার স্টেট চেঞ্জ হয়েছে তাহলে তিনবার কম্পোনেন্ট রি-রেন্ডার হবে এবং তিনবার এ তিনটি স্ট্যাটাস দেখতে পাওয়া যাবে ।না এখানে তা দেখতে পাবেন না । এখানে আপনি একটা স্ট্যাটাস এ দেখতে পাবেন এবং তা হলো ফাইনাল স্ট্যাটাস আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিসএবার চলুন বুঝি এমন কেন হলো বা রিয়াক্ট কিভাবে এই কাজটা করলোঃ\nরিয়াক্ট স্টেটগুলোকে ব্যাচ আপডেট করে: তারমানে হলো কোন একটা event handler function এর ভিতর যদি স্টেট আপডেট হয় এবং যদি সেই ইভেন্ট হেন্ডেলারের ভিতর মাল্টিপল স্টেট আপডেট থাকে, যেমনঃ\nexport default function App() {\n    <button\n        onClick={() => {\n            setDishStatus(\"আপনার ডিশটি রান্না করা হচ্ছে\");\n            setDishStatus(\"আপনার ডিসটি রান্না করা হয়ে গেছে\");\n            setDishStatus(\"আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস\");\n        }}>\n        আমাদের ডিসের কি অবস্থা ?\n    </button>;\n}\nএই কোডে তিনবার setDishStatus করা হয়েছে । তাহলে রিয়াক্ট শুধু প্রথম setter function পেয়েই সাথে সাথে রি-রেন্ডার ট্রিগার করেনা বরং ওই event handler function এর ভিতরের সমস্ত কোড এক্সিকিউট হউয়ার পর ট্রিগার হয় । এবং তখন ওই event handler function এর ভিতরের সমস্ত স্টেট আপডেটকে ব্যাচ করে নিয়ে যায় এবং একটা স্টেটের কিউ ম্যেনেজ করে। এবং তারপর কিউ থেকে প্রতিটা স্টেট এক এক করে চেঞ্জ করে। এবং পরের রেন্ডারে সমস্ত আউটপুট একসাথে পাওয়া যায়।এখন প্রশ্ন জাগতে পারে যে,যদি তাই হয় তাহলেতো আমরা প্রথম উদাহরণের কোডের আউটপুট হিসেবে তিনটা স্টেট চেঞ্জের আউটপুট ই পেতাম।তাহলে চলুন এটাও আরেকটু ভালোভাবে বুঝিঃ","updating-the-same-state-multiple-times-before-the-next-render#Updating the same state multiple times before the next render":"রিয়াক্ট এর স্টেট আপডেট করা জন্য যেই ফাংশনে আপরা স্টেট চেঞ্জ করি সেখানে দুইটা উপায়ে করা যায়ঃ\nReplace the value of state with setter function:\nexport default function App() {\n    const [disStatus, setDishStatus] = useState(\n        \"মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে\"\n    );\n    <button\n        onClick={() => {\n            setDishStatus(\"আপনার ডিশটি রান্না করা হচ্ছে\");\n            setDishStatus(\"আপনার ডিসটি রান্না করা হয়ে গেছে\");\n            setDishStatus(\"আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস\");\n        }}>\n        আমাদের ডিসের কি অবস্থা ?\n    </button>;\n}\nআমরা যখন এইভাবে স্টেট আপডেট করছি তখন আসলে স্টেট এর পূর্বের ভ্যালুটাকে রিপ্লেস করে দিয়ে নতুন ভ্যালু দিচ্ছি। তাই উপরের উদাহরণে যখন লাস্ট setter function কল হয়েছে তখন disStatus রিপ্লেস হয়ে গিয়েছে। তাই আমরা আউটপুটে শুধু আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস এটাই দেখতে পেয়েছি।\nUpdate the value of state with updater function:\nexport default function App() {\n    const [disStatus, setDishStatus] = useState(\n        \"মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে\"\n    );\n    <button\n        onClick={() => {\n            setDishStatus((d) => `${d} , আপনার ডিশটি রান্না করা হচ্ছে `);\n            setDishStatus((d) => `${d} , আপনার ডিসটি রান্না করা হয়ে গেছে `);\n            setDishStatus(\n                (d) => `${d} , আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস `\n            );\n        }}>\n        আমাদের ডিসের কি অবস্থা ?\n    </button>;\n}\nএখানে আমরা setDishStatus এর ভিতরে একটা anonymous Arrow ফাংশনের সিনট্যাক্স ব্যাবহার করেছি, যা প্যারামিটারে আগের স্টেট ভ্যালুটা রিসিভ করে। এবং তারপর তার সাথে নতুন ভ্যালু যোগ করে ভ্যালু আপডেট করে।এভাবে করলে প্রতিটা স্টেট আপডেট করার সময় আগের স্টেটের ভ্যালুটা পাওয়া যায়,এবং সেই ভ্যালু দিয়ে নতুন ভ্যালু আপডেট করা যায়।উপরের updater function এর উপায়ে যদি আমরা স্টেট আপডেট করি তাহলে আমরা তিনটা চেঞ্জ ভেলুই ফাইনালি দেখতে পাবো এভাবেঃ মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে,আপনার ডিশটি রান্না করা হচ্ছে,আপনার ডিসটি রান্না করা হয়ে গেছে,আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস"}},"/reactive-accilarator/React-js/module-2/responding-to-event":{"title":"Responding to Event","data":{"":"রিয়াক্ট আমাদের ইভেন্ট হ্যন্ডেল করার সিস্টেম দিয়ে দিয়েছে। ইভেন্ট হ্যান্ডেলার হলো মূলত যখন কোন ইভেন্ট ট্রিগার হয়, যেমন ঃ ক্লিক,হভার,ফোকাস এসব।","adding-event-handler-to-jsx#Adding Event Handler to JSX":"রিয়াক্টে আমরা দুটি স্টেপে Event Handler এড করতে পারিঃ","হ্যান্ডেলার-ফাংশন-ডিক্লেয়ার-করা-এবং-লজিক-এড-করাঃ#হ্যান্ডেলার ফাংশন ডিক্লেয়ার করা এবং লজিক এড করাঃ":"প্রথমত একটা হ্যান্ডেলার ফাংশন ডিক্লেয়ার করতে হবে এবং এতে লজিক ইমপ্লিমেন্ট করতে হবে।\nধরুন, একটা button এ ক্লিক করলে আমরা দেখাতে চাই যে \"বাটনে ক্লিক করা হয়েছে\" সেক্ষেত্রে আমাদের হ্যান্ডেলার ফাংশন ও লজিক হবে এমনঃ\nexport default function Button(){\n    function handleClick(){ // এখনে handleClick নামে একটা হ্যন্ডেলার ফাংশন ডিক্লেয়ার করা হয়েছে এবং তার ভিতরে লজিক ইমপ্লিমেন্ট করা হয়েছে।\n        alert(\"বাটনে ক্লিক করা হয়েছে\");\n    }\n}","হ্যান্ডেলার-ফাংশনটি-বাটনে-এড-করাঃ#হ্যান্ডেলার ফাংশনটি বাটনে এড করাঃ":"এরপর হ্যান্ডেলার ফাংশনটি button এলিমেন্টে এড করতে হবেঃ\nexport default function Button(){\n    function handleClick(){\n        alert(\"বাটনে ক্লিক করা হয়েছে\");\n    }\nreturn <button onClick={handleClick}>Click Me</button> // এখনে বাটনের onClick এ হ্যান্ডেলার ফাংশনটি এড করা হয়েছে।\n}\nএছাড়াও আমরা JSX এর ইনলাইনেও Event Handler ফাংশন এড করতে পারি ।যেমনঃ\nexport default function Button(){\nreturn <button onClick={ function handleClick(){\n        alert(\"বাটনে ক্লিক করা হয়েছে\");\n    }}>Click Me</button> // এখনে বাটনের onClick এ হ্যান্ডেলার ফাংশনটি এড করা হয়েছে।\n}\nঅথবা আরও ছোট করেও লিখতে পারি Arrow Function এর সিনট্যাক্সেঃ\nexport default function Button() {\n    return (\n        <button\n            onClick={() => {\n                alert(\"বাটনে ক্লিক করা হয়েছে\");\n            }}>\n            Click Me\n        </button>\n    ); // এখনে বাটনের onClick এ হ্যান্ডেলার ফাংশনটি এড করা হয়েছে।\n}\nএখানে একটি ফাংশন ডিফাইন করা হয়েছে handleClick নামে এবং তা button এলিমেন্টে as a props পাস করা হয়েছে । handleClick ফাংশনটি একটা event handler ফাংশন।\n👉 ইভেন্ট হ্যান্ডেলার ফাংশনগুলো কম্পোনেন্ট এর ভিতরে ডিফাইন করতে হয় ।\n👉 কনভেনশন অনুযায়ী event handlerএর নামগুলোর শুরুতে handle এবং তারপর\nevent name দিয়ে লিখতে হয়। যেমনঃhandleClick handleMouseEnter\nhandleMouseLeave\nইভেন্ট হ্যান্ডেলার ফাংশনগুলো কম্পোনেন্ট এর ভিতরে পাস করতে হবে, অবশ্যই শুধুমাত্র পাস করা লাগবে, কল করা যাবেনা\nযেমনঃ\n✅ শুধুমাত্র পাস করা হয়েছে\t❌ সরাসরি কল করা হয়েছে\t<button onClick={handleClick}</button>\t<button onClick={handleClick()}</button>\t\nএই দুইটা সিস্টেমের মাঝে খুব ভালো একটা পার্থক্য আছে।\nশুধুমাত্র পাস করা <button onClick={handleClick}</button> মানে হলো - রিয়াক্ট কে বলা যে আমি তোমাকে একটা ইভেন্ট হ্যান্ডেলার দিয়ে দিলাম,তুমি এটা মনে রেখো যে যখনি ওই ইভেন্ট টা ঘটবে তখনই তুমি ফাংশন টা কল করে দিও।\nএক্ষেত্রে যেমন Click ইভেন্ট হ্যান্ডেলার ব্যাবহার করা হয়েছে,তার মানে হলো যখন Click হবে ঠিক তখনি ফাংশনটা কল হবে এবং আউটপুট দেখা যাবে ।\nকিন্তু সরাসরি কল করে দেয়া <button onClick={handleClick()}</button> মানে হলোঃ কম্পোনেন্ট রেন্ডার হওয়ার সাথে সাথেই অটোমেটিক ফাংশন কল হয়ে যাবে , এতে ক্লিক হউয়ার জন্য ওয়েট করবেনা । এতে করে যদি কখনো কোন ফাংশনের দ্বারা State ম্যানেজ করা হয়ে থাকে, তখন বার বার State চেঞ্জ হতে থাকবে আর কম্পোনেন্ট রি-রেন্ডার হতে থাকবে। এটা এপ্লিকেশন একটা infinte লুপে পড়ে যাবে।\nইনলাইনে ফাংশন ডিফাইন করার ক্ষেত্রেও এই একই বিষয় টা খেয়াল রাখতে হয়। যদিও সেখানে শুদুমাত্র আমরা ফাংশনের ডেফিনেশন টাই লিখি ফাংশনটা কল করে দেইনা। তবে IIFE-(immediately invoked function expression) সাথে সাথেই কল হয়ে যায় বলে আমরা ইনলাইনে IIFE-(immediately invoked function expression) লিখতে পারবোনা।","reading-props-in-event-handler#Reading Props in Event Handler":"ইভেন্ট হ্যান্ডেলারগুলো যেহেতু কম্পোনেন্টের ভিতরে লেখা হয় তাই কম্পোনেন্টের যেসব প্রপস আছে তা event handler functionগুলো সরাসরি এক্সেস করতে পারে ।","pass-event-handler-to-child-components-as-props#Pass Event Handler to Child Components as Props":"কখনো কখনো আমাদের প্যারেন্ট কম্পোনেন্ট থেকে চাইল্ড কম্পোনেন্ট এর ইভেন্ট কে ম্যানেজ করা লাগে। সেই ক্ষেত্রে প্যারেন্ট কম্পোনেন্টে event handler function ডিফাইন করে তা প্রপস আকারে চাইল্ড কম্পোনেন্টে পাস করা যায়।চলুন একটু বিস্তারিত বুঝিঃ\nexport default function App() {\n    function handlePlay() {\n        alert(\"Movie is playing\");\n    }\n    return <MovieCard onPlay={handlePlay} />;\n}\nexport default function MovieCard({ onPlay }) {\n    return <button onClick={onPlay}>Play</button>;\n}\nএখানে App কম্পোনেন্ট একটি প্যারেন্ট কম্পোনেন্ট এবং এর চাইল্ড হিসেবে রয়েছে একটা MovieCard কম্পোনেন্ট। এবং মুভিকার্ড কম্পোনেন্ট এ একটা প্রপ্স পাস করা হয়েছে onPlay নামে। এই onPlay প্রপস এর মাধ্যমে মূলত handlePlay নামক একটা ইভেন্ট হ্যান্ডেলার পাস করা হয়েছে ।চাইল্ড কম্পোনেন্ট MovieCard সেই প্রপস টাকে রিসিভ করেছে এবং বাটনের onClick এ তা ট্রিগার করা হয়েছে।তার মানে হলো চাইল্ড কম্পোনেন্ট MovieCard এর বাটনে ক্লিক হলে কোন হ্যন্ডেলার ফাংশন কল হবে তা আমরা প্যারেন্ট কম্পোনেন্টেই ডিফাইন করতে পারি এবং তা প্রপস আকারে পাঠাতে পারি ।","naming-conventions-of-event-handler-props#Naming Conventions of event handler props":"👉 ইভেন্ট হ্যান্ডেলার প্রপস এর নামের শুরুতে on দিয়ে শুরু করতে হয়।\n👉 যেসব রিসার্ভড কিওয়ার্ড আছে যেমনঃ onClick,onHover এসব শুধুমাত্র html এর নেটিভ ইলিমেন্টে ব্যাবহার করা উচিত।\n👉 onদিয়ে শুরু করে তারপর প্রসঙ্গত যেকোন নামেই ব্যাবহার করা যায়। যেমনঃ onClick এর পরিবর্তে onSmash ব্যাবহার করা যায় ।"}},"/reactive-accilarator/React-js/module-2/state-as-a-snapshot":{"title":"State as a Snapshot","data":{"":"স্টেট ভেরিয়েবল নরমাল জাবাস্ক্রিপ্ট ভেরিয়েবলের মতো মনে হলেও এটা মোটেও জাবাস্ক্রিপটের নরমাল ভেরিয়েবল এর মতো কাজ করেনা। চলুন বিস্তারিত জেনে নেয়া যাক।","rendering-takes-a-snapshot-in-time#Rendering takes a snapshot in time:":"এর মানে হলো রিয়াক্ট তার প্রতিটা রেন্ডারে একটা করে snapshot নেয়। এবং তা মনে রাখে। যখনি কোন স্টেট এর ভ্যালু চেঞ্জ হয় তখন রিয়াক্ট কম্পোনেন্টকে রি-রেন্ডার করে এবং পরের রেন্ডারে গিয়ে তার ভ্যালু আপডেট হয়। তার মানে হলো আমরা নরমাল ভেরিয়েবল এ যেমন কোন ভ্যালু চেঞ্জ করলে পরের লাইনেই তা এক্সেস করতে পারি কিন্তু রিয়াক্টে তা পারিনা,কেননা রিয়াক্ট ইনপ্লেস ভ্যালু চেঞ্জ করেনা। ভ্যালুটা চেঞ্জ হয় তার পরের রেন্ডারে।একটা উদাহরণের মাধ্যমে বুঝা যাকঃ\nimport { useState } from \"react\";\nexport default function App() {\n    const [number, setNumber] = useState(1);\n    function handleClick() {\n        setNumbers(number + 5);\n        console.log(number);\n    }\n    return <button onClick={handleClick}>Incriment the number</button>;\n}\nউপরের কোডটার কনসলে আউটপুট কত আশার কথা? স্বাভাবিক ভাবে দেখলে মনে হয় যে আউটপুত 6আসার কথা। কিন্তু না , এখানে আউটপুট আসবে 1। কারণ রিয়াক্ট তার স্টেট চেঞ্জ হলেই ডিরেক্ট ভ্যালু চেঞ্জ করে দেয়না, তাই সেই ভ্যালুটা পরের লাইনগুলোতে এক্সেস করা যায়না।যেই হেন্ডেলার ফাংশনে setter function কল করা হয়েছে সেই হেন্ডেলার এর পুরো কোডটা এক্সিকিউট হয়ে যাওয়ার পর রি-রেন্ডার ট্রিগার হয় এবং পরের রেন্ডারে আপডেটেড ভ্যালু পাওয়া যায়।আরেকটা উদাহরণ যদি আমারা দেখিঃ\nimport { useState } from \"react\";\nexport default function Counter() {\n    const [number, setNumber] = useState(0);\n    return (\n        <>\n            <h1>{number}</h1>\n            <button\n                onClick={() => {\n                    setNumber(number + 1);\n                    setNumber(number + 1);\n                    setNumber(number + 1);\n                }}>\n                +3\n            </button>\n        </>\n    );\n}\nএখানে একটা বাটনে তিনবার setter function কল করা হয়েছে এবং তিনবার স্টেট এর ভ্যালু আপডেট করা হয়েছে। এই কোডটা রান করে আমরা যদি বাটনে ক্লিক করি তাহলে আউটপুট কত আসার কথা- 3?কিন্তু না আউটপুট আসবে 1 ।যেহেতু স্টেট শুধুমাত্র পরের রেন্ডারে চেঞ্জ হয় তাই প্রথম রেন্ডারে স্টেট এর ভ্যালু ছিল 0। তাই প্রথম রেন্ডারে তিনবার setter function কল হলেও তিনবার এ সে স্টেটের ইনিশিয়াল ভ্যালু পাবে 0। আর তাই নাম্বার এর আউটপুট আসবে 1\n<button\n    onClick={() => {\n        setNumber(number + 1);\n        setNumber(number + 1);\n        setNumber(number + 1);\n    }}>\n    +3\n</button>\nএখানে যেটা হচ্ছে প্রথম রেন্ডারে প্রথমবার যখন setNumber(number + 1) করা হচ্ছে তখন আসলে 0 + 1 = 1 করা হচ্ছে যা পরের রেন্ডারে আউটপুটে আসবে,কিন্তু পরের রেন্ডারে যাওয়ার আগে আরও দুইবার setNumber(number + 1) করা হয়েছে,তার মানে তখনও কিন্তু 0 + 1 = 1 ই করা হচ্ছে ।তারমানে শেষবার যখন setNumber(number + 1) করা হয়েছে, তখন কিন্তু 0 + 1 = 1 ই করা হয়েছে এবং স্টেট তার মেমরিতে 1 নিয়েই পরের রেন্ডার ট্রিগার করেছে এবং আউটপুটে 1 প্রিন্ট হয়েছে ।\n<button\n    onClick={() => {\n        setNumber(0 + 1);\n        setNumber(0 + 1);\n        setNumber(0 + 1);\n    }}>\n    +3\n</button>\nআবার যদি কোডটা এমন হয়ঃ\nexport default function Counter() {\n    const [number, setNumber] = useState(0);\n    return (\n        <>\n            <h1>{number}</h1>\n            <button\n                onClick={() => {\n                    setNumber(number + 5);\n                    setTimeout(() => {\n                        alert(number);\n                    }, 3000);\n                }}>\n                +5\n            </button>\n        </>\n    );\n}\nএখানে বাটনে নাম্বারের স্টেট চেঞ্জ করা হয়েছে এবং একটা setTimeout() কল করা হয়েছে ৩ সেকেন্ডের জন্য। এবং তাতে নাম্বার এর ভ্যালুটা এলার্টে নেয়া হয়েছে।এখানেও হয়তো মনে হতে পারে যে নাম্বার এর ভ্যালু এলার্টে 5 আসবে,কেননা যতক্ষণে ৩ সেকেন্ড টাইমার শেষ হবে ততক্ষণে স্টেট রি-রেন্ডার হয়ে যাবে এবং আমরা এলার্টে আপডেটেড ভ্যালু পাবো ।কিন্তু না এখানেও ব্যাপারটাকে snapshot হিসেবে চিন্তা করতে হবে, এখানে timeOut টা তিন সেকেন্ড পরে হলেও যখন টাইমআউট শুরু হয়েছে তখন কিন্তু সে number এর ভ্যালু 0 নিয়েই গিয়েছে, তাই টাইমার যতই নিয়ে যাক প্রথম রেন্ডারে সে তাই পাবে যেটা তার ইনিশিয়াল ভ্যালু।অর্থাৎ রিয়াক্টের একটা রেন্ডারে কখনই সরাসরি ভ্যালু চেঞ্জ হয়না, বরং স্টেট চেঞ্জ হলে একটা রি-রেন্ডার ট্রিগার হয় এবং পরের রেন্ডারে গিয়ে তার আপডেটেড ভ্যালু পাওয়া যায়।"}},"/reactive-accilarator/React-js/module-2/understanding-state":{"title":"Understanding State","data":{"":"রিয়াক্ট এপ্লিকেশনে যখনি কোন এন্টারেকশনে কোনকিছু চেঞ্জ করা প্রয়োজন হয় তখনি স্টেট এর প্রয়োজন হয়।","স্টেট-state-কি-#স্টেট (State) কি ?":"State এর বাংলা মানে হলো অবস্তা । ভিন্ন ভিন্ন অবস্থার স্টেট হয় ভিন্ন ভিন্ন।ধরুন একটা Button এ ক্লিক করলে একটা Modal ওপেন হবে । এইযে Modal একবার ওপেন হবে এটা একটা অবস্থা, আবার যখন Modal ক্লোজ থাকবে সেটা আবার আরেক অবস্থা। এটাকেই বলা হয় State।রিয়াক্ট যেহেতু একটা রিয়াক্টিভ এপ্লিকেশনে সাহায্য করে তাই রিয়াক্ট যাতে বুঝতে পারে যে এপ্লিকেশনে কিছু চেঞ্জ হয়েছে,তাকে রি-রেন্ডার করতে হবে, এবং কোন অবস্থায় কি ছিল, সেটা তাকে মনে রাখতে হবে তাই তাকে এপ্লিকেশনের বিভিন্ন স্টেট ম্যানেজ করা লাগে। আর এই কাজটা রিয়াক্ট করে তার বিল্ট ইন hook useState এর মাধ্যমে।","এই-কাজগুলো-কি-আমরা-রেগুলার-ভেরিয়েবল-নিয়ে-কন্ডীশনালি-করতে-পারিনা-#এই কাজগুলো কি আমরা রেগুলার ভেরিয়েবল নিয়ে কন্ডীশনালি করতে পারিনা ?":"নাহ, রিয়াক্ট এপ্লিকেশনে আমরা সেটা পারিনা,কেননা রিয়াক্ট এপ্লিকেশনে কোনকিছু চেঞ্জ হলেই তার কম্পোনেন্টকে রি-রেন্ডার করতে হয় এবং UI আপডেট করতে হয়। কিন্তু আমরা যদি লোকাল ভ্যারিয়েবল নিয়ে তার মদ্ধে ভ্যালু চেঞ্জ করে দেই,তাহলে রিয়ায়ক্ট সেটাকে মনে রাখতে পারেনা এবং তাতে সে রি-রেন্ডার ও ট্রিগার করেনা। তাহলে হয়তো ভাবতে পারেন যে ,আমরা ম্যনুয়ালি UI আপডেট করে দিলেইতো হয়ে গেল, হ্যাঁ - কিন্তু তাহলে আমরা রিয়াক্টে কেন এসেছি ? রিয়াক্টে এসেছি কারণ যাতে আমাদের কোন কিছু চেঞ্জ হলেই যাতে UIঅটোমেটিক আপডেট হয়।","লোকাল-ভেরিয়েবল-এর-ক্ষেত্রে-যেসব-বিষয়-হয়নাঃ#লোকাল ভেরিয়েবল এর ক্ষেত্রে যেসব বিষয় হয়নাঃ":"Local variables don't persist between renders: মানে হলো যখন কম্পোনেন্ট রি-রেন্ডার হয়, তখন পুরো কম্পোনেন্টটা আবার নতুন করে রেন্ডার হয়। তখন সে তার লোকাল ভেরিয়েবল এ আগের রেন্ডারে কি চেঞ্জ হয়েছিল তা সে মনে রাখেনা ।\nChanges to local variables won't trigger renders: মানে হলো লোকাল ভেরিয়েবল চেঞ্জ হলে রিয়েক্ট বুঝতেই পারেনা যে, তাকে কম্পোনেন্ট রি-রেন্ডার করতে হবে।\nকম্পোনেন্টকে নতুন ডাটা দিয়ে আপডেট হতে হলে দুইটা জিনিস লাগেঃ\nRetain the data between renders: এর মানে হলো রি-রেন্ডারের পর কম্পোনেন্টকে জানতে হয় যে তার আগের রেন্ডারে কি চেঞ্জ হয়েছিল,যেটা সে UI তে আপডেট করবে।\nTrigger a Re-render: মানে হলো কোন স্টেট চেঞ্জ হলেই রিয়াক্টকে তার রি-রেন্ডার ট্রিগার করতে হয় ।\nuseState হুক এই দুটি জিনিস দিয়ে থাকেঃ\nA State Variable: useState হুক একটি স্টেট ভেরিয়েবল দেয় যা সে প্রতিটা রি-রেন্ডারে মনে রাখতে পারে ।\nA Setter Function:useState হুক একটি setter function দেয় যা দিয়ে সে স্টেট ভেরিয়েবলকে চেঞ্জ করতে পারে ।","usestate-হুক---কিভাবে-লিখতে-হয়-এবং-কিভাবে-ব্যাবহার-করতে-হয়-#useState হুক - কিভাবে লিখতে হয় এবং কিভাবে ব্যাবহার করতে হয় ?":"সিনট্যাক্সঃ\nconst [currentValue, setterFunction] = useState(initialValue);","রিয়াক্ট-থেকে-usestate-হুক-ইম্পোর্ট-করতে-হবেঃ#রিয়াক্ট থেকে useState হুক ইম্পোর্ট করতে হবেঃ":"import { useState } from \"react\";\nexport default function App() {\n    return (\n    <>\n        <h1>Count:  </h1>\n        <button>Click to Incriment Count</<button>\n    </>\n    );\n}","usestate-হুক-ডিক্লেয়ার-করা-#useState হুক ডিক্লেয়ার করা ।":"import { useState } from \"react\";\nexport default function App() {\nconst [count, setCount] = useState(0);\n    return (\n    <>\n         <h1>Count:  </h1>\n        <button>Click to Incriment Count</<button>\n    </>\n    );\n}","setter-function-এর-মাধ্যমে-state-variable-এর-ভ্যালু-চেঞ্জ-করা-এবং-ভ্যালু-ব্যাবহার-করা-#setter function এর মাধ্যমে State variable এর ভ্যালু চেঞ্জ করা এবং ভ্যালু ব্যাবহার করা ।":"import { useState } from \"react\";\nexport default function App() {\nconst [count, setCount] = useState(0);\n    function handleCountIncriment() {\n        setCount(count + 1);\n    }\n    return (\n    <>\n         <h1>Count: {count}  </h1>\n        <button onClick={handleCountIncriment}>Click to Incriment Count</<button>\n    </>\n    );\n}\n**রিয়াক্টে সকল ফাংশন যেগুলা শুরুতে use দিয়ে নামকরন করা হয়েছে সেগুলা প্রতিটাই হলো হুক। শুধু useState ই নয়,রিয়েক্টের এমন বিল্ট ইন আরও অনেক হুক রয়েছে যেগুলো আমরা পরে যানতে পারবো । এসব প্রতিটা হুক রিয়াক্টে আলাদা আলাদা ফিচার যুক্ত করেছে। তাই রিয়াক্টের হুকগুলো হলো একেকটা স্পেশাল ফাংশন । তাই এগুলোকে নরমাল ফাংশনের মতো চিনটা করলে হবেনা। আর রিয়াক্টের হুকগুলোকে সবসময় কম্পোনেন্টের টপ লেভেলে ব্যাবহার করতে হয় । এগুলোকে কখনওই কোন কন্দীশন,লুপ বা অন্যান্য ফাংশনের ভিতরে ব্যাবহার করা যাবেনা । **","রিয়াক্টের-usestate-হুক-কিভাবে-কাজ-করে-#রিয়াক্টের useState হুক কিভাবে কাজ করে ?":"যখনি আমরা কোন কম্পোনেন্টের ভিতরে useState লিখি,তার মনে হলো রিয়াক্টকে বলা যে, আমার এই কম্পোনেন্টে কিছু স্টেট আছে সেগুলো তোমাকে মনে রাখতে হবে ।\nconst [index, setIndex] = useState(0);\nএক্ষেত্রে আমরা স্টেট ভেরিয়েবল নিয়েছি index । তাহলে রিয়াক্ট প্রতিটা রেন্ডারে index এর ভ্যালুটাকে তার মেমরিতে মনে রাখবে।\nStateএর নেমিং কনভেনশন হলো - যেই নামে স্টেট ভেরিয়েবল নেয়া হয়েছে,\nsetterFunction এর নামটাও সেই নামটাকে ফলো করেই দেয়া উচিত । যেমন: const\n    [index, setIndex] = useState(0);","রেন্ডার-এবং-রি-রেন্ডারিং-প্রসেসঃ#রেন্ডার এবং রি-রেন্ডারিং প্রসেসঃ":"const [index, setIndex] = useState(0);\nপ্রথমবার যখন কম্পোনেন্ট রেন্ডার হয়ঃ আমারা স্টেট ভেরিয়েবলের ইনিশিয়াল যে ভ্যালু দিয়েছিলাম সেটাই রিটার্ন করে। এক্ষেত্রে initial value = 0 তাই স্টেট 0 রিটার্ন করবে ।\nযখন স্টেট ভেরিয়েবল এর ভ্যালু আপডেট করা হয়ঃ যখন ইউজারের ক্লিক বা কোন ইন্টারেকশনে setter function দিয়ে ভ্যালু আপডেট করা হয় setIndex( index + 1 ) তখন স্টেটের ভ্যালু চেঞ্জ হয়ে হয় 1 এবং রিয়েক্টকে তা মনে রাখতে বলে এবং তারপর setter function রিয়াক্টের Render() মেথড কল করে দিয়ে আরেকটা রেন্ডার ট্রিগার করে দেয় ।\nদ্বিতীয়বার যখন রেন্ডার হয়ঃ তখন কম্পোনেন্ট আবার নতুন করে রেন্ডার হয় এবং রিয়াক্ট দেখে যে useState(0) এর initial value 0  কিন্তু আগের রেন্ডারে যখন state value চেঞ্জ হয়েছে তখন রিয়াক্ট সেটাকে মনে রেখেছে, আর তাই সে তখন index এর ভ্যালু 1 রিটার্ন করবে ।\nআর এভাবেই প্রতিটা রেন্ডার চলতে থাকবে ।","যদি-একটা-কম্পোনেন্টে-মাল্টিপল-স্টেট-ভ্যারিয়েবল-নেয়ার-প্রয়োজন-হয়#যদি একটা কম্পোনেন্টে মাল্টিপল স্টেট ভ্যারিয়েবল নেয়ার প্রয়োজন হয়?":"কোন কম্পোনেন্টের যদি মাল্টিপল স্টেট ম্যানেজ করা লাগে,তাহলে মাল্টিপল useState কল করা যায়। এতে কোন সমস্যা নেই। তবে যদি একটা স্টেট আরেকটার সাথে রিলেটেড হয় তাহলে আমরা স্টেট ভ্যালু Array বা object হিসেবে রেখেও কাজ করতে পারি।","state-হলো-কম্পোনেন্টের-প্রাইভেট-ডাটা#State হলো কম্পোনেন্টের প্রাইভেট ডাটা":"রিয়াক্টের স্টেট তার কম্পোনেন্টের ভিতরেই সীমাবদ্ধ। স্টেট কে বলা হয় কম্পোনেন্টের প্রাইভেট ডাটা।ধরুন কোন কম্পোনেন্টে স্টেট ব্যাবহার করা হয়েছে। এখন যতবার ওই কম্পোনেন্টকে ব্যাবহার করা হোক না কেন,প্রতিটার জন্য তার স্টেট হবে আলাদা। এমন নয় যে,কম্পোনেন্ট রি-ইউজ করার জন্য একটার স্টেট চেঞ্জ হলে বাকিগুলোও স্টেট চেঞ্জ করে ফেলবে। এটা কক্ষনো হবেনা। কারণ প্রতিটা কম্পোনেন্টের স্টেট তার ভিতরে আইসোলেটেড অবস্থায় থাকে এবং সেগুলো ইউনিক হয়।তবে যদি আমাদের রিকোয়ারমেন্ট এমন হয় যে আমাদের প্রতিটা রি-ইউজেবল কম্পোনেন্টের স্টেট sync থাকবে বা একটায় স্টেট চেঞ্জ করলে তা প্রতিটায় এফেক্ট করবে,তাহলে আমারা lifting state up টেকনিক ব্যাবহার করতে পারি। যা নিয়ে আমরা পরে বিস্তারিত জানবো ।"}},"/reactive-accilarator/React-js/module-2/updateing-array-in-state":{"title":"Updateing Array in State","data":{"":"জাভাস্ক্রিপ্টে Array মিউটেড করা যায়, কিন্তু যখন আপনি Array কে রিয়াক্টের কোন স্টেট ভ্যারিয়েবল এর ভ্যালু হিসেবে স্টোর করবেন তখন অবশ্যই আপনাকে ভাবতে হবে যে - Array কেও মিউটেড করা যায়না। যখনি কোন স্টেট ভ্যারিয়েবলের ভ্যালু Array থাকবে,তখন তা আপডেট করতে হলে অবশ্যই সম্পুর্ন নতুন Array অথবা আগের Array এর কপি বানিয়ে সেখানে ভ্যালু আপডেট করে তারপর স্টেট এর আপডেটেড ভ্যালু হিসেবে সেট করতে হবে।","updating-arrays-without-mutation---কিভাবে-মিউটেশন-ছাড়া-array-আপডেট-করতে-পারি#(Updating arrays without mutation) - কিভাবে মিউটেশন ছাড়া Array আপডেট করতে পারি।":"জাভাস্ক্রিপ্টে Array হলো একধরনের অবজেক্ট। রিয়াক্টের স্টেট হিসেবে Array কেও সবসময় read-only মনে করতে হবে। তাই আপনি কখনওই arr[0]= \"something\" এভাবে সরাসরি রি-এসাইন করতে পারবেন না। এবং এছাড়াও বেশ কিছু Array মেথড আছে যা পুরাতন Array কে মিউটেড করে যেমন: push ,pop,shift,unshift,splice,sort,reverse,arr[i] এইগুলো রিয়াক্টের স্টেট আপডেট করার জন্য ব্যাবহার করা উচিত নয়।চলুন জেনে নেই রিয়াক্ট এর স্টেট আপডেট করা জন্য Array ডাটা আপডেট করতে কোন কোন মেথডগুলো ব্যাবহার করা যাবে আর কোনগুলো ব্যাবহার করা উচিত নয়।\nব্যাবহারের কারণ\t❌ - পুরাতন Array কে মিউটেড করে\t✅ যেগুলো নতুন Arry রিটার্ন করে\tএড করা (Adding in Array)\tpush, unshift\tconcat, [...sprade,], array.with()\tবাদ দেয়া (Removing from Array)\tpop, shift, splice\tfilter, slice, toSpliced\tরিপ্লেস করা (Replac in Array)\tsplice, arr[0]=\"something\"\tmap, toSpliced\tসর্টিং করা (Sort in Array)\tsort, reverse\tপ্রথমে পুরাতন Array কপি করে নিয়ে sort বা reverse করা, toSorted, toReversed","adding-to-an-array-array-তে-এলিমেন্ট-এড-করা-#(Adding to an Array) Array তে এলিমেন্ট এড করা ।":"avoid push() , use concat or [...spread]Array তে কোনকিছু এড করতে হলে স্বাভাবিকভাবে push() মেথড ব্যাবহার করা যায়,কিন্তু push() মেথড মেইন Array কে মিউটেড করে ফেলে। তাই রিয়াক্টের স্টেট আপডেট করার সময় push() মেথড ব্যাবহার না করে concat অথবা [...spread] ব্যাবহার করে Array তে আইটেম এড করা উচিত।\nlet nextId = 0\nconst [artists, setArtists] = useState([{..}, {..}, {..}]);\nsetArtists([\n    ...artists, // that contains all the old items\n    { id: nextId++, name: \"Something\" }, // and one new item at the end\n]);","removing-from-an-array-array-থেকে-এলিমেন্ট-রিমুভ-করা#(Removing from an array) Array থেকে এলিমেন্ট রিমুভ করা।":"avoid pop,unshift use filter or slice or toSpliced Array থেকে কোন কিছু বাদ দিতে হলে সবচেয়ে সহজ উপায় হলো filter ব্যাবহার করা। filter মেথড মেইন Array তে হাত দেয়না, বরং একটা নতুন Array রিটার্ন করে।\nlet nextId = 0\nconst [artists, setArtists] = useState([{..}, {..}, {..}]);\nconst filteredData = artists.filter((item)=> item.id !== 2)\nsetArtists(filteredData)","transforming-an-array-array-কে-পরিবর্তন-করা#(Transforming an array) Array কে পরিবর্তন করা।":"যদি Arrayএর কোন আইটেমের মদ্ধ্যে কোনকিছু পরিবর্তন করতে হয় তাহলে map() ব্যাবহার করে করা উচিত। map() মেইন Array কে পরিবর্তন করেনা বরং একটি নতুন Array রিটার্ন করে।map() দিয়ে একটা Array এর প্রতিটা আইটেমের ভিতর দিয়ে itareate করে কন্ডিশনলি যেখানে পরিবর্তন করা প্রয়োজন,সেখানে পরিবর্তন করা যায়।","replacing-items-in-an-array--array-এর-মধ্য-থেকে-কোন-আইটেমকে-রিপ্লেস-করা-#(Replacing items in an array ) Array এর মধ্য থেকে কোন আইটেমকে রিপ্লেস করা ।":"যদি Arrayএর কোন আইটেমের মদ্ধ্যে থেকে কোন আইটেম কে রিপ্লেস করতে হয় তাহলে map() ব্যাবহার করে করা উচিত।map() দিয়ে একটা Array এর প্রতিটা আইটেমের ভিতর দিয়ে itareate করে কন্ডিশনলি যেই আইটেম টি রিপ্লেস করা প্রয়োজন,সেটি রিপ্লেস করা যায়।","inserting-into-an-array-array-এর-কোন-পজিশনে-আইটেম-ইনসার্ট-করা#(Inserting into an array) Array এর কোন পজিশনে আইটেম ইনসার্ট করা।":"Array এর কোন নির্দিষ্ট পজিশনে কোন আইটেম এড করতে চাইলে slice অথবা toSpliced ব্যাবহার করা যেতে পারে। toSpliced ECMA SCRIPT 2023 এর নতুন ফিচার। এটি মেইন Array কে পরিবর্তন করেনা এবং নতুন Array রিটার্ন করে।slice() মেথড ব্যাবহার করে ইনসার্টঃ\nimport { useState } from \"react\";\nlet nextId = 3;\nconst initialArtists = [\n    { id: 0, name: \"Marta Colvin Andrade\" },\n    { id: 1, name: \"Lamidi Olonade Fakeye\" },\n    { id: 2, name: \"Louise Nevelson\" },\n];\nexport default function List() {\n    const [name, setName] = useState(\"\");\n    const [artists, setArtists] = useState(initialArtists);\n    function handleClick() {\n        const insertAt = 1; // কোন পজিশনে ইনসার্ট হবে সেই নাম্বার\n        const nextArtists = [\n            // ইনসার্ট পজিশনের আগের আইটেমগুলো\n            ...artists.slice(0, insertAt),\n            // নতুন আইটেম\n            { id: nextId++, name: name },\n            // বাকি আইটেমগুলো ইনসার্ট পজিশনের পর\n            ...artists.slice(insertAt),\n        ];\n        setArtists(nextArtists);\n        setName(\"\");\n    }\n    return (\n        <>\n            <h1>Inspiring sculptors:</h1>\n            <input\n                value={name}\n                onChange={(e) => setName(e.target.value)}\n            />\n            <button onClick={handleClick}>Insert</button>\n            <ul>\n                {artists.map((artist) => (\n                    <li key={artist.id}>{artist.name}</li>\n                ))}\n            </ul>\n        </>\n    );\n}\ntoSpliced() মেথড ব্যাবহার করে ইনসার্টঃ\nimport { useState } from \"react\";\nlet nextId = 3;\nconst initialArtists = [\n    { id: 0, name: \"Marta Colvin Andrade\" },\n    { id: 1, name: \"Lamidi Olonade Fakeye\" },\n    { id: 2, name: \"Louise Nevelson\" },\n];\nexport default function List() {\n    const [name, setName] = useState(\"\");\n    const [artists, setArtists] = useState(initialArtists);\n    function handleClick() {\n        const insertAt = 1; // কোন পজিশনে ইনসার্ট হবে সেই নাম্বার\n        const nextArtists = artists.toSpliced(insertAt, {\n            // নতুন আইটেম এড করে নতুন অ্যারে রিটার্ন করবে\n            id: nextId++,\n            name: \"Something\",\n        });\n        setArtists(nextArtists);\n        setName(\"\");\n    }\n    return (\n        <>\n            <h1>Inspiring sculptors:</h1>\n            <input\n                value={name}\n                onChange={(e) => setName(e.target.value)}\n            />\n            <button onClick={handleClick}>Insert</button>\n            <ul>\n                {artists.map((artist) => (\n                    <li key={artist.id}>{artist.name}</li>\n                ))}\n            </ul>\n        </>\n    );\n}","sort-or-reverse-in-array---সর্ট-অথবা-রিভার্স-করা-#(sort or reverse in array) - সর্ট অথবা রিভার্স করা ।":"Array কে সরাসরি sort অথবা reverse মেথড ব্যাবহার সর্ট অথবা রিভার্স করতে গেলে তা মেইন Array পরিবর্তন করে দেয়। তাই সরাসরি sort অথবা reverse ব্যাবহার না করে প্রথমে [...spread] সিনট্যাক্স ব্যাবহার করে spread করে নিতে হয়।\nimport { useState } from \"react\";\nconst initialList = [\n    { id: 0, title: \"Big Bellies\" },\n    { id: 1, title: \"Lunar Landscape\" },\n    { id: 2, title: \"Terracotta Army\" },\n];\nexport default function List() {\n    const [list, setList] = useState(initialList);\n    function handleClick() {\n        const nextList = [...list];\n        nextList.reverse();\n        setList(nextList);\n    }\n    return (\n        <>\n            <button onClick={handleClick}>Reverse</button>\n            <ul>\n                {list.map((artwork) => (\n                    <li key={artwork.id}>{artwork.title}</li>\n                ))}\n            </ul>\n        </>\n    );\n}\nএখানে একটা বিষয় মাথায় রাখতে হবে তা হলো,[...spread] সিনট্যাক্স শুধুমাত্র প্রথম লেবেলের কপি বানায়, উপরের উদাহরণ অনুযায়ী যদি শুধুমাত্র অবজেক্টগুলোর অর্ডার টা সর্ট বা রিভার্স করা হয়,তাহলে এই পদ্ধতি ঠিক আছে, কিন্তু যদি Array এর ভিতরের অবজেক্টগুলোকে কোনকিছু করা লাগতো,তাহলে কিন্তু এইভাবে শুধু একবার [...spread] করলে চলবেনা।","updating-objects-inside-an-array---array-ভিতরের-অবজেক্টকে-আপডেট-করা-#(Updating objects inside an Array) - Array ভিতরের অবজেক্টকে আপডেট করা ।":"যখনি আমদের Arrayভিতরের অবজেক্টকে আপডেট করতে হবে তখন আমরাmap()` ব্যাবহার করে সেটা করতে পারি।যেহেতু map() Arrayর প্রতিটা আইটেমের ভিতর দিয়ে itarate করে এবং প্রতি itaration এ একেকটা আইটেম রিটার্ন করে, তাহলে map() ব্যাবহার করে কন্ডিশনালি যেকোন আইটেমকে পরিবর্তন করা যেতে পারে।\nimport { useState } from \"react\";\nlet nextId = 3;\nconst initialList = [\n    { id: 0, title: \"Big Bellies\", seen: false },\n    { id: 1, title: \"Lunar Landscape\", seen: false },\n    { id: 2, title: \"Terracotta Army\", seen: true },\n];\nexport default function BucketList() {\n    const [myList, setMyList] = useState(initialList);\n    const [yourList, setYourList] = useState(initialList);\n    function handleToggleMyList(artworkId, nextSeen) {\n        setMyList(\n            myList.map((artwork) => {\n                if (artwork.id === artworkId) {\n                    // Create a *new* object with changes\n                    return { ...artwork, seen: nextSeen };\n                } else {\n                    // No changes\n                    return artwork;\n                }\n            })\n        );\n    }\n    function handleToggleYourList(artworkId, nextSeen) {\n        setYourList(\n            yourList.map((artwork) => {\n                if (artwork.id === artworkId) {\n                    // Create a *new* object with changes\n                    return { ...artwork, seen: nextSeen };\n                } else {\n                    // No changes\n                    return artwork;\n                }\n            })\n        );\n    }\n    return (\n        <>\n            <h1>Art Bucket List</h1>\n            <h2>My list of art to see:</h2>\n            <ItemList\n                artworks={myList}\n                onToggle={handleToggleMyList}\n            />\n            <h2>Your list of art to see:</h2>\n            <ItemList\n                artworks={yourList}\n                onToggle={handleToggleYourList}\n            />\n        </>\n    );\n}\nfunction ItemList({ artworks, onToggle }) {\n    return (\n        <ul>\n            {artworks.map((artwork) => (\n                <li key={artwork.id}>\n                    <label>\n                        <input\n                            type='checkbox'\n                            checked={artwork.seen}\n                            onChange={(e) => {\n                                onToggle(artwork.id, e.target.checked);\n                            }}\n                        />\n                        {artwork.title}\n                    </label>\n                </li>\n            ))}\n        </ul>\n    );\n}","write-concise-update-logic-with-immer---immer-এর-সাহায্যে-খুব-সহজে-array-অপারেশন-চালানো#(Write concise update logic with Immer) - Immer এর সাহায্যে খুব সহজে Array অপারেশন চালানো।":"আমরা যদি মিউটেশন নিয়ে এতো টেনশন না করতে চাই,তাহলে আমরা Immer ব্যাবহার করে খুব সহজেই আমাদের সকল ধরনের Array অপারেশন করতে পারি। Immer কিভাবে ব্যাবহার করতে হয় তা স্টেপ বাই স্টেপ জানতে এখানে ক্লিক করুন","ecma-script-2023-es-2023-এর-চারটি-স্পেশাল-array-মেথডঃ#ECMA SCRIPT 2023 (ES-2023) এর চারটি স্পেশাল Array মেথডঃ":"ECMA SCRIPT 2023 (ES-2023) এর চারটি স্পেশাল Array মেথড দিয়ে আমরা খুব সহজেই মেইন Arrayকে Mutatateনা করেই বিভিন্ন Arrayঅপারেশন চালাতে পারি।\ntoSpliced()\ntoReversed()\ntoSorted()\nwith()","tospliced-মেথডঃ#toSpliced() মেথডঃ":"Array.prototype.toSpliced() মেথডের মাধ্যমে Array এর যেকোন পজিশনে যেকোন আইটেম এড করতে পারি বা ডিলিট করতে পারি। এবং এটা মেইন Arrayতে হাত দেয়না। উদাহরনঃsplice() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করে।\nconst arr = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconst arr2 = arr.splice(2, 3, \"x\", \"y\");\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"b\", \"x\", \"y\"]; // মেইন Array পরিবর্তন হয়ে গেছে\n[\"c\", \"d\", \"e\"];\ntoSpliced() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করেনা।\nconst arr = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconst arr2 = arr.toSpliced(2, 3, \"x\", \"y\");\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"b\", \"c\", \"d\", \"e\"]; // মেইন Array অপরিবর্তিত রয়েছে।\n[\"a\", \"b\", \"x\", \"y\"]; // নতুন Array রিটার্ন হয়েছে","toreversed-মেথডঃ#toReversed() মেথডঃ":"Array.prototype.toReversed() মেথডের মাধ্যমে Arrayকে রিভার্স করা যায়, এতে মেইন Array অপরিবর্তিত থাকে।reverse() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করে।\nconst arr = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconst arr2 = arr.reverse();\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"e\", \"d\", \"c\", \"b\", \"a\"]; // মেইন Array পরিবর্তন হয়ে গেছে\n[\"e\", \"d\", \"c\", \"b\", \"a\"];\ntoReversed() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করেনা।\nconst arr = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconst arr2 = arr.toReversed();\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"b\", \"c\", \"d\", \"e\"]; // মেইন Array অপরিবর্তিত রয়েছে।\n[\"e\", \"d\", \"c\", \"b\", \"a\"]; // নতুন Array রিটার্ন হয়েছে","tosorted-মেথডঃ#toSorted() মেথডঃ":"Array.prototype.toSorted() মেইন Array কে পরিবর্তন না করে Array কে sort করার জন্য ব্যাবহার করা যায়।sort() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করে।\nconst arr = [\"a\", \"d\", \"c\", \"f\", \"e\"];\nconst arr2 = arr.sort();\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"c\", \"d\", \"e\", \"f\"]; // মেইন Array পরিবর্তন হয়ে গেছে\n[\"a\", \"c\", \"d\", \"e\", \"f\"];\ntoSorted() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করেনা।\nconst arr = [\"a\", \"d\", \"c\", \"f\", \"e\"];\nconst arr2 = arr.toSorted();\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"d\", \"c\", \"f\", \"e\"]; // মেইন Array অপরিবর্তিত রয়েছে।\n[\"a\", \"c\", \"d\", \"e\", \"f\"]; // নতুন Array রিটার্ন হয়েছে","with-মেথডঃ#with() মেথডঃ":"Array.prototype.with() মেথডের মাধ্যমে Arrayর নির্দিষ্ট পজিশনে কোন ভ্যালুকে অন্য একটি ভ্যালু দিয়ে পরিবর্তন করে নতুন Array রিটার্ন করে।উদাহরণঃ\nconst arr = [\"a\", \"d\", \"c\", \"f\", \"e\"];\nconst arr2 = arr.with(1, \"b\");\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"d\", \"c\", \"f\", \"e\"]; // মেইন Array অপরিবর্তিত রয়েছে।\n[\"a\", \"b\", \"c\", \"f\", \"e\"]; // নতুন Array রিটার্ন হয়েছে"}},"/reactive-accilarator/React-js/module-2/updating-object-in-state":{"title":"Updating Object in State","data":{"":"রিয়াক্টে যেকোন ধরনের জাভাস্ক্রিপ্ট ভ্যালুকে তার স্টেট হিসেবে নিতে পারে। কিন্তু যখনি আমরা রিয়াক্টের স্টেট হিসেবে কোন জাভাস্ক্রিপ্ট অবজেক্ট ব্যাবহার করবো তা কখনওই আমরা সরাসরি চেঞ্জ করতে পারবোনা বা মিউটেড করতে পারবোনা। এক্ষেত্র আমাদেরকে সম্পূর্ন নতুন অবজেক্ট দিয়ে আগের অবজেক্টকে রিপ্লেস করে দিতে হবে, নাহলে আগের অবজেক্ট থেকে একটা কপি বানিয়ে সেই কপি অবজেক্ট দিয়ে আগের স্টেট এর অবজেক্ট কে রিপ্লেস করে দিতে হবে। অর্থাৎ যেভাবেই করি আমাদেরকে সবসময় স্টেট আপডেট করার সময় নতুন ভ্যালু দিয়ে আগের ভ্যালু রিপ্লেস করে দিতে হবে।","what-is-a-mutation-মিউটেশন-কি-#(What is a Mutation) মিউটেশন কি ?":"মিউটেশন মানে হলো পরিবর্তন করা । জাভাস্ক্রিপ্টের ভাষায় কোন ভেরিয়েবল এর ভ্যালুকে সরাসরি পরিবর্তন করে ফেলাকে মিউটেশন বলা হয়। রিয়াক্ট স্টেটের ভ্যালুকে সরাসরি পরিবর্তন করাকে নিরুৎসাহিত করে। রিয়াক্টে স্টেট হিসেবে যেকোন ভ্যালু স্টোর করা যায় যেমনঃ string ,number,Boolean,Array ,Object।string ,number,Boolean হলো জাভাস্ক্রিপ্টের প্রিমিটিভ ভ্যালু যা read-only বা কখনো এগুলো পরিবর্তন করা যায়না।অন্যদিকে Array ,Object হলো রেফারেন্স ভ্যালু। যা টেকনিক্যালি পরিবর্তন করা গেলেও রিয়াক্ট স্টেট-এর ভ্যালুতে সরাসরি রেফারেন্স ভ্যালুকে পরিবর্তন করতে নিষেধ করে। রিয়াক্টে স্টেট আপডেটের ক্ষেত্রে এসব ভ্যালুকেও read-only হিসেবে চিন্তা করতে বলে ।জাভাস্ক্রিপ্ট এর প্রিমিটিভ ও রেফারেন্স ভ্যালু সম্পর্কে আরও বিস্তারিত জানতে চাইলে এখানে ক্লিক করুনচলুন একটু উদাহরণের মাধ্যমে বিস্তারিত বুঝিঃ\nconst [x, setX] = useState(0);\nএখানে স্টেট ভ্যারিএবল x এর ভ্যালু হিসেবে 0 রাখা হয়েছে, 0 হলো একটি প্রিমিটিভ ভ্যালু।\nsetX(5);\nএখানে setX করে স্টেট ভ্যারিএবল x এর ভ্যালু 5 করা হয়েছে । এখানে x এর ভ্যালু 0 কে কিন্তু চেঞ্জ করা হয়নি,কেননা এটা হলো একটা প্রিমটিভ ভ্যালু যা কখনো চেঞ্জ করা যায়না বা read-only বরং 5 যা একটি নতুন ভ্যালু, তা দিয়ে আগের ভ্যালুকে রিপ্লেস করা হয়েছে ।কিন্তু যখন আমাদের স্টেট এর ভ্যালু এমন অবজেক্ট হবে,\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nযদিও এটা টেকনিকালি position.x = 5; এভাবে পরিবর্তন করা সম্ভব কিন্তু এটা করলে তা মেইন অবজেক্ট কে মিউটেড করা হয়। যা রিয়াক্ট কখনওই রিকমেন্ড করেনা। আপনাকে অবশ্যই স্টেট চেঞ্জ করার সময় সম্পুর্ন নতুন ভ্যালু বা নতুন অবজেক্ট দিয়ে আগের ভ্যালুকে রিপ্লেস করে দিতে হবে।তাহলে কিভাবে করবো চলুন জেনে নেই।","treat-state-as-read-only-রিয়াক্টের-স্টেটকে-read-only-চিন্তা-করতে-হবে#(Treat state as read-only) রিয়াক্টের স্টেটকে read-only চিন্তা করতে হবে।":"import { useState } from \"react\";\nexport default function MovingDot() {\n    const [position, setPosition] = useState({\n        x: 0,\n        y: 0,\n    });\n    return (\n        <div\n            onPointerMove={(e) => {\n                position.x = e.clientX;\n                position.y = e.clientY;\n            }}\n            style={{\n                position: \"relative\",\n                width: \"100vw\",\n                height: \"100vh\",\n            }}>\n            <div\n                style={{\n                    position: \"absolute\",\n                    backgroundColor: \"red\",\n                    borderRadius: \"50%\",\n                    transform: `translate(${position.x}px, ${position.y}px)`,\n                    left: -10,\n                    top: -10,\n                    width: 20,\n                    height: 20,\n                }}\n            />\n        </div>\n    );\n}\nউপরের কোড এ একটা পয়েন্টার বানানো হয়েছে যা মাউস মুভ করার সাথে সাথে মাউসকে ফলো করে মুভ করার কথা। কিন্তু কোডটা রান করলে দেখা যাবে কোডটা কাজ করছেনা।কাজ করছেনা কারণ কোডের এই অংশে একটু ভুল আছে।\n    onPointerMove={e => {\n      position.x = e.clientX;\n      position.y = e.clientY;\n    }}\nএখানে onPointerMove event listener এ স্টেট ভ্যারিয়েবল position এর ভ্যালু একবার স্ক্রিনে রেন্ডার হয়ে যাওয়ার পর আবার সেই ভ্যালুকেই সরাসরি পরিবর্তন করা হয়েছে, এজন্যই কাজ করছেনা। কেননা চেঞ্জটা কোন setter function এ করা হচ্ছেনা, তাই রিয়েক্ট জানতেই পারছেনা যে স্টেট এর ভ্যালু চেঞ্জ হয়েছে এবং তাকে রি-রেন্ডার করতে হবে।এক্ষেত্রে এটা চেঞ্জ করতে হলে setter function এর ভিতরে চেঞ্জ করতে হবে যাতে ভ্যালু চেঞ্জ হলেই রি-রেন্ডার ট্রিগার হয়ে যায়।\nonPointerMove((e) => {\n    setPosition({\n        x: e.clientX,\n        y: e.clientY,\n    });\n});\nখেয়াল করে দেখেন, এখানে কিন্তু আগের position অবজেক্ট এর কোন ভ্যালুকে চেঞ্জ করা হয়নি,সম্পুর্ন নতুন একটা অবজেক্ট বানিয়ে আগের অবজেক্ট কে রিপ্লেস করে দেয়া হয়েছে।\nলোকাল মিউটেশন হলে সেটা ঠিক আছে।এভাবে কোড করা যাবেনা,যা স্টেটের বর্তমান অবজেক্ট position কেই সরাসরি চেঞ্জ করে।\nposition.x = e.clientX;\nposition.y = e.clientY;\nকিন্তু যদি এভাবে কোড করি, যাতে আমরা সম্পুর্ন নতুন একটা অবজেক্ট বানিয়ে আগের স্টেট ভ্যালুর অবজেক্ট কে রিপ্লেস করে দেই,তাহলে সেটা সম্পুর্নভাবে ঠিক আছে।\n    setPosition((e)=>{\n        x: e.clientX,\n        y: e.clientY\n    })\nআবার একটা লোকাল অবজেক্ট ভ্যারিয়েবল বানিয়ে সেটা দিয়েও চেঞ্জ করতে পারি, যেমনঃ\nconst nextPosition = {};\nnextPosition.x = e.clientX;\nnextPosition.y = e.clientY;\nsetPosition(nextPosition);\nএভাবে করলেও ঠিক আছে কেননা এখানে স্টেট ভ্যারিএবল এর position অবজেক্ট কে মডিফাই করা হচ্ছেনা, এখানে একটা নতুন অবজেক্ট বানিয়ে স্টেট এর আগের ভ্যালুকে রিপ্লেস করা হচ্ছে।মিউটেশন তখনই প্রব্লেম যখন আপনি কোন স্টেট এর এক্সিস্টীং অবজেক্টে সরাসরি পরিবর্তন করছেন, তা নাহলে আপনি লোকাল ভেরিয়েবল পরিবর্তন করতে পারেন,এতে কোন সমস্যা নাই","copying-objects-with-the-spread-syntax#Copying objects with the spread syntax":"আগের উদাহরণে আমরা যেমন দেখলাম যে যখনি আমরা স্টেট এর অবজেক্ট ভ্যালু পরিবর্তন করবো তখন আমাদের একটা নতুন অবজেক্ট স্টেটে দিতে হবে। তার মানে আমাদের প্রতিবার একটা করে ফ্রেশ অবজেক্ট বানাতে হচ্ছে।কিন্তু আমাদের অবজেক্ট যদি অনেক বড় হয় তাহলে যখনি স্টেট আপডেট করতে চাইবো তখনি যদি এত বড় অবজেক্ট নতুন করে লিখতে যাই তাহলে সেটা একটা সমস্যা এবং এতে ভুল হওয়ার সম্ভাবনা বেশি থাকে।এক্ষেত্রে আমরা আগের অবজেক্ট এর একটা কপি বানিয়ে নিয়ে শুধুমাত্র যেই যেই ভ্যালু পরিবর্তন করতে চাই,সেগুলো পরিবর্তন করে দিলেইতো ঝামেলা শেষ।এই কাজটা করতেই জাভাস্ক্রিপ্ট এর ... spread অপারেটর আমাদের হেল্প করে থাকে। ... spread অপারেটর ব্যাবহার করে আমরা আগের অবজেক্ট এর একটা Shallow কপি বানিয়ে নিতে পারি। তবে মনে রাখতে হবে ... spread অপারেটর নেস্টেড অবজেক্ট এর ক্ষেত্রে শুধুমাত্র এক লেবেল কপি করে। যদি ডিপলি কপি করতে চাই তাহলে ... spread অপারেটর একাধিকবার ব্যাবহার করতে হবে।Shallow Copy এবং Deep Copy সম্পর্কে আরও বিস্তারিত জানতে এই লিঙ্ক এ ক্লিক করুনধরুন আমাদের এই অবজেক্ট স্টেট ভ্যারিয়বলের firstName প্রপার্টির ভ্যালু চেঞ্জ করা লাগবে।\nconst [person, setPerson] = useState({\n    firstName: \"Barbara\",\n    lastName: \"Hepworth\",\n    email: \"bhepworth@sculpture.com\",\n});\nতাহলে আমরা এভাবে করতেই পারিঃ\nsetPerson({\n    firstName: \"Shahadat Hussain Ripon\",\n    lastName: \"Hepworth\",\n    email: \"bhepworth@sculpture.com\",\n});\nএটা খুব ভালোভাবেই কাজ করবে। কিন্তু এতে আমাদের একই জিনিস বার বার লেখা লাগছে,কিন্তু যদি আমরা ...spread অপারেটর ব্যাবহার করি তাহলে আমরা আরও সহজে এভাবে লিখতে পারি।\nsetPerson({\n    ...person, // এখানে আমাদের আগের অবজেক্টের সকল ডাটা কপি হয়ে নতুন অবজেক্ট এর প্রপার্টি হিসেবে বসে গেছে।\n    firstName: \"Shahadat Hussain Ripon\", // এখানে আমরা প্রপার্টির ভ্যালু চেঞ্জ করছি\n});","updating-a-nested-object-কিভাবে-নেস্টেড-অবজেক্টকে-স্টেট-এ-আপডেট-করতে-হয়#(Updating a nested object) কিভাবে নেস্টেড অবজেক্টকে স্টেট এ আপডেট করতে হয়?":"ধরুন আমাদের স্টেট এর স্ট্রাকচার এমনঃ\nconst [person, setPerson] = useState({\n    name: \"Niki de Saint Phalle\",\n    artwork: {\n        title: \"Blue Nana\",\n        city: \"Hamburg\",\n        image: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n    },\n});\nএবং আমরা person.artwork.city এর ভ্যালু আপডেট করতে চাই।তাহলে আমরা এভাবে করতে পারি।\nconst changedArtwork = { ...person.artwork, city: \"Narayangonj\" };\nconst changedPerson = { ...person, artwork: changedArtwork };\nsetPerson(changedPerson);\nঅথবা যদি আমরা একটা সিঙ্গেল ফাংশন কলের ভিতরেই চেঞ্জ করতে চাই, তাহলে এভাবে করতে পারি,\nsetPerson({\n    ...person, // আগের অবজেক্ট এর সমস্ত ফিল্ড কপি করা হয়েছে\n    artwork: {\n        ...person.artwork, // আগের অবজেক্ট এর artwork ফিল্ডের সমস্ত ডাটা কপি করা হয়েছে\n        city: \"Narayangonj\", // প্রপার্টির ভ্যালু পরিবর্তন করা হয়েছে\n    },\n});\nসত্যি হলো যে অবজেক্ট কখনই নেস্টেড নয়।\nlet obj = {\n    name: \"Niki de Saint Phalle\",\n    artwork: {\n        title: \"Blue Nana\",\n        city: \"Hamburg\",\n        image: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n    },\n};\nএই অবজেক্টটাকে এভাবে দেখে মনে হচ্ছে এটা নেস্টেড,কিন্তু সত্যিটা হলো যে যখন আমাদের কোড এক্সিকিউট হবে,তখন আসলে নেস্টেড অবজেক্টের কোন অস্তিত্ব নেই। তখন আসলে এটা দুইটা অবজেক্ট হয়ে যাবে।\nlet obj1 = {\n    title: \"Blue Nana\",\n    city: \"Hamburg\",\n    image: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n};\nlet obj2 = {\n    name: \"Niki de Saint Phalle\",\n    artwork: obj1,\n};\nতারপর হয়তো একটা অবজেক্ট এর রেফারেন্স নিয়ে অন্য আরেকটা অবজেক্ট তৈরি হতে পারে, এভাবেঃ\nlet obj1 = {\n    title: \"Blue Nana\",\n    city: \"Hamburg\",\n    image: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n};\nlet obj2 = {\n    name: \"Niki de Saint Phalle\",\n    artwork: obj1,\n};\nlet obj3 = {\n    name: \"Something\",\n    artwork: obj1,\n};\nএমন অবস্থায় আপনি যদি obj1 এ কোন চেঞ্জ করেন তাহলে রেফারেন্স ভ্যালু হউয়ার কারনে obj3 তে গিয়েও সেই চেঞ্জটা এফেক্ট করবে।","write-concise-update-logic-with-immer-ইমার-এর-মাধ্যমে-নিশ্চিন্তে-নেস্টেড-অবজেক্ট-পরিবর্তন-করা#(Write concise update logic with Immer) ইমার এর মাধ্যমে নিশ্চিন্তে নেস্টেড অবজেক্ট পরিবর্তন করা।":"আমরা স্টেট এর নেস্টেড অবজেক্টগুলোকে খুব সহজে ,কোন কিছু চিন্তা ভাবনা ছাড়াই পরিবর্তন করতে চাইলে রিয়াক্ট একটা থার্ড পার্টি প্যাকেজ রিকমেন্ড করে Immerনামে।আমরা চাইলে Immer ব্যাবহার করেও আমাদের কমপ্লেক্স ন্যাস্টেড অবেজক্ট স্টেট গুলো খুব সহজেই পরিবর্তন করতে পারি।Immer আমাদেরকে draft নামে একটা স্পেশাল অবজেক্ট দেয়,যেটা আগের কমপ্লেক্স অবজেক্ট এর একটা Proxy অবজেক্ট বানিয়ে নেয়, এবং আমরা কি কি পরিবর্তন করি তা সে খুঁজে বের করে, আগের অবজেক্ট কে ইমিউটিভলি আপডেট করে দেয়। এক্ষেত্রে Mutation এর ব্যাপারটা Immerনিজে ম্যানেজ করে বলে আমাদের টেনশন নিতে হয়না।","immer-কিভাবে-ব্যাবহার-করতে-হয়#Immer কিভাবে ব্যাবহার করতে হয়।":"","install-immer-package#install Immer package":"npm install use-immer","import-useimmer#import useImmer":"import { useImmer } from \"use-immer\";","change-usestate-to-useimmer#change useState to useImmer":"useState কে চেঞ্জ করে useImmer হবে\nimport { useImmer } from \"use-immer\";\nconst [person, setPerson] = useState({}); // এই লাইনটিকে চেঞ্জ করতে হবে\nconst [person, updatePerson] = useImmer({}); // এভাবে স্টেট ডিফাইন করতে হবে।","update-state-like-below#Update state like below":"import { useImmer } from \"use-immer\";\nconst [person, updatePerson] = useImmer({\n    firstName: \"Barbara\",\n    lastName: \"Hepworth\",\n    contact: {\n        email: \"bhepworth@sculpture.com\",\n        phone: \"+8801913509868\",\n        github: \"deveripon\",\n    },\n});\nupdateImmer((draft) => {\n    // state updater immer function\n    draft.firstName = \"Shahadat Hussain \";\n    draft.lastName = \"Ripon\";\n    draft.contact.email = \"devripon.io@gmail.com\";\n});\nএভাবে করলে হয়তো মনে হতে পারে আমরা রিয়াক্টের রুলস ব্রেক করছি,কিন্তু না আসলে আমরা এখানে draft কে মিউটেড করলেও, আন্ডার দ্যা হুড, Immer নিজে আমাদের স্টেট টা ইমিউটিভলি আপডেট করছে।"}},"/reactive-accilarator/React-js/module-3/choosing-the-state-structure":{"title":"Choosing the State Structure","data":{"":"রিয়াক্টে স্টেট ডিজাইন করার সময় আমাদের কিছু পিন্সিপাল মনে রাখা অবশ্যই জরুরি,এতে আমরা আরও সুন্দর ও ইফিশিয়েন্ট ভাবে স্টেটগুলো ম্যানেজ করতে পারবো। চলুন জেনে নেয়া যাক সেই প্রিন্সিপালগুলো,যেগুলো রিয়াক্টের স্টেট এর স্ট্রাকচার করার সময় আমাদের অবশ্যই মাথায় রাখতে হবে\nGroup Related State\nAvoid Contradictions in State\nAvoid Redundant State\nAvoid Duplication is State\nAvoid Deeply Nested State","group-related-state-একইজাতীয়-বা-পারস্পারিক-সম্পর্কযুক্ত-স্টেটগুলোকে-একটা-স্টেটে-গ্রুপ-করে-নেয়া#Group Related State (একইজাতীয় বা পারস্পারিক সম্পর্কযুক্ত স্টেটগুলোকে একটা স্টেটে গ্রুপ করে নেয়া)":"যদি এমন হয় যে মাল্টিপল স্টেট কিন্তু একটা আরেকটার সাথে সম্পর্কযুক্ত,এবং একটা চেঞ্জ করলে অন্যটাও চেঞ্জ করার প্রয়োজন পরে সেই ক্ষেত্রে স্টেটগুলোকে একটা স্টেট হিসেবে গ্রুপ করে নেয়া উচিত। যেমন ঃ\nconst [x, setX] = useState(0);\nconst [y, setY] = useState(0);\nএখানে একটা কাস্টম কার্সর বানানোর জন্য x এবং y নামে দুইটা স্টেট নেয়া হয়েছে, এবং মাউসমুভ করার সাথে সাথে স্টেটগুলো আপডেট হতে হবে, তার মানে মাউসমুভ হলেই আমাকে x এবং y দুইটা স্টেট পরিবর্তন করতে হবে। তাহলে আমরা এভাবে দুইটা স্টেট না নিয়ে বরং একটা স্টেট নিতে পারি positionনামে এবং এর ভ্যালু হিসেবে x এবং y কে একটা অবজেক্ট আকারে রাখতে পারি।\nconst [position, setPosition] = useState({ x: 0, y: 0 });","avoid-contradictions-in-state-একই-সাথে-দুইটাই-কখনও-সত্য-অথবা-মিথ্যা-না-হলে-দুইটা-কে-একটা-স্টেট-হিসেবে-নেয়া#Avoid contradictions in state (একই সাথে দুইটাই কখনও সত্য অথবা মিথ্যা না হলে দুইটা কে একটা স্টেট হিসেবে নেয়া)":"এমন অনেক সিনারিও আসতে পারে যেখানে হয়তো দুইটা স্টেট আছে যেখানে হয়তো দুইটা স্টেট আছে,কিন্তু স্টেট দুইটা কখনোই একইসাথে সত্য অথবা একই সাথে মিথ্যা হতে পারেনা। এসব স্টেটকে বলা হয় Contradiction in State। এমন হলে দুইটা স্টেট কখনোই নেয়া উচিত না,বরং একটা স্টেট দিয়েই দুইটাকেই ম্যনেজ করা উচিত।উদাহরণসরূপ একটা লাইটের কথা চিন্তা করুনঃএকটা লাইট আছে, যার দুইটা স্টেট১। লাইট জালানো অবস্থা (isOn)২। লাইট বন্ধ অবস্থা (isOff)\nconst [isOn, setIsOn] = useState(true);\nconst [isOff, setIsOff] = useState(true);\nএখানে এই দুইটা স্টেট কি কখনো একইসাথে দুইটাই true অথবা false হতে পারে? মানে একই সাথে লাইট জালানো বা বন্ধ করা থাকতে পারে ? না সেটা কখনই হতে পারেনা, এটাকেই বলা হয় Contradiction in State। এমন অবস্থায় আমাদের একটাই স্টেট নেয়া উচিত যেমনঃ\nconst [lightStatus, setLigthStatus] = useState(\"on\");\nএভাবে আমরা একটা স্টেট দিয়েই লাইটের দুইটা অবস্থা ম্যানেজ করতে পারি।","avoid-redundant-state-অপ্রয়োজনীয়-স্টেট-না-নেয়া-বা-পরিহার-করা#Avoid redundant state (অপ্রয়োজনীয় স্টেট না নেয়া বা পরিহার করা)":"যদি আমরা কোন স্টেটকে অন্য স্টেট থেকে কেলকুলেট করে নিয়ে ব্যাভারা করতে পারি তাহলে আমাদের নতুন স্টেট না নিয়ে সেই কেলকুলেটেড স্টেট দিয়েই কাজ করা উচিত।এটাকে Derived Stateও বলা হয়ে থাকে\nDerived State: যখন কোন ভ্যালু অন্য কোন স্টেট এর ভ্যালু থেকে calculate করে ব্যাবহার করা যায়, তখন সেই Calculated ভ্যারিয়েবল কে Derived State বলা হয়\nধরুন আমাদের এমন তিনটা স্টেট ম্যানেজ করা লাগবে,firstName, lastName, fullName। এখেত্রে আমদের স্টেট গুলো হবে এমন,\nconst [firstName, setFirstName] = useState(\"Shahadat\");\nconst [lastName, setLastName] = useState(\"Hussain\");\nconst [fullName, setFullName] = useState(\"Shahadat Hussain\");\nচিন্তা করে দেখেনতো, এখানে কি আমাদের fullName স্টেট-এর কোন দরকার ছিল? আমরা চাইলেইতো firstName,এবং lastName থেকে fullName টা বানিয়ে নিতে পারতাম এভাবে,\nconst fullName = firstName + \" \" + lastName;\nএক্ষেত্রে\nconst [fullName, setFullName] = useState(\"Shahadat Hussain\");\nএই স্টেট টা ছিল Redundant বা অপ্রয়োজনীয়। আমাদের এসব Redundant স্টেটকে Avoid করতে হবে।","dont-mirror-props-in-state-প্রপ্স-মিরর-করা-এড়িয়ে-চলতে-হবে#Don't mirror props in state (প্রপ্স মিরর করা এড়িয়ে চলতে হবে)":"একটা স্টেটকে যখন প্যারেন্ট কম্পোনেন্ট এ ডিক্লেয়ার করে সেটার ভ্যালুটা চাইল্ড কম্পোনেন্টে পাস করা হয়, এবং চাইল্ড কম্পোনেন্ট সেই প্রপ্সটা নিয়ে আবার তার নিজস্ব স্টেট এর ভ্যালুকে ইনিশিয়ালাইজ করে,সেটা কে বলা হয় প্রপ্স মিরর করা।এটা করা যাবেনা, কেননা যদি আপনি একবার কোন স্টেট ভ্যালু প্যারেন্ট থেকে চাইল্ডে পাস করেছেন এবং সেটা চাইল্ডের নিজস্ব স্টেট ভ্যরিয়েবল এর ইনিশিয়াল ভ্যালু হিসেবে ব্যাবহার করেছেন,তখন যদি আপনি চাইল্ড কম্পোনেন্ট থেকে স্টেট ভ্যালু চেঞ্জ করেত চান,তখন চাইল্ড থেকে সেটা পরিবর্তন করতে পারলেও, যদি প্যারেন্ট থেকে সেট স্টেট যেটা আপনি প্রপ্স হিসেবে চাইল্ডে পাঠিয়েছেন,সেটার কোন কন্ট্রোল থাকবেনা,এবং প্যারেন্ট থেকে তা পরিবর্তন করা যাবেনা। কেননা স্টেট এর ইনিশিয়াল ভ্যালু কম্পোনেন্টের প্রথম রেন্ডারেই ইনিশিয়ালাইজ হয়, পরে আর ইনিশিয়াল ভ্যালু চেঞ্জ হয়না। শুধু setter function এর মাধ্যমেই সেই স্টেট এর ভ্যালু চেঞ্জ করা যায়।তাই এখেত্রে প্যারেন্ট কম্পোনেন্টে সেই স্টেটটা পরিবর্তন করলেও তা কিন্তু প্রপ্স হয়ে আর চাইল্ড কম্পোনেন্টে যাবেনা, কেননা প্রথম রেন্ডারেই চাইল্ডের স্টেটের ইনিশিয়াল ভ্যালু সেট হয়ে গেছে।","avoid-duplication-in-state-ডুপ্লিকেট-স্টেট-নেয়া-যাবেনা#Avoid duplication in state (ডুপ্লিকেট স্টেট নেয়া যাবেনা)":"একি ভ্যালু যদি মাল্টিপল স্টেট ভ্যারিয়েবল ব্যাবহার করে সেটাকে ডুপ্লিকেট করা বলে। আমাদের এসব ডুপ্লিকেট স্টেট এর ব্যাপারে সতর্ক থাকতে হবে।অর্থাৎ যদি এমন হয় যে আমাদের কোন স্টেট ভ্যারিয়েবল এ কিছু ভ্যালু আছে,এবং সেই একই ভ্যালু দিয়ে আমরা আরও একটা স্টেট নিয়েছি, সেটাকে ডুপ্লিকেট করা বলা হয়, স্টেট ডুপ্লিকেট করা যাবেনা,প্রয়োজনে এক্ষেত্রে Derived State ব্যাবহার করতে হবে।","avoid-deeply-nested-state-ডিপলি-নেস্টেড-অবজেক্ট-কে-স্টেট-হিসেবে-নেয়া-থেকে-বিরত-থাকতে-হবে#Avoid deeply nested state (ডিপলি নেস্টেড অবজেক্ট কে স্টেট হিসেবে নেয়া থেকে বিরত থাকতে হবে)":"যদি এমন হয় যে আমাদের এমন একটা স্টেট আছে যা একটা অবজেক্ট এবং তার প্রপারর্টি হিসেবে আরও একটা অবজেক্ট আছে, এবং সেই নেস্টেড অবজেক্ট এর-ও আরও নেস্টেড অনেক অবঞ্জেক্ট আছে, এভাবে অনেক লেয়ার ডীপ একটা নেশটেড অবজেক্ট । যা একটা কমপ্লেক্স স্ট্রাকচার।এমন স্ট্রাকচার নিয়ে কাজ করলে স্টেট আপডেট করতে হলে সেটা কোডের কপ্লেক্সিটি বাড়াবে,বাগ হতে পারে, কোডটার রিডেবিলিটি নষ্ট হবে। তাই এমন অবজেক্টকে স্টেট হিসেবে নেয়া পরিহার করতে হবে।সেক্ষেত্রে সেই অবজেক্ট ডাটাকে normalize বা flatten করে নিয়ে তারপর স্টেট হিসেবে ব্যাবহার করতে হবে।"}},"/reactive-accilarator/React-js/module-3/declaretive-imperative":{"title":"Declaretive Imperative","data":{"":"ডিক্লারেটিভ (Declarative) এবং ইম্পারেটিভ (Imperative) প্রোগ্রামিং এপ্রোচ দুটি প্রোগ্রামিং করার ভিন্ন ভিন্ন পদ্ধতি। আসুন, প্রথমে প্রতিটি এপ্রোচের মূল ধারণা বুঝি, তারপরে কোডের উদাহরণ দেখি।","১-ইম্পারেটিভ-imperative-এপ্রোচ#১. ইম্পারেটিভ (Imperative) এপ্রোচ:":"ইম্পারেটিভ প্রোগ্রামিংয়ে আপনি কীভাবে কিছু করবেন তা ধাপে ধাপে বলে দেন। আপনি প্রতিটি পদক্ষেপ নির্দিষ্টভাবে বর্ণনা করেন এবং কম্পিউটার সেই পদক্ষেপগুলি ঠিকমতো অনুসরণ করে। এটি অনেকটা রান্নার রেসিপির মতো, যেখানে প্রতিটি ধাপ স্টেপ বাই স্টেপ বলে দেয়া থাকে।","উদাহরণ#উদাহরণ:":"ধরুন, আমাদের একটি অ্যারের উপাদানগুলিকে ২ দিয়ে গুণ করতে হবে।\n// Imperative approach\nconst numbers = [1, 2, 3, 4, 5];\nconst doubledNumbers = [];\nfor (let i = 0; i < numbers.length; i++) {\n    doubledNumbers.push(numbers[i] * 2);\n}\nconsole.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]\nএখানে আমরা একটি লুপ দিয়ে প্রতিটি উপাদানকে ২ দিয়ে গুণ করে নতুন অ্যারেতে পুশ করছি। প্রতিটি পদক্ষেপ যেমনঃ\nলুপিং,\nগুণ,\nপুশ\nস্পষ্টভাবে বলে দেয়া হয়েছে।","২-ডিক্লারেটিভ-declarative-এপ্রোচ#২. ডিক্লারেটিভ (Declarative) এপ্রোচ:":"ডিক্লারেটিভ প্রোগ্রামিংয়ে আপনি কী করতে চান সেটি বলেন, তবে কীভাবে করবেন তা নির্দিষ্টভাবে উল্লেখ করেন না। কম্পিউটারকে নির্দিষ্টভাবে প্রতিটা স্টেপ বলে দিতে হয় না।এই এপ্রোচে আপনি মূলত কী চান শুধু তা বলে দেন, আর ভেতরের ইম্প্লিমেন্টেশন কম্পিউটার নিজেই বোঝে নেয় ।","উদাহরণ-1#উদাহরণ:":"উপরে যে একই কাজ করলাম, এবার ডিক্লারেটিভ এপ্রোচে করবো:\n// Declarative approach\nconst numbers = [1, 2, 3, 4, 5];\nconst doubledNumbers = numbers.map((num) => num * 2);\nconsole.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]\nএখানে .map() ফাংশন ব্যবহার করেছি, যা প্রত্যেকটি উপাদানকে ২ দিয়ে গুণ করছে এবং নতুন অ্যারে তৈরি করছে। তবে, কোন লুপের উল্লেখ নেই—অ্যারের উপরে কাজ করতে কীভাবে গুণ করতে হবে, তা সরাসরি বলিনি। শুধু বলেছি, \"প্রতিটি উপাদানকে ২ দিয়ে গুণ করো\"।","প্রধান-পার্থক্য#প্রধান পার্থক্য:":"ইম্পারেটিভ: প্রতিটি ধাপ স্টেপ বাই স্টেপ বলে দিতে হয়,কীভাবে কাজটি সম্পন্ন হবে তা নির্দিষ্টভাবে উল্লেখ করতে হয়।\nডিক্লারেটিভ: শুধু কী করতে হবে তা বলে দিতে হয়, আর কীভাবে করতে হবে তা গোপন থাকে বা কম্পিউটার নিজেই বুঝে নেয়।","রিয়াক্ট-কি-এপ্রোচে-তার-ইউ-আই-চেঞ্জ-করে#রিয়াক্ট কি এপ্রোচে তার ইউ আই চেঞ্জ করে?":"React মূলত ডিক্লারেটিভ (Declarative) এপ্রোচে তার UI পরিবর্তন করে। এর অর্থ হলো, React-এ আপনি কীভাবে UI আপডেট হবে তা নিয়ে চিন্তা করার পরিবর্তে, UI-র বর্তমান অবস্থা কেমন হবে তা বর্ণনা করেন, আর React নিজেই সেই UI-টি আপডেট করার জন্য ভেতরে ভেতরে প্রয়োজনীয় কাজ করে নেয়।","react-এর-ডিক্লারেটিভ-এপ্রোচ-কীভাবে-কাজ-করে#React-এর ডিক্লারেটিভ এপ্রোচ কীভাবে কাজ করে?":"Declarative Components: React-এ আপনি প্রতিটি UI অংশ (component) তৈরি করার সময়, প্রতিটি কম্পোনেন্টকে বলে দেন কীভাবে সেটা দেখতে হবে। আপনি UI এর শেষ অবস্থা (final state) বলে দেন, কিন্তু সেই অবস্থা কীভাবে পরিবর্তন হবে তা নির্দিষ্টভাবে বলে দিতে হয় না।উদাহরণ:\nfunction Greeting({ name }) {\n    return <h1>Hello, {name}!</h1>;\n}\nএখানে আমরা শুধু বলে দিচ্ছি, \"এই component-টি কেমন দেখতে হবে,\" কিন্তু কীভাবে render হবে বা কতবার হবে তা চিন্তা করতে হচ্ছে না। React সেই কাজগুলো নিজের মতো করে করে নিচ্ছে।\nState Changes: React-এর ডিক্লারেটিভ এপ্রোচের আরেকটি গুরুত্বপূর্ণ বিষয় হলো state। আপনি যখন কোনো state পরিবর্তন করেন, React সেই state অনুযায়ী UI-কে আপডেট করে।উদাহরণ:\nimport React, { useState } from \"react\";\nfunction Counter() {\n    const [count, setCount] = useState(0);\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={() => setCount(count + 1)}>Click me</button>\n        </div>\n    );\n}\nএখানে, আমরা state (count) এর মান পরিবর্তন করলে, React সেই অনুযায়ী UI-কে রি-রেন্ডার করে। আমরা শুধু জানাচ্ছি UI কেমন দেখতে হবে যখন state পরিবর্তন হবে, কিন্তু কিভাবে DOM ম্যানিপুলেট হবে বা পরিবর্তনগুলো কীভাবে ঘটবে, তা React-এর দায়িত্ব।\nVirtual DOM: React-এর ডিক্লারেটিভ UI পরিবর্তনের আরেকটি বড় বিষয় হলো Virtual DOM। যখন state বা props পরিবর্তিত হয়, React প্রথমে সেই পরিবর্তনগুলোকে Virtual DOM-এর মাধ্যমে চেক করে, এবং তারপর প্রয়োজনীয় স্থানে শুধুমাত্র প্রয়োজনীয় UI অংশটুকু আপডেট করে।\nReact নিজেই Virtual DOM ব্যবহার করে কীভাবে পরিবর্তন করতে হবে, সেটি নির্ধারণ করে নেয়। ফলে ডেভেলপারকে DOM নিয়ে চিন্তা করতে হয় না।React-এর UI আপডেটিং পদ্ধতি ডিক্লারেটিভ এপ্রোচে কাজ করে। এর ফলে ডেভেলপাররা কেবল UI-র শেষ অবস্থা কী হবে তা বলে দেয়, আর React ভেতরে ভেতরে কীভাবে সেই পরিবর্তনগুলো ঘটাবে তা নিজে থেকেই করে।"}},"/reactive-accilarator/React-js/module-3/extracting-state-logic-into-reducer":{"title":"Extracting State Logic into Reducer","data":{"extracting-state-logic-into-a-reducer#Extracting State Logic into a Reducer":"এই লেসনে আমরা সর্বপ্রথম useReducer হুকটা নিয়ে কথা বলছি, useReducer হুকটা হলো রিয়াক্টের অনেকগুলো হুকের মধ্যে একটি আমাদের কমপ্লেক্স স্টেট ম্যানেজমেন্টকে এফিসিয়েন্টভাবে হ্যন্ডেল করতে সাহায্য করে।চলুন সবার প্রথমে useReducer হুকটা কি,কিভাবে কাজ করে এটা জেনে নেই, পরে জানবো কিভাবে এটা কোডে ব্যাবহার করতে পারি।","introduction-of-usereducer-hook#Introduction of useReducer Hook":"useReducer হলো রিয়াক্ট এর একটি হুক যা জাভাস্ক্রিপ্ট এর Array.reducer() মেথড টা ইউজ করে বানানো হয়েছে । useReducer হুকটিও আমাদের রিয়াক্টের স্টেট ম্যনেজমেন্ট করতে হেল্প করে।আমরা এতদিন স্টেট ম্যানেজমেন্ট করার জন্য যেই useState হুক ব্যাবহার করতাম সেটি মূলত এই useReducer হুকের উপর বেইসড করেই বানানো হয়েছে।তাহলে প্রশ্ন হলো কখন আমরা কোনটা ব্যাবহার করবো? - সে বিষয়ে আমরা বিস্তারিত জানবো, তবে এখন শুধু এটা মাথায় রাখতে হবে যে রিয়াক্টের কমপ্লেক্স স্টেট ম্যানেজমেন্ট করার জন্য useReducer হুকটি ব্যাবহার করা হয়।","syntax-of-usereducer-hook#Syntax of useReducer Hook":"const [updatedStateFullValue, dispatch] = useReducer(reducerFunc, initialState);","anatomy-of-usereducer-hook#Anatomy of useReducer Hook":"useReducer হুকটি দুইটা আর্গুমেন্ট নেয়,\nReducer Function: এই ফাংশনটির মাধ্যমে আমাদের স্টেট চেঞ্জ এর সমস্ত বিজনেস লজিকগুলো ম্যানেজ করা হয়ে থাকে। এটা প্যারামিটার হিসেবে দুইটা জিনিস নেয়,\nstate: এটা আমাদের স্টেট এর যেই ভ্যালু তা রিটার্ন করে, যাতে আমরা reducer function এর ভিতরে আমাদের স্টেট গুলো ম্যানেজ করতে পারি।\naction: এটার ভিতরে মূলত থাকে আমাদের একশন, আমরা কোন একশনের ভিত্তিতে স্টেট এ কি করতে চাচ্ছি, সেই একশনটা এই action প্যারামিটারের ভিতর পাই, এখানে আমরা চাইলে অবজেক্ট আকারে মাল্টিপল জিনিস এক্সেস করতে পারি।\nInitial State: এইটা হলো আমাদের স্টেট এর যেই ইনিশিয়াল ভ্যালু।\nএবং একটা টুপল রিটার্ন করে,সেই টুপলে দুইটা জিনিস থাকে,\nUpdated stateful value: আমাদের রিডিউসার ফাংশন স্টেটকে আপডেট বা মডিফাই করে যেই Updated stateful value রিটার্ন করে, সেটা এটার ভিতর থাকে যা আমরা UI তে রেন্ডার করাতে পারি।\nDispatch Method: যেসব একশন অনুযায়ী reducer function স্টেট ম্যানেজ করবে সেই সব একশন reducer function এর কাছে পাঠানোর জন্য এর Dispatch Method ব্যাবহার হয়।","how-to-use-usereducer-hook#How to use useReducer Hook?":"আমরা তিনটা স্টেপ ফলো করে useReducer ব্যাবহার করতে পারি। চলুন উদাহরনের মাধ্যমে আমরা একটা Counter বানাই আর বুঝি কিভাবে useReducer ব্যবাহার করতে পারি।উদাহরনে আমারা নিচের এই JSX টা ব্যবাহার করবো।\n        export default function App(){\n            return (\n           <div>\n              <h1> Count : 0</h1>\n              <button>Increment</button>\n              <button>Decrement</button>\n          </div>\n            )\n        }\nএখানে App.jsx এ একটা কাউন্টার বানানো হয়েছে যেটাতে দুইটা বাটন আছে যার একটায় চাপ দিলে কাউন্টারের ভ্যালু increment হবে এবং অন্যটায় চাপ দিলে decrement হবে। চলুন তাহলে এই ফাংশনালিটি আমরা useReducer ব্যাবহার করে বানাই।","create-a-reducer-function-and-to-manage-state-changing-logic#create a reducer function and to manage state changing logic":"প্রথমে একটা reducer function বানাতে হবে এবং যেখানে আমরা আমাদের সমস্ত লজিক লিখবো যে বাটনের কোন একশনে আমরা স্টেট কিভাবে পরিবর্তন করবো।\nচলুন সেটা বানাই,\nconst counterReducer = (state, action) => {\n    switch (action.type) {\n        case \"INCREMENT\": {\n            return state + 1;\n        }\n        case \"DECREMENT\": {\n            return state - 1;\n        }\n        default: {\n            return state;\n        }\n    }\n};\nএখানে আমরা counterReducer নামে একটা reducer function নিয়েছি এবং তাতে আমরা action.type (action.type কি হবে তা আমরা পরে বাটন থেকে dispatch করবো) এর উপর ভিত্তি করে switch-case দিয়ে স্টেটকে পরিবর্তন করছি। এখানে আমরা চাইলে if-elseও ব্যাবহার করতে পারতাম।","add-usereducer-to-component#Add useReducer to Component":"তারপর যেখানে আমরা স্টেট ম্যানেজ করতে চাই,(এক্ষেত্রে আমারা App কম্পোনেন্টে ব্যবাহার করছি) সেখানে useReducer হুকটাকে ইম্পোর্ট করে ডিফাইন করা লাগবে। এবং Count এর ভ্যালু ডাইনামিকভাবে useReducer হুক থেকে নিয়ে ব্যাবহার করতে হবে।\nimport { useReducer } from \"react\";\nconst initialState = 0;\nexport default function App() {\n    const [count, dispatch] = useReducer(counterReducer, initialState);\n    return (\n        <div>\n            <h1> Count : {count}</h1>\n            <button>Increment</button>\n            <button>Decrement</button>\n        </div>\n    );\n}\nতারপর useReducer এর আর্গুমেন্ট হিসেবে reducer function এবং initialState দিতে হবে। reducer function যেই আপডেটেড স্টেটটা রিটার্ন করে সেটা আমরা যেকোন নামে ধরতে পারি, কিন্তু যেহেতু আমরা কাউন্টারের স্টেট মেনেজ করছি তাই আমরা এটাকে count নামে ধরেছি","call-dispatch-method-on-event-handlers-and-connect-the-event-handlers#call dispatch method on Event handlers and connect the event handlers":"এখন আমদের শুধু একশন গুলো dispatch করা বাকি। আমরা বাটনের onClick এ যেসব ইভেন্ট হ্যান্ডেলার এড করবো সেখানে dispatch মেথড কল করবো এবং আমরা যে একশন dispatch করতে চাই সেটা একটা অবজেক্ট আকারে পাঠিয়ে দিব reducer function এর কাছে। তবে আমরা চাইলে এটা ইভেন্ট হ্যন্ডেলারের মদ্ধ্যে কল না করে সরারসরি বাটনের onClick এ কল করে দিতে পারতাম।\nimport { useReducer } from \"react\";\nconst initialState = 0;\nexport default function App() {\n    const [count, dispatch] = useReducer(counterReducer, initialState);\n    //increment handler\n    function handleIncrementClick() {\n        return dispatch({\n            type: \"INCREMENT\",\n        });\n    }\n    //decrement handler\n    function handleDecrementClick() {\n        return dispatch({\n            type: \"DECREMENT\",\n        });\n    }\n    return (\n        <div>\n            <h1> Count : {count}</h1>\n            <button onClick={handleIncrementClick}>Increment</button>\n            <button onClick={handleDecrementClick}>Decrement</button>\n        </div>\n    );\n}\nব্যাস, এই তিনটা স্টেপ ঠিকঠাক ভাবে করলেই দেখবেন আমাদের হুক কাজ করছে।","comparing-usestate-and-usereducer#Comparing useState and useReducer":"রিয়াক্ট নিজেই তার ডকুমেন্টেশনে বলেছে যে, useReducer হুকেরও কিছু ডাউনসাইড রয়েছে, এটা এমন নয় যে আমরা সবসময় শুধু useReducerই ব্যাবহার করবো, আমরা প্রয়োজন অনুযায়ী useState এবং useReducer দুইটাই ব্যবাহার করবো। তবে একটা আরেকটার সাথে তুলনা করলে কিছু পার্থক্য বুঝা যায়,সেগুলো হলোঃ\nকোডের সাইজঃ useState ব্যবহার করলে useReducer এর চাইতে তুলনামূলক কম কোড লেখা লাগে, কিন্তু যখন এপ্লিকেশন অনেক বড় হবে এবং অনেক অনেক স্টেট ম্যনেজ করা লাগবে তখন কিন্তু আবার useState সেই একই ধরেনের স্টেট এর কাজগুলোকে আলাদা করে কোডকে ম্যানেজেবল করতে সাহায্য করে থাকে।\nকোড রিডেবিলিটিঃ useState ব্যবহার করলে যখন প্রজেক্ট ছোট থাকে তখন কোডের রিডেবিলিটি ভালো থাকে কিন্তু যখনি প্রজেক্ট বড় হতে থাকে সেই সাথে কোডের রিডেবিলিটিও নষ্ট হতে থাকে, এক্ষেত্রে reducer কোডের বিজনেস লজিকগুলোকে আলাদা করে ফেলে বলে কোডের রিডেবিলিটি ঠিক থাকে।\nডীবাগীংঃ useState ব্যাবহার করলে কোড ডীবাগ করাটা কঠিন হয়ে যায়, কেননা কোথায় কোথায় setter function কল হয়েছে তা খুঁজে বের করে ডীবাগ করাটা বেশ কঠিন, কিন্তু useReducer এর ক্ষেত্রে সমস্ত বিজনেস লজিকগুলো একটা জায়গায় ম্যানেজ হয় বলে এক্ষেত্রে ডীবাগ করা সহজ হয়ে যায়।\nটেস্টিংঃ reducer ফাংশনগুলোকে পিওর ফাংশন হতে হয়, তাই পিওর ফাংশন হউয়ার কারনে চাইলেই যেকোন সময় ফাংশন গুলোকে নিয়ে আলাদা এনভাইরনমেন্টেও সহজে টেস্টিং করা যায়।\nব্যাক্তিগত পছন্দঃ অনেকেই useReducer খুব পছন্দ করে,আবার কেউ কেউ useReducer ব্যাভার-ই করেনা। এটা একটা ব্যাক্তিগত পছন্দের ব্যাপার, তবে আমাদের শুধু useState বা শুধু useReducerই ব্যাবহার না করে আমরা দুইটাকে মিলিয়ে ব্যবাহার করবো, আমাদের যখন যে জায়গায় যেটার প্রয়োজন মনে হবে,আমরা সেটাই ব্যাবহার করবো","when-should-use-usereducer#When should use useReducer?":"আমরা আমাদের প্রয়োজন অনুযায়ী যখন যেটা প্রয়োজন হবে তখন সেটাই ব্যাবহার করবো, যখন আমাদের স্টেট লজিকগুলো কমপ্লেক্স হবে তখন আমরা useReducer ব্যাবহার করবো, আবার যখন আমাদের সিম্পল লোকাল স্টেট ম্যানেজ করা লাগবে তখন আমরা useState ব্যাবহার করতে পারি।চলুন একটু দেখে নেই কখন কোনটা ব্যাবহার করা উচিত।\nযখন\tuseState\tuseReducer\tState চেঞ্জ এর সংখ্যা\tসর্বোচ্চ তিনটা হবে\tঅনেক হবে\tএকাধিক state change যদি related হয়\tনা\tহ্যাঁ\tstate এর ডাটা টাইপ যদি\tString,Number,Boolean হয়\tObject,Array হয়\tযদি কমপ্লেক্স লজিক থাকে\tনা\tহ্যাঁ\tযদি state এর scope\tLocal হয়\tGlobal হয়"}},"/reactive-accilarator/React-js/module-3/lifting-state-up":{"title":"Lifting State Up","data":{"":"lifting state up বা স্টেটকে উপরে নিয়ে যাওয়া, এটা হচ্ছে রিয়াক্টের বেস্ট ডিজাইন প্যাটার্নগুলোর মধ্যে একটা","লিফটং-স্টেট-আপ-বলতে-কি-বুঝায়-#লিফটং স্টেট আপ বলতে কি বুঝায় ?":"রিয়াক্টে কোন স্টেট কে কম্পোনেন্টের লোকাল জায়গায় না রেখে সেটাকে লিফট করে প্যারেন্ট কম্পোনেন্ট এ নিয়ে যাওয়াকে লিফটিং স্টেট আপ বা স্টেট উপরে নিয়া যাওয়া বুঝায়।","লিফটিং-স্টেট-আপ-কেন-করতে-হয়#লিফটিং স্টেট আপ কেন করতে হয়?":"আমরা জানি যে, রিয়াক্ট কম্পোনেন্টের স্টেটগুলো সেই কম্পোনেন্টের ভিতর আইসোলেটেড থাকে, মানে তা হলো তার নিজস্ব কম্পোনেন্ট। সেই কম্পোনেন্ট একাধিকবার ব্যাবহার করা হলেও প্রতিটা ইউজে সে আলাদা আলাদা স্টেট মেন্টেইন করবে, কখনো একটা আরেকটার সাথে সিঙ্ক থাকবেনা। আবার এমনও হতে পারে যে কোন একটা কম্পোনেন্টে দুইটা বা তিনটা Sibling কম্পোনেন্ট আছে, যেমনঃ\nconst App = () => {\n    return (\n        <div>\n            <Product />\n            <Cart />\n        </div>\n    );\n};\nexport default App;\nএখানে App নামে একটা প্যারেন্ট কম্পোনেন্ট আছে, যার দুইটা চাইল্ড কম্পোনেন্ট হলো Product এবং Cart। Product এবং Cart এরা নিজেরা আবার Siblingএখন ধরুন আমাদের Product কম্পোনেন্টের একটা লোকাল স্টেট আছে সেই কম্পোনেন্টের ভিতরে। এখন যদি সেই স্টেট টা আমাদের চাইল্ড কম্পোনেন্টের ভিতরে প্রয়োজন হয় তাহলে আমরা কি করতে পারি? আমরা কিভাবে Product এর লোকাল স্টেট কে Cart এ পাঠাবো?এই ক্ষেত্রেই কাজে লাগে lifting state up প্যাটার্ণ। আমরা Productকম্পোনেন্টের লোকাল স্টেটকে তাদের ইমিডিয়েট প্যারেন্ট কম্পোনেন্ট App এ নিয়ে আসতে পারি। এবং App থেকে Props পাস করার মাধ্যমে আমরা একই স্টেট Product এবং Cart দুটো কম্পোনেন্টেই পাঠাতে পারি।","controlled-and-uncontrolled-components#Controlled and Uncontrolled Components":"Controlled and Uncontrolled Components এটা সম্পূর্ন রিয়াক্টের একটা টার্ম,এটা কোন প্রোগ্রামিং এর টেকনিক্যাল টার্ম না।","controlled-components#Controlled Components":"রিয়াক্টে Controlled Component বলতে বুঝায় যেসব কম্পোনেন্টের কনট্রোল সম্পুর্নভাবে প্যারেন্টের কাছে থাকে, মানে প্যারেন্ট তার নিজস্ব স্পেসে স্টেট ম্যানেজ করছে, এবং শুধু ডাটাগুলো Props এর মাধ্যমে চাইল্ডে পাঠিয়ে দিচ্ছে, এমন কম্পোনেন্ট কে রিয়াক্টে Controlled Component বলা হয়।অর্থাৎ Controlled Component গুলো Props এর উপর নির্ভর করে।","uncontrolled-components#UnControlled Components":"যেসব রিয়াক্ট কম্পোনেন্ট তার নিজ লোকাল স্পেসে স্টেট নিয়ে সেই স্টেট দিয়ে কাজ করে,সেটা হলো UnControlled Componentমানে হলো সেই কম্পোনেন্টের উপর প্যারেন্টের কোন কনট্রোল নেই,সে তার নিজস্ব স্টেট ডাটার উপর নির্ভর করে, প্যারেন্টর Propsএর উপর নির্ভর করেনা।"}},"/reactive-accilarator/React-js/module-3/preserving-and-reseting-state":{"title":"Preserving and Reseting State","data":{"preserving-and-resetting-state#Preserving and Resetting State":"রিয়াক্টের স্টেটগুলো তার কম্পোনেন্টের মধ্যে isolated থাকে, এবং রিয়াক্ট তার কম্পোনেন্টগুলোকে যখন রেন্ডার করে তখন সে তার কম্পোনেন্টগুলোকে তার রেন্ডার ট্রি তে কম্পোনেন্টগুলোর স্টেট সহ মনে রাখে, যাতে যখন প্রয়োজন সে চাইলে স্টেট রিসেট করতে পারে, অথবা চাইলে স্টেট রিসেট করতে পারে।রিয়াক্ট কখন স্টেট প্রিসার্ভ করে আর কখন স্টেটগুলো রিসেট করে ফেলে,তা বিস্তারিত জেনে নেওয়া যাকঃরিয়াক্ট মূলত তিনটা রুলস মানেঃ👉1.State is tied to a position in the render tree (রিয়াক্টের স্টেটগুলো কম্পোনেটের পজিশনের সাথে যুক্ত থাকে)👉2.Same component at the same position preserves state (সেম কম্পোনেন্ট সেম পজিশনে স্টেট ধরে রাখে)👉3.Different components at the same position reset state (একই পজিশনে আলাদা আলাদা কম্পোনেন্ট আসলে স্টেট রিসেট হয়ে যায়)","state-is-tied-to-a-position-in-the-render-tree#State is tied to a position in the render tree":"রিয়াক্ট তার কম্পোনেন্টগুলোকে রেন্ডার করার পর সকল কম্পোনেন্ট গুলোকে একটা ট্রি আকারে চিন্তা করে, এবং ট্রি এর প্রতিটা আলাদা আলাদা পজিশনে যেসব কম্পোনেন্ট গুলো আছে সেগুলোকেও সে সেই পজিশনের সাথে যুক্ত রাখে।মানে হলো রিয়াক্টের রেন্ডার ট্রি এর আলাদা আলাদা পজিশনে যদি একই কম্পোনেন্ট রি-ইউজ করা হয়, তাতে কিন্তু আলাদা আলাদা পজিশন হউয়ার কারনে প্রতিটা পজিশনের কম্পোনেটের স্টেট টাও আলাদা হয়। এবং সেই কারণেই একটায় স্টেট চেঞ্জ করলেও অন্যটায় স্টেট চেঞ্জ হয়না।\nimport { useState } from \"react\";\nexport default function App() {\n    const counter = <Counter />;\n    return (\n        <div>\n            {counter}\n            {counter}\n        </div>\n    );\n}\nfunction Counter() {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>{score}</h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nউপরে একটা কাউন্টার কম্পোনেন্ট কে দুইবার রি-ইউজ করা হয়েছে,\nexport default function App() {\n    const counter = <Counter />;\n    return (\n        <div>\n            {counter}\n            {counter}\n        </div>\n    );\n}\nএকানে একই কম্পোনেট দুইবার ব্যাবহার করা হলেও দুইটা কিন্তু দুই পজিশনে আছে, আমরা যদি উপরের কোডটার UI দেখি তাহলে এমন দেখতে পাবো এখানে দেখা যাচ্ছে দুইটা একই কম্পোনেট পাশাপাশি বসে আছে, পাশাপাশি বসে থাকলেও এই কম্পোনেট দুইটার রেন্ডার ট্রি-রিপ্রেজেটেশন হলো এমনঃ এখন তাহলে পরিষ্কার বুঝা যাচ্ছে যে, যদিও দুইটা একই কম্পোনেট কিন্তু রিয়াক্টের ট্রি তে তাদের পজিশন আলাদা আলাদা। আর এজন্যই একটা কম্পোনেন্টে স্টেট চেঞ্জ করলেও অন্য কম্পোনেন্টে কোন ধরনের কোন স্টেট পরিবর্তন হয়না। এজন্যই বলা হয় State is tied to a positionআমরা এটা আরও ভালো করে বুঝতে পারবো যদি নিচের উদাহরণগুলো একটু দেখি।চলুন একটা চেকবক্স এড করি,যাতে আমরা চাইলে দ্বিতীয় কাউন্টার কম্পোনেন্টকে চাইলে রেন্ডার করতে পারি আবার চাইলে রিমুভ করে দিতে পারি।\nimport { useState } from \"react\";\nexport default function App() {\n    const [showB, setShowB] = useState(true);\n    return (\n        <div>\n            <Counter />\n            {showB && <Counter />}\n            <label>\n                <input\n                    type='checkbox'\n                    checked={showB}\n                    onChange={(e) => {\n                        setShowB(e.target.checked);\n                    }}\n                />\n                Render the second counter\n            </label>\n        </div>\n    );\n}\nfunction Counter() {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>{score}</h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nআউটপুট: এখানে আমরা দুইটা কাউন্টারের সাথে একটা চেকবক্স দেখতে পাচ্ছি, আমরা কাউন্টারের স্টেট গুলো আপডেট করতে পারছি এবং চেকবক্স এ চাপ দিয়ে আনচেক করে দিলে দ্বিতীয় কাউন্টারটি রিমুভ হয়ে যাচ্ছে, এবং আবার চেক করলে চলে আসছে।কিন্তু খেয়াল করুন দ্বিতীয়বার যখন কম্পোনেন্টটি ফেরত আসলো তখন কিন্তু তার স্টেট রিসেট হয়ে গেছে, তাহলে এটা কেন হলো ?এটা এজন্য হলো যে, যখন চেকবক্স আনচেক করা হয়েছে তখন কম্পনেন্টটি তার পজিশন থেকে সমস্ত স্টেট সহ ডিলিট হয়ে গেছে, তাই দ্বিতীয়বার যখন আবার ফেরত আনা হচ্ছে তখন সে সম্পুর্ন নতুন কম্পোনেন্ট হয় আসছে।একানে রেন্ডার ট্রি তে যা ঘটছে তা হলোঃঅর্থাৎ কম্পোনেট ট্রি থেকে রিমুভ হয়ে গেলে ট্রি স্ট্রাকচার টা পরিবর্তন হয়ে যাচ্ছে, তাই কম্পোনেন্টের সকল স্টেট ডেস্ট্রয় হয়ে যাচ্ছে।সুতরাং কোন কম্পোনেন্ট যতক্ষণ তার নিজ পজিশনে বসে থাকে ততক্ষণ রিয়াক্ট স্টেট কে ধরে রাখে, যদি সেটি তার পজিশন থেকে রিমুভ হয়ে যায়,তাহলে স্টেট ও রিসেট হয় যায়।","same-component-at-the-same-position-preserves-state#Same component at the same position preserves state":"একই কম্পোনেট যতক্ষণ তার একই পজিশনে বসে থাকবে ততক্ষণ সে তার নিজস্ব স্টেট ধরে রাখবে। যদি এমনও হয় যে আপনি প্যারেন্ট কম্পোনেন্ট থেকে কোন স্টেট চেঞ্জ করছেন বা কন্ডীশনালি কিছু করছেন তবুও সেই কম্পোনেন্ট যতক্ষন তার নিজস্ব পজিশনে বসে থাকবে,ততক্ষণ সে তার লোকাল স্টেট ধরে রাখবে।\nimport { useState } from \"react\";\nexport default function App() {\n    const [isFancy, setIsFancy] = useState(false);\n    return (\n        <div>\n            {isFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />}\n            <label>\n                <input\n                    type='checkbox'\n                    checked={isFancy}\n                    onChange={(e) => {\n                        setIsFancy(e.target.checked);\n                    }}\n                />\n                Use fancy styling\n            </label>\n        </div>\n    );\n}\nfunction Counter({ isFancy }) {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    if (isFancy) {\n        className += \" fancy\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>{score}</h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nউপরের এই কোডে একটা কাউন্টার কম্পোনেন্টকে একটা কন্ডিশন দিয়ে রেন্ডার করা হয়েছে,\nconst [isFancy, setIsFancy] = useState(false);\nisFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />;\nএখানে দেখা যাচ্ছে যে একটি isFancy স্টেট এর উপর বেস করে এখানে কন্ডিশনালি কম্পোনেন্ট কে রেন্ডার করা হয়েছে, এবং একটা চেকবক্স রাখা হয়েছে যেখানে ক্লিক করলে isFancy এই স্টেট টার ভ্যালু চেঞ্জ হয়।এখন স্বাভাবিকভাবে মনে হতে পারে যখন চেকবক্স এ ক্লিক করা হবে তখন আগের কম্পোনেন্ট রিমুভ হয়ে নতুন কম্পোনেন্ট আসবে এবং তার স্টেট রিসেট হয়ে যাবে।কিন্তু না, তা হবেনা । কেননা কন্ডিশনালি প্রপ্স চেঞ্জ হলেও একই কাউন্টার কম্পোনেন্ট কিন্তু রেন্ডার ট্রি এর একই পজিশনে আছে। তাই তার স্টেট রিসেট হবেনা।\nআমরা যখন পজিশনের কথা বলছি,মনে রাখতে হবে এটা হলো রিয়াক্ট এর রেন্ডার ট্রি। এটা\nকিন্তু JSX ট্রি নয়। যতক্ষণ পর্যন্ত রিয়াক্ট এর রেন্ডার ট্রি-তে কোন পরিবর্তন\nনা হবে ততক্ষণ সে কম্পোনেন্টগুলোর স্টেট ধরে রাখবে, যদি কোন কম্পোনেন্ট রিয়াক্ট\nএর রেন্ডার ট্রি থেকে রিমুভ হয় বা কোনকারনে ওই পজিশনে অন্য কোন কম্পোনেন্ট বসে\nতাহলে সেই কম্পোনেন্টের স্টেট রিসেট হয়ে যাবে।","different-components-at-the-same-position-reset-state#Different components at the same position reset state":"একই পজিশনে যদি আগের রেন্ডারে যেই কম্পোনেন্ট ছিল, পরের রেন্ডারে সেই কম্পোনেন্ট না থাকে, বা পরের রেন্ডারে ওই পজিশনে অন্য কোন কম্পোনেন্ট বসে তাহলে রিয়াক্ট স্টেট রিসেট করে দেয়।\nimport { useState } from \"react\";\nexport default function App() {\n    const [isPaused, setIsPaused] = useState(false);\n    return (\n        <div>\n            {isPaused ? <p>See you later!</p> : <Counter />}\n            <label>\n                <input\n                    type='checkbox'\n                    checked={isPaused}\n                    onChange={(e) => {\n                        setIsPaused(e.target.checked);\n                    }}\n                />\n                Take a break\n            </label>\n        </div>\n    );\n}\nfunction Counter() {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>{score}</h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nএখানে খেয়াল করলে দেখবেন যে,\n    const [isPaused, setIsPaused] = useState(false);\n    return (\n        <div>\n            {isPaused ? <p>See you later!</p> : <Counter />}\n            <label>\n                <input\n                    type='checkbox'\n                    checked={isPaused}\n                    onChange={(e) => {\n                        setIsPaused(e.target.checked);\n                    }}\n                />\n                Take a break\n            </label>\n        </div>\nএখানে কন্ডিশনালি একই পজিশনে দুইটা কম্পোনেন্ট দেখানো হচ্ছে, যখন চেকবক্স এ ক্লিক করা হচ্ছে তখন কাউন্টার কম্পোনেন্ট এর পজিশনে একটা <p>...</p> ট্যাগ বসছে, যখনি <p>...</p> ট্যাগ বসছে,তখনি দ্বিতীয় রেন্ডারে রিয়াক্ট তার রেন্ডার ট্রি এর ওই পজিশনে আর কাউন্টারকে পাচ্চেনা,তাই কাউন্টার কম্পোনেন্ট রিমুভ হওয়ার সাথে সাথে তার স্টেট সহ রিসেট হয়ে যাচ্ছে। তাই পরেরবার আবার যখন চেকবক্স আনচেক করে কাউন্টার কম্পোনেন্ট আবার আনা হচ্ছে, তখন সে একটা ফ্রেশ কম্পোনেন্ট হিসেবে আসছে।সর্বশেষে মোট কথা হলো যদি একটা রেন্ডার থেকে পরবর্তি রেন্ডারে কম্পোনেন্টগুলোর স্টেট ধরে রাখতে হয়, তাহলে রেন্ডার ট্রি এর স্ট্রাকচার দুইটা রেন্ডারেই সেম থাকতে হবে।"}},"/reactive-accilarator/React-js/module-3/reseting-state-at-same-position":{"title":"Reseting State at Same Position","data":{"resetting-state-at-the-same-position#Resetting state at the same position":"আমরা জানি কোন কম্পনেন্ট একই পজিশনে যতক্ষণ থাকবে ততক্ষণ রিয়াক্ট তার স্টেট ধরে রাখবে।কিন্তু যদি আমাদের এমন প্রয়োজন হয় যে আমরা একই পজিশনে কম্পনেন্টের স্টেট রিসেট করবো। তাহলে দুইটা উপায়ে আমরা সেটা করতে পারিঃ\nRendering a component in different positions\nGive each component an explicit identity with key","rendering-a-component-in-different-positions#Rendering a component in different positions":"import { useState } from \"react\";\nexport default function Scoreboard() {\n    const [isPlayerA, setIsPlayerA] = useState(true);\n    return (\n        <div>\n            {isPlayerA ? (\n                <Counter person='Taylor' />\n            ) : (\n                <Counter person='Sarah' />\n            )}\n            <button\n                onClick={() => {\n                    setIsPlayerA(!isPlayerA);\n                }}>\n                Next player!\n            </button>\n        </div>\n    );\n}\nfunction Counter({ person }) {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>\n                {person}'s score: {score}\n            </h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nএখানে একটা কম্পোনেন্টে প্লেয়ারের স্কোর কাউন্ট করা হচ্ছে, আমরা যখন Add One বাটনে চাপ দিয়ে স্কোর বারাচ্ছি,তখন স্কোর এর স্টেট চেঞ্জ হচ্ছে, আবার আমরা নিচে একটা বাটন রেখেছি Next Player নামে, এবং আমরা চাইছি যে বাটনে চাপ দিলে প্লেয়ার এর নাম চেঞ্জ হবে এবং স্কোরটা রিসেট হয়ে যাবে। কিন্তু এখানে সেটা হচ্ছেনা, কারণ হলো এখানে একই পজিশনে কাউন্টার কম্পোনেন্ট তার পজিশনে ধরে রেখছে,তাই স্টেট রিসেট হচ্ছে।কিন্তু যদি আমরা কোডটা এভাবে লিখি,\n// প্রথম কোড যা স্টেট ধরে রাখবে\n{\n    isPlayerA ? <Counter person='Taylor' /> : <Counter person='Sarah' />;\n}\n{\n    isPlayerA && <Counter person='Taylor' />; // এখানে যদি isPlayerA না হয় তাহলে এই পজিশনে null রিটার্ন হবে\n}\n{\n    !isPlayerA && <Counter person='Sarah' />; // এখানে যদি isPlayerA হয় তাহলে এই পজিশনে null রিটার্ন হবে\n}\nএকানে রেন্ডার ট্রি-এর স্ট্রাকচার টা হয় এমনঃ তাহলে দেখা যাচ্ছে যে isPlayerA না হয় তাহলে নিচের কম্পোনেন্ট রেন্ডার হবে। এখানে কিন্তু দুইটা কম্পোনেন্ট দুইটা আলাদা পজিশনে আছে, কেননা একটা যদি true না হয় সেই পজিশনে কিন্তু একটা null রিটার্ন হয়, এবং অন্য কম্পোনেন্ট টা আলাদা একটা পজিশনে রেন্ডার হয়।","resetting-state-with-a-key#Resetting state with a key":"আরেকটা সবচাইতে এফিসিয়েন্ট উপায় হলো key প্রপ্স ব্যাবহার করা, আমরা লিস্ট রেন্ডার করার সময় keyপ্রপ্স এর সাথে পরিচিত হয়েছিলাম,key প্রপ্স শুধুমাত্র লিস্ট রেন্ডারিং এর জন্য ব্যবহার হয়না। key প্রপ্স এর মানে হলো সেই কম্পোনেন্টকে রিয়াক্টের কাছে একটা আলাদা কম্পোনেন্ট হিসেবে রিপ্রেজেন্ট করা।তাই আমরা যদি আগের মতো করেই কোড করি এবং শুধু স্টেটগুলো রিসেট করতে চাই তাহলে আমরা এভাবে key প্রপ্স ব্যাবহার করতে পারি।\n{\n    isPlayerA ? (\n        <Counter\n            key='Taylor'\n            person='Taylor'\n        />\n    ) : (\n        <Counter\n            key='Sarah'\n            person='Sarah'\n        />\n    );\n}\nএখানে key প্রপ্স এর মানে হলো একই পজিশনে দুইটা সম্পুর্ন আলাদা কম্পোনেন্ট ।"}},"/reactive-accilarator/React-js/module-3/thinking-about-ui":{"title":"Thinking about UI","data":{"ইউ-আই-কে-ডিক্লারেটিভলি-ভাবা-thinking-about-ui-declaratively#ইউ আই-কে ডিক্লারেটিভলি ভাবা (Thinking about UI declaratively)":"আমরা যখনি রিয়াক্টের কোন UI কে পরিবর্তন বা ম্যানেজ করতে চাইবো তখন আমাদের স্টেট দিয়ে তা ম্যানেজ করা লাগবে । একটা কম্পোনেন্টে কি কি স্টেট থাকতে পারে বা কিভাবে খুব সুন্দর করে স্টেটগুলো ম্যনেজ করতে হবে তা খুব ভালোভাবে বুঝতে হলে আমাদের কয়েকটা স্টেপ অবশ্যই ফলো করতে হবে। নিচে এই স্টেপগুলো নিয়ে বিস্তারিত আলোচনা করবো। এই স্টেপগুলো খুব ভালোভাবে বুঝতে পারলে যেকোন কমপ্লেক্স UI এর স্টেট ম্যানেজমেন্ট খুব সহজেই করে ফেলা সম্ভব। চলুন স্টেপগুলো জানি,\nIdentify Components differnet visual states\nDetermine What trigger those state changes\nRepresent the state in memory useing useState\nRemove any not-essential state variables\nConnent the event handlers to set the state","identify-components-differnet-visual-states-কম্পোনেন্টের-কি-কি-পরিবর্তন-বা-অবস্থা-হতে-পারেতা-নির্ধারণ-করা#Identify Components differnet visual states (কম্পোনেন্টের কি কি পরিবর্তন বা অবস্থা হতে পারে,তা নির্ধারণ করা)":"প্রথমেই আমাদের বুঝতে হবে যে আমাদের UI তে কি কি পরিবর্তন হতে পারে। মানে UI টা কি কি অবস্থায় স্ক্রিনে দেখা যাবে।উদাহরণ হিসেবে, ধরুন আমারা একটা ফর্ম এর কথা ভাবি, ফরমটা একটা প্রশ্নের উত্তর নেয়, এবং উত্তর সঠিক হলে সাকসেস মেসেজ দেখায় আর ভুল হলে ইরর মেসেজ দেখায়। আর ফর্ম টায় কোন কিছু না লিখা হলে ফর্মটা ডিসেবল থাকে, আর কিছু লিখে ফর্মটা সাবমিট করা হলে একটা লোডীং দেখায়।তাহলে চলুন একটু ভিজুয়ালাইজ করি আমাদের এর কম্পোনেন্টের কি কি ভিজুয়াল স্টেট হতে পারে:১।  ২।  ৩। ৪।  ৫। তাহলে এখানে আমরা UI তে পাচটি স্টেট দেখতে পাচ্ছি,empty, typing, submitting, success, error এতে আমরা ক্লিয়ার ধারনা পাই যা আমাদের UI তে কি কি পরিবর্তন হবে আর কখন কোন স্টেট এ থাকবে। এই ভাবে একটা কম্পোনেন্টের প্রতিটা ভিজুয়াল চেঞ্জকে রিপ্রেজেন্ট করা কে স্টোরিবুকস বলা হয়","determine-what-triggers-those-state-changes-কোন-কোন-কারনে-স্টেট-এর-পরিবর্তনগুলো-ট্রিগার-হবে-তা-নির্ধারন-করা#Determine what triggers those state changes (কোন কোন কারনে স্টেট এর পরিবর্তনগুলো ট্রিগার হবে তা নির্ধারন করা)":"UI তে যেই স্টেট এর পরিবর্তনগুলো হবে,সেগুলো কিভাবে ট্রিগার হবে তা নির্ধারন করতে হবে। স্টেট এর পরিবর্তনগুলো কি ইউজারেরে কোন ইন্টারেকশনের কারনে হবে নাকি কম্পিউটার অটোমেটিক করবে তা নির্ধারন করতে হবে।এক্ষেত্রে যেমন ইউজার ইনপুট ফিল্ডে কিছু লিখলে স্টেট হবে টাইপিং,আর সাবমিট করলে হবে সাবমিটিং।আর ইরর হবে নাকি সাকসেস হবে সেটা কম্পিউটার নিজে ডিসিশন নিবে।অর্থাৎ দ্বিতীয় স্টেপে আমাদের বুঝতে হবে যে, কখন কিভাবে স্টেট চেঞ্জ গুলো ট্রিগার হবে।এই স্টেট চেঞ্জের স্টেপগুলোকে আমরা একটা ডায়াগ্রামে রিপ্রেজেন্ট করতে পারলে পুরো স্টেট চেঞ্জের ফ্লো-টা বোঝা অনেক সহজ হয়ে যায়। যেমনঃ","represent-the-state-in-memory-with-usestate-usestateব্যবহার-করে-স্টেটগুলো-কে-রিপ্রেজেন্ট-করা#Represent the state in memory with useState (useStateব্যবহার করে স্টেটগুলো কে রিপ্রেজেন্ট করা)":"এই স্টেপে আমাদের যেসব স্টেটগুলো প্রয়োজন হবে সেগুলো কে useState হুক দিয়ে ইনিশিয়ালিজ করতে হবে বা ডিফাইন করতে হবে। এই উদাহরণে স্বাভাবিকভাবে দেখলে আমাদের পাঁচটা স্টেট লাগবে,\nconst [isEmpty, setIsEmpty] = useState(true);\nconst [isTyping, setIsTyping] = useState(false);\nconst [isSubmitting, setIsSubmitting] = useState(false);\nconst [isSuccess, setIsSuccess] = useState(false);\nconst [isError, setIsError] = useState(false);\nএছাড়াও আমাদেরকে ফর্মের ইনপুট হ্যান্ডেল করা আর ইরর হয়েছে কিনা তা বুঝার জন্য আরও দুইটা স্টেট অবশ্যই নেয়া লাগতে পারে।\nconst [answer, setAnswer] = useState(\"\");\nconst [error, setError] = useState(null);","remove-any-non-essential-state-variablesঅপ্রয়োজনীয়-স্টেট-ভ্যারিয়েবল-রিমুভ-করে-দেয়া#Remove any non-essential state variables(অপ্রয়োজনীয় স্টেট ভ্যারিয়েবল রিমুভ করে দেয়া)":"এই পর্যায়ে আমাদের বুঝতে হবে যে আমরা যেই state গুলো ডিফাইন করেছি তার প্রত্যেকটাই কি আমাদের লাগবে কিনা, কোন একটা স্টেট ভ্যারিয়েবল দিয়ে অন্যটার কাজ হয়ে যাচ্ছে কিনা বা কোন স্টেট ডুপ্লিকেট হচ্ছে কিনা এবং একই সময়ে দুইটা স্টেট কখনো সত্যি অথবা মিথ্যা (Paradox) হতে পারেনা এমন ক্ষেত্রে একই স্টেট নেয়াঅর্থাৎ এই পর্যায়ে আমাদের স্টেটকে ক্লিনাপ করা লাগবে, অপ্রয়োজনীয় স্টেট ভ্যরিয়েবলগুলোকে রিমুভ করে দিতে হবে।এক্ষেত্রে যেমন আমরা empty আর typing দুইটা ইনফরমেশনএর স্টেট দুইটা বাদ দিয়ে শুধুমাত্র answer স্টেট থেকেই সবকিছু ম্যনেজ করতে পারি। যেমন answer.length == 0 মানে হলো empty আর 0 না হলে typing তাহলে আমরা খুব সহজেই empty আর typing এই দুইটা স্টেট রিমুভ করে দিতে পারি।আবার বাকি তিনটা অবস্থা submitting successঅথবা error আমরা শুধু একটা স্টেট ভ্যারিয়েবল status নিয়েই আমরা মেনেজ করতে পারি।\nconst [status, setStatus] = useState(\"typing\"); // 'submitting', or 'success / error'\nতাহলে এখানে আমাদের শুধু তিনটা স্টেট নিলেই সমস্ত কিছু পারফেক্টলি হয়ে যাচ্ছে,\nconst [answer, setAnswer] = useState(\"\");\nconst [error, setError] = useState(null);\nconst [status, setStatus] = useState(\"typing\"); // 'submitting', or 'success / error'","connect-the-event-handlers-to-set-stateস্টেটগুলো-চেঞ্জ-করার-জন্য-ইভেন্ট-হ্যন্ডেলারগুলো-কানেক্ট-করিয়ে-দিতে-হবে#Connect the event handlers to set state(স্টেটগুলো চেঞ্জ করার জন্য ইভেন্ট হ্যন্ডেলারগুলো কানেক্ট করিয়ে দিতে হবে)":"এই পর্যায়ে আমাদের শুধু স্টেট এর সেটার ফাংশনগুলোকে ইভেন্ট হ্যান্ডেলারের সাথে কানেক্ট করিয়ে দিতে হবে, যাতে ইভেন্ট ট্রিগার হলেই স্টেটগুলো আপডেট হতে থাকে।"}},"/reactive-accilarator/React-js/module-4/effect-react-to-reactive-values":{"title":"Effect React to Reactive Values","data":{"effects-react-to-reactive-values-রিয়াক্টিভ-ভ্যালুগুলোতে-ইফেক্ট-রিয়াক্ট-করে#Effects \"react\" to reactive values (রিয়াক্টিভ ভ্যালুগুলোতে ইফেক্ট রিয়াক্ট করে)":"const serverUrl = \"https://localhost:1234\";\nfunction ChatRoom({ roomId }) {\n    useEffect(() => {\n        const connection = createConnection(serverUrl, roomId);\n        connection.connect();\n        return () => {\n            connection.disconnect();\n        };\n    }, [roomId]);\n    // ...\n}\nউপরের উদাহরণ অনুযায়ী ইফেক্টে দুইটা ভ্যারিয়েবল ব্যাবহার করা হয়েছে, কিন্তু ইফেক্টের ডিপেন্ডেন্সি হিসেবে ব্যাবহার করা হয়েছে একটা ভ্যারিয়েবল roomId, এটা কেন? কেন serverUrl ইফেক্টের ডিপেন্ডেন্সিতে ব্যাবহার করা হলোনা ?এর কারণ হলো serverUrl হলো একটা স্ট্যাটিক ভ্যালু এবং এটা কম্পোনেন্টের বাহিরে ডিক্লেয়ার করা হয়েছে, তাই এটা কখনই কোন রি-রেন্ডারে চেঞ্জ হবেনা। যেই ভ্যারিয়েবলগুলো কম্পোনেন্টের বাহিরে ডিক্লেয়ার করা হয় এবং যেগুলো কখনো চেঞ্জ হওয়ার সম্ভাবনা নেই,সেগুলো রিয়াক্টিভ ভ্যালু না। আর ইফেক্টের ডিপেন্ডেন্সিতে শুধুমাত্র রিয়াক্টিভ ভ্যালুগুলোই ব্যাবহার করতে হয়।অন্যদিকে roomId ভ্যারিয়েবলটা প্রপে এসেছে, প্রপ,স্টেট এগুলা রি-রেন্ডারে চেঞ্জ হতে পারে,তাই এগুলো রিয়াক্টিভ ভ্যালু কেননা এগুলা রিয়াক্টের কম্পোনেন্ট এর ভিতরে ডিক্লেয়ার করা হয়েছে তাই এগুলো রেন্ডারিং এ কেলকুলেট হবে, আর তাই এসব ভ্যালু রিয়াক্টিভ।যদি serverUrl ভ্যারিয়েবলটা প্রপ হিসেবে আসতো, তাহলে এটাও রিয়াক্টিভ ভ্যালু হতো। রিয়াক্টিভ ভ্যালু যেগুলো ইফেক্টের মধ্যে ব্যাবহার করা হয়েছে,সেগুলো অবশ্যই ইফেক্টের ডিপেন্ডেন্সিতে এড করা লাগবে।","what-an-effect-with-empty-dependencies-means-ইফেক্টের-ইম্পটি-ডিপেন্ডেন্সি-মানে-কি#What an Effect with empty dependencies means (ইফেক্টের ইম্পটি ডিপেন্ডেন্সি মানে কি?)":"const serverUrl = \"https://localhost:1234\";\nconst roomId = \"general\";\nfunction ChatRoom() {\n    useEffect(() => {\n        const connection = createConnection(serverUrl, roomId);\n        connection.connect();\n        return () => {\n            connection.disconnect();\n        };\n    }, []); // ✅ All dependencies declared\n    // ...\n}\nযদি এমন হয় যে আমদের ইফেক্ট শুধুমাত্র একবার রান করবে একবার চ্যাট রুমের সাথে কানেক্ট হবে যখন কম্পোনেন্ট মাউন্ট হবে, পরে আর কখনোই ইফেক্ট রান করার প্রয়োজন নেই, এবং শুধুমাত্র কম্পোনেন্ট আনমাউন্ট হলে কানেকশন স্টপ হবে, তাহলে আমরা ডিপেন্ডেন্সি ভ্যারিয়েবল গুলো কপোনেন্টের বাহিরে নিয়ে স্ট্যাটিক ভ্যালু হিসেবে রাখতে পারি। এবং এতে যেহেতু কোন রিয়াক্টিভ ভ্যালু ইফেক্টের ভিতরে ব্যাবহার করা হয়নি,তাই এখানে ডিপেন্ডেন্সি ইম্পটি থাকতে পারে।আসলে আমাদের কম্পোনেন্টের মাউন্ট -আনমাউন্ট নিয়ে চিন্তা করার কোন দরকার এ নেই, আমরা শুধুমাত্র এফেক্টের স্টার্ট আর স্টপ লিখবো ইফেক্টের ভিতরে, বাকিটা রিয়াক্ট নিজে বুঝে নিবে। যদি কোন ডিপেন্ডেন্সি দেয়ার প্রয়োজন হয়,সেটা আমদের eslint সাজেশন দিবে।","all-variables-declared-in-the-component-body-are-reactive-কম্পোনেন্টের-ভিতরে-যে-সকল-ভ্যারিয়েবল-ডিক্লেয়ার-করা-হয়তা-সব-রিয়াক্টিভ-ভ্যালু#All variables declared in the component body are reactive (কম্পোনেন্টের ভিতরে যে সকল ভ্যারিয়েবল ডিক্লেয়ার করা হয়,তা সব রিয়াক্টিভ ভ্যালু)":"শুধুমাত্র প্রপ আর স্টেট ই রিয়াক্টিভ ভ্যালু নয়, আমাদের কম্পোনেন্টের ভিতরে ডিক্লেয়ার করা ভ্যারিয়েবলগুলোও রিয়াক্টিভ, কেননা যদি এমন হয় যে আমাদের কম্পোনেন্টের ভিতরে কোন ভ্যালু আমরা কনটেক্সট থেকে রিড করেছি এবং তা কম্পোনেন্টের ভিতরে ডিক্লেয়ার করেছি,সেটাও রিয়াক্টিভ ভ্যালু হতে হবে। আমরা কম্পোনেন্টের ভিতরে শুধু সেই ভ্যারিয়েবল ই রাখবো যেগুলো কম্পোনেন্টের রেন্ডারিং এর সাথে সম্পর্কযুক্ত। এমন কোন ভ্যারিয়েবল যা আমাদের কম্পোনেন্টের রেন্ডারিং সাথে সম্পর্ক নেই, এবং া কখনো পরিবর্তন হউয়ার সম্ভাবনা নেই, সেগুলো আমরা সবসময় কম্পোনেন্ট এর বাইরে ডিক্লেয়ার করবো।","react-verifies-that-you-specified-every-reactive-value-as-a-dependency-রিয়াক্ট-ভেরিফাই-করা-যে-প্রতিটা-রিয়াক্টিভ-ভ্যালু-ইফেক্টের-ডিপেন্ডেন্সিতে-এড-করা-হয়েছে#React verifies that you specified every reactive value as a dependency (রিয়াক্ট ভেরিফাই করা যে প্রতিটা রিয়াক্টিভ ভ্যালু ইফেক্টের ডিপেন্ডেন্সিতে এড করা হয়েছে।)":"আমরা প্রজেক্ট সেটআপ করার সময় রিয়াক্টের জন্য যেই linter টা সেটআপ করি,সে সবসময় আমাদের ওয়ার্ন করে যাতে সকল রিয়াক্টিভ ভ্যালু যা ইফেক্টের ভিতরে ব্যাবহার করা হয়েছে সেগুলো যাতে ইফেন্টের ডিপেন্ডেন্সিতে এড করা হয়।যদি কোন রিয়াক্টিভ ভ্যালু আমরা ইফেক্টের ভিতরে ব্যাবহার করি কিন্তু ডিপেন্ডেন্সিতে এড না করি, তাহলে linter আমাদের ওয়ার্নিং দিবে, আমরা কখনোই সেই ওয়ার্নিং টাকে সাপ্রেস করবোনা, বরং যেসব ভ্যালু ডিপেন্ডেন্সিতে এড করার জন্য linter সাজেস্ট করবে সেগুলো আমরা ডিপেন্ডেন্সিতে এড করে নিবো।আর যদি আমরা চাই যে, আমাদের কম্পোনেন্ট re-Syncronize না করুক,তাহলে আমরা রিয়াক্টিভ ভ্যালুগুলো কম্পোনেন্ট এর বাহিরে স্ট্যাটিক ভ্যালু হসেবে রাখতে পারি,যেগুলো কখনই চেঞ্জ হবেনা, এবং ইফেক্ট re-Syncronize হবেনা।"}},"/reactive-accilarator/React-js/module-4/flushing-state-updates-synchronously":{"title":"Flushing State Updates Synchronously","data":{"":"এটা আরেকটা escap hatch। আমরা জানি যে রিয়াক্ট তার State গুলুকে ব্যাচ করে আপডেট করে এবং পরের রেন্ডারে গিয়ে আপডেটেড ভ্যালু পাওয়া যায়।কিন্তু আমরা যদি চাই যে স্টেট আপডেডকে আমরা Syncronously করবো এবং স্টেট আপডেট হয়ে যাওয়ার পর নিচের লাইন এক্সিকিউট হবে তাহলে আমরা flushSync ব্যাবহার করতে পারি। এটি react-dom একটি মেথড। এটা স্টেট আপডেট না হওয়া পর্যন্ত নিচের লাইনের এক্সিকিউশন বন্ধ রাখে এবং রিয়াক্টকে জানায় যে আগে স্টেট আপডেট করো তারপর নিচের লাইনগুলো এক্সিকিউট করো।তাহলে আমরা যেই স্টেট আপডেটকে ফোর্স করে আগে স্টেট আপডেট করে তারপর নিচের লাইনে যেতে বলছি সেই স্টেট আপডেটের setter function  কে flushSync মেথড দিয়ে তার একটা কলব্যাক এ দিয়ে দিতে হবে।\nimport { flushSync } from \"react-dom\";\nflushSync(() => {\n    setTodos([...todos, newTodo]);\n});"}},"/reactive-accilarator/React-js/module-4/fatching-data":{"title":"Fatching Data","data":{"fetching-data-with-effects#Fetching data with effects":"যখন আমরা রিয়াক্টে ইফেক্টের মাধ্যমে কোন ডাটা fetch করবো তখন অবশ্যই আমাদেরকে ইফেক্টের ক্লিন-আপ ফাংশন ইমপ্লিমেন্ট করতে হবে এবং ডেভেলপমেন্ড মুডে আমরা যখনি ডাটা fetch করে স্টেট এ সেট করবো তখন যাতে দুইবার সেট না হয় সেজন্য ইফেক্টের ক্লিন-আপে প্রথমবার setState কে ইগনোর করতে হবে।\nconst [data, setData] = useState([]);\nuseEffect(() => {\n    let ignore = false;\n    async function startFatching() {\n        const fetched = await fetch(`apiurl/${id}`);\n        const json = await fetched.json();\n        if (!ignore) {\n            setData(json);\n        }\n    }\n    startFatching();\n    return () => {\n        ignore = true;\n    };\n}, [id]);\nদেখেন এখানে আমরা ৩ নাম্বার লাইনে একটা ভ্যারিয়েবল রেখেছি ignore নামে এবং ৯-১১ নাম্বার লাইনে আমরা স্টেট আপডেট করার আগে চেক করেছি যে ignore এর ভ্যালু true কিনা, যদি true না হয়,সেখেত্রে আমরা স্টেট আপডেট করেছি।এখন চলুন এই প্যাটার্নটা আরেকটু ভালো করে বুঝি,আমরা জানি ডেভেলপমেন্ট মুডে প্রতিটা কম্পোনেন্ট দুইবার করে রান হয়, মানে হলো mount --> unmount --> remount.তাই প্রথমবার যখন আমাদের কম্পোনেন্ট মাউন্ট হয়েছে তখন আমাদের ইফেক্ট রান হয়েছে এবং সেখানে ignore এর ভ্যালু false পেয়েছে, এবং তারের পরের লাইনেই আমাদের ডাটা fatching এর জন্য একটা asynchronous ফাংশন startFatching() কল হয়েছে, asynchronous ফাংশনটার ক্লোজারের মধ্যে ignore ভ্যারিয়েবল এর ভ্যালু false নিয়ে Web API এর মধ্যে তার ডাটা fatching এর কাজ করছে।এর পরে আমাদের এফেক্টের আর কোন কাজ নাই, তাই সে দ্বিতীয়বার রান হউয়ার জন্য কম্পোনেন্টকে unmount করতে যাবে এমন সময় দেখে একটা ক্লিন-আপ ফাংশন লেখা হয়েছে ইফেক্টের মধ্যে, তাই সে ক্লিন-আপ ফাংশনটা রান করবে, এবং ক্লিন-আপের মধ্যে ignore ভ্যারিয়েবল এর ভ্যালু true করে দেয়া হয়েছে,এই সময়ের মধ্যে যখন startFatching() ফাংশনটা তার কাজ শেষ করে ফিরে আসবে এবং স্টেট-আপডেট করতে যাবে তখন সে দেখবে তার ক্লোজারের মধ্যে থাকা ignore ভ্যারিয়েবল এর ভ্যালু true হয়ে গিয়েছে। তখন সে আর কোন কাজ করবেনা।এরই মধ্যে যখন কম্পোনেন্ট remount হবে তখন আবার পুরো কম্পোনেন্ট নতুন করে রান হবে, এবং তখন ignore ভ্যারিয়েবল এর ভ্যালু false পাবে, আর startFatching() ফাংশনটা কল হবে, এবারে কিন্তু কম্পোনেট আর unmount হবেনা, তাই ক্লিন-আপ ফাংশনও কল হবেনা আর ignore ভ্যারিয়েবল এর ভ্যালুও চেঞ্জ হবেনা। তখন startFatching() ফাংশনটা তার কাজ শেষ করে যখন ডাটা নিয়ে ফিরত আসবে তখনও সে ignore ভ্যারিয়েবল এর ভ্যালু false পাবে, আর তাই স্টেট আপডেট করে দিবে।এই প্যাটার্নে করলে আমাদের ডেভেলপমেন্ট মুড এবং প্রোডাকশন মুড দুইটাতে সেফ। দুইবার আমাদের স্টেট আপডেট হবেনা।যদিও ইফেক্টের মাধ্যমে এভাবে ডাটা ফেচ করাটা বেস্ট এপ্রোচ না, আমরা রিয়াক্ট এপ্লিকেশনে ডাটা ফেচিং এর জন্য React Query, useSWR, rtkQuery ইত্যাদি চাইলে ব্যবাহার করতে পারি। অথবা আমরা যদি কোন ফ্রেমওয়ার্ক ব্যবাহার করি তাহলে সেখানে বিল্ট-ইন ডাটা ফেচিং মেকানিজম পেয়ে যাবো।"}},"/reactive-accilarator/React-js/module-4/forwarding-refs":{"title":"Forwarding Refs","data":{"accessing-another-components-dom-nodes#Accessing another component’s DOM nodes":"সাধারণত আমরা যখন কোন HTML ELEMENTকে ref দিয়ে ধরতে চাই, আমরা সেটা করতে পারি, এবং আমরা ref.currentএর মধ্যে তার ভ্যালুটা পাই। কিন্তু আমরা যদি আমদের কোন কাস্টম কম্পোনেন্ট (eg: <MyInput/>) কে সরাসরি ধরতে চাই, তখন আমরা সেটা পারবোনা। এবং তখন যদি আমরা কনসলে ref এর current ভ্যালু দেখি আমরা তাতে null পাবো।চলুন একটা উদাহরণের মাধ্যমে এই প্রব্লেমটা বুঝা যাক,\nimport { useRef } from \"react\";\nfunction MyInput(props) {\n    return <input {...props} />;\n}\nexport default function MyForm() {\n    const inputRef = useRef(null);\n    function handleClick() {\n        inputRef.current.focus();\n    }\n    return (\n        <>\n            <MyInput ref={inputRef} />\n            <button onClick={handleClick}>Focus the input</button>\n        </>\n    );\n}\nএখানে আমাদের দুইটা কম্পোনেন্ট আছে যার একটি হলো <MyInput/> যাতে শুধুমাত্র একটি ইনপুট ট্যাগ আছে, আরেকটি হলো প্যারেন্ট কম্পোনেন্ট , এখানে একটি বাটন আছে এবং আমরা চাইছি এই বাটনে onClickএ আমরা আমাদের যেই কাস্টম কম্পোনেন্ট <MyInput/> এর ভিতরের ইনপুট ট্যাগ এ ফোকাস করবো। কিন্তু আমরা যদি এখন আউটপুট দেখি এবং বাটনে ক্লিক করি তাহলে দেখবো যে ইনপুট ট্যাগটা ফোকাস হচ্ছেনা।তার কারণ হলো রিয়াক্ট বাই ডিফল্ট কোন কম্পোনেন্ট এর রেফারেন্স অন্য কম্পোনেন্টে শেয়ার করেনা এমনকি সেটা সেই কম্পোনেন্টের নিজের চাইল্ড কম্পোনেন্ট হলেও না।কিন্তু আমরা যদি এই বিহেবিয়ারটাকে চেঞ্জ করতে চাই এবং সত্যিই চাই যে আমরা আমাদের কাস্টম কম্পোনেন্টের কোন Node কে আমরা বাহিরের কোন কম্পোনেন্টে এক্সেস দিবো তাহলে আমদেরকে সেই কাস্টম কম্পোনেন্টস থেকে রেফারেন্স টাকে ফরওয়ার্ড করে দিতে হবে React এর forwardRef API ব্যাবহার করে।সেজন্য আমাদের কে দুইটা স্টেপ ফলো করতে হবে।","প্যারেন্ট-কম্পোনেন্ট-থেকে-ref-কে-প্রপ্স-এর-মতো-করে-পাস-করতে-হবে-#প্যারেন্ট কম্পোনেন্ট থেকে ref কে প্রপ্স এর মতো করে পাস করতে হবে ।":"import { useRef } from \"react\";\n    \n    export default function MyForm() {\n        const inputRef = useRef(null);\n    \n        function handleClick() {\n            inputRef.current.focus();\n        }\n    \n        return (\n            <>\n                <MyInput ref={inputRef} />\n                <button onClick={handleClick}>Focus the input</button>\n            </>\n        );\n    \n    }","চাইল্ড-কম্পোনেন্ট-থেকে-কম্পোনেন্টটাকে-forwardref-এটা-একটা-higer-order-function-ব্যাবহার-করে-ref-সহ-কম্পোনেন্ট-কে-ফরওয়ার্ড-করে-দিতে-হবে#চাইল্ড কম্পোনেন্ট থেকে কম্পোনেন্টটাকে forwardRef (এটা একটা Higer Order Function) ব্যাবহার করে ref সহ কম্পোনেন্ট কে ফরওয়ার্ড করে দিতে হবে।":"এক্ষেত্রে আমরা আমাদের পুরো কম্পোনেন্ট টাকে forwardRef দিয়ে wrap করে দিতে হবে এবং প্যারেন্ট কম্পোনেন্ট থেকে পাস করা ref আমরা কম্পোনেন্টের সেকেন্ড প্যারামিটারে ধরতে পারি এবং সেটা কম্পোনেন্টের যেই নোডের এক্সেস চাই সেটাতে সেট করতে হবে।\n    import { forwordRef } from \"react\";\n    const MyInput = forwardRef((props,ref)=> { return <input {...props} ref={ref} />});\n    export default MyInput;\nএবার যদি আমরা আউটপুট দেখি এবং বাটনে ক্লিক করি, আমরা দেখবো এটা কাজ করছে। স্বাভাবিক ভাবে কম্পোনেন্ট গুলো তাদের Node এর রেফারেন্স বাইরে শেয়ার করেনা কারণ এতে কম্পোনেন্ট আন-এক্সপেক্টেড আচরণ করতে পারে, তাই এটাই ডিফল্ট বিহেবিয়ার, আমরা এটাকে পরিবর্তন করতে চাইলে উপরের স্টেপগুলো ফলো করে করতে পারি।"}},"/reactive-accilarator/React-js/module-4/handling-effects-firing-twice":{"title":"Handling Effects Firing Twice","data":{"how-to-handle-the-effect-firing-twice-in-development#How to handle the Effect firing twice in development?":"রিয়াক্ট ইন্টেনশনালি প্রতিটা কম্পোনেন্টকে দুইবার করে রান করে যাতে আমরা সহজেই বুঝতে পারি যে কোডে কোন বাগ রয়েছে কিনা, তাই ডেভেলপমেন্ট মুডে আমরা যখনি দেখবো যে আমাদের কম্পোনেন্ট দুইবার করে রান হয়েছে তখন আমরা এটা ভাববোনা যে, কিভাবে আমাদের কম্পোনেন্ট একবার রান করবো বরং এটা ভাববো যে কিভাবে আমাদের ইফেক্টগুলোকে ঠিক ভাবে করতে পারি যাতে আমাদের কম্পোনেন্ট দুইবার মাউন্ট হলেও যেন ইফেক্ট ঠিকভাবে কাজ করে?সাধারণভাবেই এটার উত্তর হলো, ইফেক্টের ক্লিন-আপ ফাংশনের ইমপ্লিমেন্ট করা। আমরা যদি সঠিকভাবে ক্লিন-আপ ফাংশন ইমপ্লিমেন্ট করতে পারি, তাহলে আমদের কম্পোনেন্ট দুইবার করে মাউন্ট হলেও সঠিকভাবে কাজ করবে।","dont-use-refs-to-prevent-effects-from-firing#Don’t use refs to prevent Effects from firing":"একটা সাধারণ ভুল যেটা অনেকেই করে তা হলো ref এর মাধ্যমে ইফেক্টকে দুইবার করে রান হওয়া বন্ধ করে।\nconst connectionRef = useRef(null);\nuseEffect(() => {\n    // ❌ This wont fix the bug!!!\n    if (!connectionRef.current) {\n        connectionRef.current = createConnection();\n        connectionRef.current.connect();\n    }\n}, []);\nএটা করলে হয়তো ডেভেলপমেন্ট মোডে আপনি দেখতে পারেন যে আপনার কানেকশন একবার হয়ছে,কিন্তু এতে কিন্তু বাগ ফিক্স হয়না। যখন ইউজার নেভিগেট করে অন্য পেজে চলে যাবে এবং ফিরে আসলে আবার নতুন করে কানেকশন হবে, কিন্তু পুর্বের কানেকশন কিন্তু ক্লোজ করা হয়নি। তাই এটা মেমরি লিক করবে।তাই এটা ফিক্স করার জন্য অবশ্যই ক্লিন-আপ ফাংশন ইমপ্লিমেন্ট করা লাগবে।নিচে আমরা কয়েকটা কমন প্যাটার্নের উদাহরণ দেখবো যাতে আমরা বুঝতে পারি যে কখন আমাদের ক্লিন-আপ ফাংশন লেখা লাগবে আর কখন লাগবেনা।","controlling-non-react-widgets#Controlling non-React widgets":"যখন আমরা কোন UI এলিমেন্ট এড করবো যা আমাদের রিয়াক্টে লেখা নয়, উদাহরণ স্বরূপ যদি আমরা একটা ইমেজ এড করি এবং তার একটা জুমলেভেল সেট করে দেই ইফেক্ট দিয়ে তাহলে আমাদের ক্লিন-আপ ফাংশনের কোন দরকার নেই, কেননা কম্পোনেন্ট যতবার মাউণ্ট হউক না কেন, একই কপোনেন্টে বার বার একই ভ্যালু পাবে। তাই এখানে ক্লিন-আপের কোন দরকার নেই।\nuseEffect(() => {\n    const map = mapRef.current;\n    map.setZoomLevel(zoomLevel);\n}, [zoomLevel]);\nআবার কিছু কিছু API আছে যেগুলা একসাথে দুইবার রান হলে ইরর দেয়, যেমন HTML এর dialog ট্যাগ এর একটা বিল্ট-ইন মেথড আছে showModal নামে। এখানে যদি দুইবার showModal কল হয় তাহলে ইরর দিতে পারে, তাই এখানে ক্লিন-আপ করতে হবে।\nuseEffect(() => {\n    const dialog = dialogRef.current;\n    dialog.showModal();\n    return () => dialog.close();\n}, []);","subscribing-to-events#Subscribing to events":"যখনি আমরা ইফেক্টের ভিতরে কোন ইভেন্ট লিসেনার এড করবো সেটা অবশ্যই আমদের ক্লিন-আপ করা লাগবে।\nuseEffect(() => {\n    function handleScroll(e) {\n        console.log(window.scrollX, window.scrollY);\n    }\n    window.addEventListener(\"scroll\", handleScroll);\n    return () => window.removeEventListener(\"scroll\", handleScroll);\n}, []);","triggering-animations#Triggering animations":"যখন আমরা ইফেক্টের ভিতরে কোন কম্পোনেন্টে এনিমেশন এড করবো তখন অবশ্যই ক্লিন-আপ এড করা লাগবে, যাতে কম্পোনেন্ট আনমাউন্ট হলে এনিমেশন ও রিসেট হয়, নাহলে এটা ইউজারের এক্সপেরিয়ন্স কে নষ্ট করতে পারে।\nuseEffect(() => {\n    const node = ref.current;\n    node.style.opacity = 1; // Trigger the animation\n    return () => {\n        node.style.opacity = 0; // Reset to the initial value\n    };\n}, []);"}},"/reactive-accilarator/React-js/module-4/manipulating-dom-with-refs":{"title":"Manipulating Dom with Refs","data":{"":"রিয়াক্ট অটোমেটিক ভাবে DOM কে আপডেট করতে থাকে, তাই আমদের ম্যনুয়ালি DOM কে মডিফাই করা দরকার হয়না, কিন্তু আমাদের এমন এমন কিছু ইউজকেস আসতে পারে যখন আমদের বাধ্য হয়ে DOM মেনিপুলেট করা লাগে, যেমনঃ কোন এলিমেন্টে ফোকাস করা, স্ক্রল করে কোন এলিমেন্টের পজিশনে যাওয়া অথবা সাইজ পরিমাপ করা। রেয়াক্টে এসব করার জন্য কোন বিল্ট-ইন মেথড নেই, তাই এসব করার জন্য আমরা useRef ব্যবহার করে সরাসরি DOM মডিফাই করতে পারি।চলুন দেখে নেই কিভাবে আমরা useRef ব্যবহার করে DOM মেনিপুলেট করতে পারি,","import-useref-from-react#Import useref from react":"সর্বপ্রথম আমদেরকে রিয়াক্ট থেকে useRefকে ইম্পোর্ট করতে হবে।\nimport { useState } from \"react\";","declare-a-ref-inside-your-component#declare a ref inside your component:":"কম্পোনেন্টের ভিতর ref কে ডিক্লেয়ার করে ইনিশিয়াল করতে হবে।\nconst myRef = useRef(null);","pass-your-ref-as-the-ref-attribute-to-the-jsx-tag#pass your ref as the ref attribute to the JSX tag":"এবারে আমরা যেই DOM node কে মেনিপুলেট করতে চাই সেই JSX ট্যাগ এ Attraibute এর মতো করে ref কে ব্যবহার করবো।\n<div ref={myRef}></div>\n<button onClick={handleChangeText}>Change Text</button>","modify-the-dom-node-in-event-handler#modify the dom node in event handler":"এবারে আমদের ওই DOM NODE যেসব মেনিপুলেশন করা দরকার তা করতে পারবো event handler এর মধ্যমে।\nfunction handleChangeText() {\n    myRef.innerText = \"This is a text passed by the ref\";\n}"}},"/reactive-accilarator/React-js/module-4/performance-optimization":{"title":"Performance Optimization","data":{"performance-optimization#Performance Optimization":"এই লেসনে আমরা রিয়াক্টের দুইটা গুরুত্বপূর্ন পার্ফরমেন্স অপটিমাইজেশন হুক এবং একটি API নিয়ে কথা বলবো।","api#API":"memo - কম্পোনেন্টকে মেমোয়াইজ করার জন্য।","hooks#Hooks":"useCallback - কলব্যাক ফাংশনের ডেফিনেশনকে মেমোয়াইজ করার জন্য। (যখন প্রপ্স আকারে কোন ফাংশনকে পাঠানো হয়,সেই ফাংশনকে মেমোয়াইজ করার জন্য।)\nuseMemo - ফাংশনের রেজাল্টকে মেমোয়াইজ করার জন্য।","memo#memo":"আমরা জানি যে,আমাদের কম্পোনেন্ট তিনটি কাড়নে রি-রেন্ডার নেয়\nProps Change হলে,\nState Change হলে এবং\nParent Components Re-Render হলে\nপ্রথম দুইটি ক্ষেত্রে আমাদের কম্পোনেন্ট রি-রেন্ডার হলে আমাদের কিছুই করার নাই, কিন্তু যদি তৃতীয় কারনে বা প্যারেন্ট কম্পোনেন্ট এর রি-রেন্ডার হওয়ার কারনে যখন চাইল্ড কম্পোনেন্ট গুলো রি-রেন্ডার হয় তখন যদি আমাদের প্রয়োজন হয় তাহলে আমরা সেটা চাইলে ফিক্স করতে পারি।যদি এমন হয় যে আমাদের কম্পোনেন্টের কোন কোডব্লক অপ্রয়োজনীয় রেন্ডার নিচ্ছে এবং এতে পার্ফমরমেন্সের খুব বেশি লক্ষণীয় প্রভাব ফেলছে, এবং যদি সেটা একান্তই ফিক্স করতে হয় তাহলে আমরা Component এর রি-রেন্ডার আটকানো বা Component কে মেমোয়াইজ করার জন্য ব্যাবহার করতে পারি memo APIUsage\nimport React from \"react\";\nconst MyComponent = () => {\n    return (\n        <div>\n            <h1>\n                Something that is re-rendering everytime due to its parents\n                state change\n            </h1>\n        </div>\n    );\n};\nexport default MyComponent;\nআমদের এই কম্পোনেন্ট টা শুধুমাত্র একটা টেক্সট স্ক্রিনে প্রিন্ট করছে, আর কিছুই করেনা। কিন্তু এর প্যারেন্ট কম্পোনেন্ট এ হয়তো কোন স্টেট চেঞ্জের কারনে বার বার রি-রেন্ডার হচ্ছে। আমরা জানি প্যেরেন্ট কম্পোনেন্ট এ কোন স্টেট চেঞ্জ হলে তার নিচের পুরো ট্রি টাই রি-রেন্ডার হয়।ধরেন MyComponent টা একটা অনেক বড় কম্পোনেন্ট এবং এটা অনেক হেভি কাজ করছে, আর তাই প্রতিবার প্যারেন্ট এর স্টেট চেঞ্জ এর কারনে আপনি এই কম্পোনেন্ট কে রি-রেন্ডার করাতে চান না। এসব ক্ষেত্রে কোন কম্পোনেন্ট এর রি-রেন্ডার আটকানোর জন্য আমরা নিচের উপায়ে memo ব্যাবহার করতে পারি।\nimport { memo } from \"react\";\nconst MyComponent = () => {\n    return (\n        <div>\n            <h1>\n                Something that is re-rendering everytime due to its parents\n                state change\n            </h1>\n        </div>\n    );\n};\nexport default memo(MyComponent);\n// or\nimport { memo } from \"react\";\nconst MyComponent = () => {\n    return (\n        <div>\n            <h1>\n                Something that is re-rendering everytime due to its parents\n                state change\n            </h1>\n        </div>\n    );\n};\nconst memoizedMyComponent = memo(MyComponent);\nexport default memoizedMyComponent;","usecallback#useCallback":"ধরুন আপনার কোন একটা প্যারেন্ট কম্পোনেন্ট থেকে আপনি কোন একটা চাইল্ড কম্পোনেন্টে প্রপ্স হিসেবে কোন একটা ফাংশন পাঠিয়েছেন। এবং সেই চাইল্ড কম্পোনেন্ট কে আপনি হয়তো memo দিয়ে রি-রেন্ডারিং আটকাতে চাচ্ছেন। কিন্তু আপনি দেখবেন যে memo ব্যাবহার করার পরও সেই কম্পোনেন্ট টা রি-রেন্ডার হচ্ছে।এর কারণ হলো সেই চাইল্ড কম্পোনেন্টটা তার প্যারামিটারে একটা ফাংশন রিসিভ করছে।জাভাস্ক্রিপ্টে প্রতিটা ফাংশন এক একেকটা অবজেক্ট। তাই প্রতিবার রি-রেন্ডারে সেই ফাংশনগুলো সেম নামে হওয়া সত্ত্বেও প্রতিটা রেন্ডারে নতুন নতুন অবজেক্ট রেফারেন্স হিসেবে আসবে। তাই প্যারামিটারে প্রতিবার নতুন নতুন প্রপ্স ভ্যালু আসার কারনে কম্পোনেন্ট memo দিয়ে wrap করে দেওয়ার পরও রি-রেন্ডার হবে।এটার সমাধান করার জন্য প্রপ্স আকারে পাঠানোর আগে কলব্যাক ফাংশনগুলোকে useCallback দিয়ে মেমোয়াইজড করতে হবে, যাতে প্রতিটা রেন্ডারে ফাংশনগুলো cached হয় থাকে।অর্থাৎ কোন ফাংশনের বডি কে cached বা মেমোয়াইজড করার জন্য useCallback ব্যবহার করা হয়Usage\nimport React from \"react\";\nconst App = () => {\n    const somethingFunction = () => {\n        return; //something\n    };\n    return (\n        <div>\n            <MyComponent onChange={somethingFunction} />\n        </div>\n    );\n};\nexport default App;\nউপরের কোডের উদাহরণে somethingFunction কে প্রপ্স হিসেবে MyComponent এ পাঠানো হয়েছে তাই আমরা যদি MyComponent কে memo wrap করেও দেই,তবুও এটা রি-রেন্ডার নিবে। এটা কে আমরা ফিক্স করার জন্য somethingFunction কে useCallback হুক দিয়ে cached করবো।\nimport React, { useCallback } from \"react\";\nconst App = () => {\n    const somethingFunction = useCallback(() => {\n        return; //something\n    }, []);\n    return (\n        <div>\n            <MyComponent onChange={somethingFunction} />\n        </div>\n    );\n};\nexport default App;\nuseCallback হুক তার প্রথম প্যারামিটার হিসেবে সেই ফাংশনটাকে নিবে যেটাকে মেমোয়াইজ করতে চান আরে useEffect এর মতো দ্বিতীয় প্যারেমিটারে একটা ডিপেন্ডেন্সি অ্যারে নেয়, এবং ডিপেন্ডেন্সি চেঞ্জ হলেই নতুন করে রান হয় বা রিয়াক্ট করে।","usememo#useMemo":"আমাদের কোম্পনেন্টে যদি এমন কোন ফাংশন থাকে যাতে অনেক কমপ্লেক্স কেলকুলেশন থাকে যা অনেক কস্টলি এবং আমরা চাই কম্পোনেন্ট রি-রেন্ডার হলেই যেন সেই কস্টলি কেলকুলেশন টা বার বার না হয়। যদি নতুন করে কেলকুলেশন করার প্রয়োজন না পরে তাহলে যেন প্রতিবার রি-রেন্ডারে আগেরবার করা কেলকুলেটেট রেজাল্ট টাকেই রিটার্ন করে, তাহলে এক্ষেত্রে আমাদের সেই রেজাল্টটাকে cached করতে হবে।কোন ফাংশনের রেজাল্টটাকে cached করার জন্য ব্যাবহার করা হয় useMemo হুক।\nReference\nconst cachedResuld = useMemo(calculateValue, dependencies);","references#References:":"**useMemo(calculateValue, dependencies)**useMemo হলো রিয়াক্টের একটা হুক, অন্য সকল হুকের মতো useMemo কেও কম্পোনেন্ট অথবা অন্য কাস্টম হুকের একদম টপ লেভেলে কল করতে হবে। কখনও কম্পোনেন্টের রিটার্নের ভিতর বা অন্য কোন কলব্যাক ফাংশনের ভিতর এমনকি কোন কন্ডিশনাল কোডব্লকের ভিতরেও কল করা যাবেনা।\nimport { useMemo } from \"react\";\nfunction TodoList({ todos, tab }) {\n    const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n    // ...\n}\nUsage\nimport React, { useCallback } from \"react\";\nconst App = () => {\n    //complex calculation\n    const complexCalculation = () => {\n        let i = 0;\n        while (i < 10000000) {\n            i++;\n        }\n        return i % 2 === 0;\n    };\n    const somethingFunction = useCallback(() => {\n        return; //something\n    }, []);\n    return (\n        <div>\n            <MyComponent onChange={somethingFunction} />\n        </div>\n    );\n};\nexport default App;\nউপরের কোডে একটা কমপ্লেক্স কেলকুলেশন আছে complexCalculation ফাংশনের ভিতর, আমরা ওই কেলকুলেশন এর রেজাল্টটাকে cached করবো।\nimport React, { useCallback, useMemo } from \"react\";\nconst App = () => {\n    //complex calculation\n    const complexCalculation = useMemo(() => {\n        let i = 0;\n        while (i < 10000000) {\n            i++;\n        }\n        return i % 2 === 0;\n    }, []);\n    return (\n        <div>\n            <MyComponent />\n        </div>\n    );\n};\nexport default App;\nuseMemo হুক তার ভিতরে কল হওয়া ফাংশনটার আউটপুট কে রিটার্ন করবে,এমন নয় যে সে ফাংশনটা রিটার্ন করবে। তার মানে হলো useMemoকে যেই ভ্যারিয়েবলে এসাইন করা হবে,তার কাছে useMemo হুক এর ভিতরের ফাংশন যেই ভ্যালূটা রিটার্ন করবে, ভ্যারিয়েবলের কাছে সেই আউটপুটটা থাকবে।useMemo হুক useCallback এবং useEffect এর মতো দ্বিতীয় প্যারেমিটারে একটা ডিপেন্ডেন্সি অ্যারে নেয়, এবং ডিপেন্ডেন্সি চেঞ্জ হলেই শুধুমাত্র ভিতরের ফাংশনটা নতুন করে রান হয় এবং নতুন আউটপুট রিটার্ন করে।"}},"/reactive-accilarator/React-js/module-4/removing-effect-dependecies":{"title":"Removing Effect Dependecies","data":{"removing-effect-dependencies#Removing Effect Dependencies":"যখনি আপনি কোন ইফেক্ট ডিক্লেয়ার করবেন,তখন linter অটোমেটিক ভেরিফাই করবে যে আপনি সকল রিয়াক্টিভ ভ্যালু তার ডিপেন্ডেন্সি অ্যারেতে এড করেছেন, কিন্তু কখনো কখনো যদি আপনি অপ্রয়োজনীয় ডিপেন্ডেন্সি এড করেন, এটা আপনার এপ্লিকেশনে বাগ সৃষ্টি করতে পারে ।এই লেসনে আমরা জানবো কিভাবে আমরা ইফেক্টের ডিপেন্ডেন্সি থেকে অপ্রয়োজনীয় ডিপেন্ডেন্সি বাদ দিতে পারি।","dependencies-should-match-the-code#Dependencies should match the code":"যখনি কোন ইফেক্ট লিখবেন, আপনি ইফেক্টের মাধ্যমে কি করতে চান তার শুধু স্টার্ট আর স্টপ লিখবেন, তারপর যদি আপনি ইফেক্টর ডিপেন্ডেন্সি ইম্পটি রাখলে linter আপনাকে প্রয়োজনীয় ডিপেন্ডেন্সিগুলো অটো সাজেস্ট করবে। আপনাকে শুধু সেই সাজেশন অনুযায়ী ডিপেন্ডেন্সিগুলো ডিপেন্ডেন্সি অ্যারেতে লিখে দিতে হবে।অর্থাৎ আপনাকে ইফেক্টের ডিপেন্ডেন্সি নিয়ে কোন চিন্তা করতে হবেনা, প্রয়োজনীয় ডিপেন্ডেন্সিগুলো linterই আপনাকে বলে দিবে।","to-remove-a-dependency-prove-that-its-not-a-dependency#To remove a dependency, prove that it’s not a dependency":"যেহেতু আপনাকে ইফেক্টের ডিপেন্ডেন্সিগুলো আপনাকে সিলেক্ট করতে হবেনা, প্রয়োজনীয় ডিপেন্ডেন্সিগুলো linterই আপনাকে বলে দিবে। তাই যদি এমন হয় যে এমন কোন ডিপেন্ডেন্সি linter আপনাকে সাজেস্ট করছে ডিপেন্ডেন্সিতে এড করতে কিন্তু আপনি সিওর জানেন যে সেটা কখনো চেঞ্জ হবেনা, আর তাই আপনি সেটা ডিপেন্ডেন্সিতে দিতে চান না, তাহলে রিয়াক্টকে এটা কোডের মাধ্যমে বুঝাবেন যে এটা কখনো চেঞ্জ হবেনা। কিন্তু আপনি কিন্তু এমন ক্ষেত্রে কখনই linter কে সাপ্রেস করবেন না।ধরুন আপানার কোড এমন ,\nconst serverUrl = \"https://localhost:1234\";\nfunction ChatRoom({ roomId }) {\n    // This is a reactive value\n    useEffect(() => {\n        const connection = createConnection(serverUrl, roomId); // This Effect reads that reactive value\n        connection.connect();\n        return () => connection.disconnect();\n    }, [roomId]); // ✅ So you must specify that reactive value as a dependency of your Effect\n    // ...\n}\nএক্ষত্রে linter আপনাকে সাজেস্ট করবে roomId কে ডিপেন্ডেন্সিতে এড করার জন্য। কিন্তু আপনি জানেন যে roomId কখনোই চেঞ্জ হবেনা। আর তাই আপনি হয়তো roomId কে ডিপেন্ডেন্সি থেকে বাদ দিলেন,\nconst serverUrl = \"https://localhost:1234\";\nfunction ChatRoom({ roomId }) {\n    useEffect(() => {\n        const connection = createConnection(serverUrl, roomId);\n        connection.connect();\n        return () => connection.disconnect();\n    }, []); // 🔴 React Hook useEffect has a missing dependency: 'roomId'\n    // ...\n}\nতখনি দেখবেন linter আপনাকে ওয়ার্নিং দেবে, আর তাই আপনি হয়তো ওয়ার্নিং থেকে বাচার জন্য linter কে এভাবে সাপ্রেস করে দিলেন।\nconst serverUrl = \"https://localhost:1234\";\nfunction ChatRoom({ roomId }) {\n    useEffect(() => {\n        const connection = createConnection(serverUrl, roomId);\n        connection.connect();\n        return () => connection.disconnect();\n        // eslint-ignore-next-line react-hooks/exhaustive-deps\n    }, []);\n    // ...\n}\nএটা কখনই করবেন না, কারণ এতে আপনার কম্পোনেন্টে বাগ তৈরি হবে, এবং পরে আর কখনই এই কম্পোনেন্টে linter সাজেশন দিবেনা, আর তাই হয়তো আপনি কোন প্রয়োজনীয় ডিপেন্ডেন্সি মিস করে যেতে পারেন, এতে আপনার কম্পনেন্টের বিহেবিয়ার চেঞ্জ হয়ে যাবে। তাই আপনি যদি একদম শিওর হন যে, roomId কখনই চেঞ্জ হবেনা,তাহলে আপনাকে রিয়াক্টকে বুঝাতে হবে যে roomId কখনই চেঞ্জ হবেনা। আর এটা করার জন্য আপনি roomId কে কম্পোনেন্টের বাহিরে নিয়ে স্ট্যাটিক ভাবে লিখে রাখতে পারেন।\nconst serverUrl = \"https://localhost:1234\";\nconst roomId = \"general\";\nfunction ChatRoom() {\n    useEffect(() => {\n        const connection = createConnection(serverUrl, roomId);\n        connection.connect();\n        return () => connection.disconnect();\n    }, []);\n    // ...\n}\nমনে রাখবেন ডিপেন্ডেন্সি থেকে কোন কিছু বাদ দিতে চাইলে কখনওই linter কে সাপ্রেস করবেন না । বরং আপনি কোড চেঞ্জ করবেন। কোড অনুযায়ী ডিপেন্ডেন্সি ম্যাচ করবে।"}},"/reactive-accilarator/React-js/module-4/referencing-values-with-refs":{"title":"Referencing Values with Refs","data":{"":"এই পার্টে আমরা সর্বপ্রথম useRef হুক নিয়ে কথা বলবো। রিয়াক্টে আমরা আমদের সকল কিছু স্টেট দিয়ে ম্যানেজ করতে পারি, কিন্তু কখনো কখনো হয়তো আমাদের HTML DOM Element কে মডিফাই করার প্রয়োজন পরতে পারে যা আমরা চাইলেও স্টেট দিয়ে ম্যানেজ করতে পারবোনা। সেসব ক্ষেত্রে আমাদেরকে বাধ্য হয়েও ম্যনুয়ায়লি DOM মডিফাই করার প্রয়োজন পরবে, এই ক্ষেত্রে রিয়াক্ট আমাদের একটি হুক দিয়ে দিয়েছে useRef নামে, যেটা আমরা ব্যাবহার করতে পারি। তবে মনে রাখতে হবে useRef আমারা রিয়াক্টের কনট্রোলের বাইরে গিয়ে ব্যবাহার করবো বিধায় এটাকে ওভার ইউজ করা যাবেনা। আমরা কিভাবে useRefব্যাবহার করবো এবং কোন কোন ক্ষেত্রে আমাদের ইউজ-রেফ ব্যাবহার করতে হবে তা নিয়ে আমারা এই লেসনে বিস্তারিত আলোচনা করবোঃ","referencing-values-with-refs#Referencing Values with Refs":"যখন আমরা চাই যে আমাদের কোন কম্পোনেন্ট কোন ভ্যালু ধরে রাখবে, এবং আমরা তা চেঞ্জ করলেও আমাদের কম্পোনেন্ট রি-রেন্ডার করবেনা, সেই ক্ষেত্রে আমারা useRef ব্যাবহার করবো।","adding-a-ref-to-your-component-কিভাবে-কম্পোনেন্টে-useref-ব্যবাহার-করা-যায়#Adding a ref to your component (কিভাবে কম্পোনেন্টে useRef ব্যবাহার করা যায়)":"চলুন দেখে নেই কিভাবে আমরা কমোনেন্টে ইউজ রেফ ব্যাবহার করতে পারি,\nপ্রথমে আমাদের কে রিয়াক্ট থেকে useRefকে ইম্পোর্ট করে নিতে হবে\nimport { useRef } from \"react\";\n** তারপর আমাদের কম্পোনেন্টে useRef কে কল করতে হবে এবং তার একটি ইনিশিয়াল ভ্যালু দিতে হবে**\nconst ref = useRef(0);\nআমারা এখানে ref এর ইনিশিয়াল ভ্যালু দিয়েছি 0 । এই অবস্থায় ref আমাদের একটা অবজেক্ট রিটার্ন করবে এবং ref অবজেক্ট এর একটা ডিফল্ট প্রপার্টি থাকে current নামে। সেই current এর ভিতর আমরা আমাদের ref এর ভ্যালুটা পাবো । আমরা যদি এবার ref টাকে js console.log(ref) করি, তাহলে আমরা আঊটপুট পাবো এমনঃ\n{\n    current: 0; // আমরা যেই ইনিশয়াল ভ্যালুটা দিয়েছিলাম সেটা এখানে রিটার্ন করছে।\n}\nআমরা এই ref.current এর ভ্যালু চাইলে read / write দুটোই করতে পারি, অর্থাৎ আমরা চাইলে ref.current এর মধ্যে কোন ভ্যালু স্টোর করতে পারি, সেটাকে পরিবর্তন করতে পারি এবং সেটাকে ব্যাবহার ও করতে পারি এবং এটার কোন ট্র্যাক রিয়াক্ট রাখবেনা, তাই এটাকে বলা হয় Escape Hatch. তবে একটা বিষয় মাথায় রাখতে হবে যে আমরা ref.current এর ভ্যালু রিয়াক্ট এর রেন্ডার এ ব্যাবহার করতে পারবোনা। অর্থাৎ UI তে ref.current এর ভ্যালু দেখাতে পারবোনা।\nimport { useRef } from \"react\";\nexport default function App() {\n    const ref = useRef(\"something\");\n    return <h1>You are rendering {ref.current} </h1>; // এখানে রিয়াক্ট এর রেন্ডারিং এ ref.current এর ভ্যালু UI তে দেখানো হচ্ছে, এটা করা যাবেনা।\n}\nতাহলে কি করা যাবে ? চলুন দেখে নেই একটা উদাহরণের মাধ্যমে।আমরা একটা সিম্পল বাটন রাখবো এবং আমরা কয়বার বাটনে ক্লিক করলাম সেটা একটা এলার্টের মাধ্যমে দেখাবো।\nimport { useRef } from \"react\";\nexport default function App() {\n    const ref = useRef(0);\n    function handleCountClick() {\n        ref.current = ref.current + 1;\n        alert(`you clicked the button ${ref.current} times`);\n    }\n    return <button onClick={handleCountClick}>Click me to count</button>;\n}\nএখানে আমরা যতবার বাটনে ক্লিক করবো ততবার আমদের এলার্টে সেটা দেখাবে।আমরা যদি এই কম্পোনেন্টে একটু খেয়াল করি তাহলেই useRef এর ব্যাপারে স্বচ্ছ ধারনা পেয়ে যাবো।খেয়াল করুনঃ\nuseRef এর ref.cuurent ভ্যালু পরিবর্তন করা হয়েছে একটা হ্যান্ডেলারের ভিতর।\nuseRefএরref.cuurentভ্যালু পরিবর্তন করার জন্য কোন রকমsetter function` কল করা হয়নি\nsetter function কল করা হয়নি বলে কম্পোনেন্ট রি-রেন্ডার করবেনা\nকম্পোনেন্ট রি-রেন্ডার না করা সত্ত্বেও ref এর ভ্যালু পরিবর্তন করার সাথে সাথেই পরের লাইনেই আমরা আপডেটেড ভ্যালু এক্সেস করতে পারছি\nতারমানে আমরা এখানে ref কে একটা plain javascript object এর মতো ব্যাবহার করতে পারছি\nref.current এর ভ্যালু আমরা কম্পোনেন্ট এর কোন রেন্ডারিং এ ব্যাবহার করিনি। আমরা শুধুমাত্র এলার্টে দেখিয়েছি।\nএই বিষয়গুলোই মূলত মনে রাখতে হবে আমাদের useRef ব্যবহারের ক্ষেত্রে।","storing-a-reference-or-values-in-ref--ref-এর-মদ্ধে-কোন-রেফারেন্স-বা-ভ্যালু-স্টোর-করে-রাখা#Storing a Reference or values in ref ( ref এর মদ্ধে কোন রেফারেন্স বা ভ্যালু স্টোর করে রাখা)":"আমরা useRef এর current প্রপার্টির মধ্যে কোন রেফারেন্স বা ভ্যালু স্টোর করে রাখতে পারি, এবং সেটা রিয়াক্টের স্টেট চেঞ্জ হলেও কম্পোনেন্ট সেই ভ্যালু টা ধরে রাখবে। অর্থাৎ আমরা ref কে কম্পোনেন্ট এর এমন একটা স্টোরেজ হিসাবে ব্যাবহার করতে পারি যা, আমদের স্টেট চেঞ্জ হয়ে কম্পোনেন্ট যতবার রি-রেন্ডার হোক না কেন,আমাদের সেই স্টোর করা ডাটা হারাবেনা।চলুন একটা উদাহরণের মাধ্যমে বুঝি। আমরা একটা Stop watch বানাবো এবং আমরা যখন Stop watch টা Start করবো তখন থেকে যখন আমরা Stop Watch টা বন্ধ করবো এর মাঝে কত সময় গিয়েছে সেটা UI তে দেখাবোঃ\nimport { useState } from \"react\";\nexport default function Stopwatch() {\n    const [startTime, setStartTime] = useState(null); //যখন আমরা Start বাটনে ক্লিক করলাম সেই টাইম টা আমরা স্টেট দিয়ে ম্যানেজ করছি\n    const [now, setNow] = useState(null); // Start  করার পর বর্তমান পর্যন্ত কত সময় পার হয়েছে সেটা আমরা এর মাধ্যমে কেলকুলেট করবো।\n    function handleStart() {\n        // এখনে আমারে কাউন্টার টা Start  করলাম\n        setStartTime(Date.now());\n        setNow(Date.now());\n        setInterval(() => {\n            // প্রতি ১০ মিলিসেকন্ড পর পর আমরা  Stop Watch  এর ভ্যালু স্টেট দিয়ে আপডেট করছি\n            setNow(Date.now());\n        }, 10);\n    }\n    let secondsPassed = 0;\n    if (startTime != null && now != null) {\n        secondsPassed = (now - startTime) / 1000;\n    }\n    return (\n        <>\n            <h1>Time passed: {secondsPassed.toFixed(3)}</h1>\n            <button onClick={handleStart}>Start</button>\n        </>\n    );\n}\nএখন আমাদের Stop Watch টাকে Stop করা লাগবে, Stop করতে হলে আমাদেরকে interval টাকে clear করতে হবে clearInterval(intervalReference) দিয়ে। কিন্তু আমদেরকে তো interval টাকে clear করতে হলে interval এর রেফারেন্সটাকে দরকার হবে, কিন্তু এখানে তো আমাদের interval টা আছে একটা handler এর ফাংশনের ভিতরে এবং প্রতি ১০ মিলিসেকন্ড পরপর টা রি-রেন্ডার ট্রিগার করছে, তাই আমরা স্বাভাবিকভাবেই clearIntervalকরতে চাইলে সেই interval এর রেফারেন্স টা পাবোনা। তাই এখেত্রে আমাদেরকে হেল্প করবেuseRef হুক।আমরা ref.current এর মদ্ধ্যে সেই interval এর রেফারেন্সটাকে স্টোর করবো এবং তাকে দিয়ে clearInterval কল করবো।এখানে প্রশ্ন আসতে পারে যে কেন আমদেরকে এই অবস্থায় interval এর রেফারেন্সটাকে ref এর মধ্যেই স্টোর করতে হবে, আমরা জাভাস্ক্রিপ্ট এর কোন ভ্যারিয়বল এ কেন রাখতে পারবোনা ?দেখুন আমরা প্রথম interval সেট করেছি handleStart নামে একটা হ্যান্ডেলার ফাংশনের ভিতরে। এখন এই ফাংশনের ভিতরে যদি আমরা এই interval টাকে কোন ভ্যারিয়েবল এ রাখি, তাহলে আমরা যখন Stop করতে চাইবো তখন handleStop ফাংশনের ভিতরে তো ওই ভ্যারিয়েবল টাকে এক্সেস করতে পারবোনা। কেননা তখন ওই ভেরিয়েবল এর স্কোপ তো শুধুমাত্র ওই handleStart ফাংশনের ভিতরের জায়গা। তাই স্বাভাবিকভাবেই আমরা এটাকে কোন ফাংশনের লোকাল ভ্যরিয়েবল হিসেবে রেখে আবার অন্য কোন ফাংশনের ভিতর থেকে এক্সেস করতে পারবোনা।আবার আমরা যদি গ্লোবাল স্কোপে কোন ইম্পটি ভ্যারিয়েবল ডিক্লেয়ার করে সেখানে interval এর রেফারেন্সটাকে সেট করে handleStop ফাংশনের ভিতরে এক্সেস করতে চাইতাম সেটাও পারতাম না, কেননা যখন আমরা Stop Watch টাকে Start করবো তখন থেকে প্রতি ১০ মিলি সেকন্ড পর পর কম্পোনেন্ট রি-রেন্ডার হচ্ছে, আর প্রতিবার রি-রেন্ডারে কম্পোনেন্ট একদম ফ্রেশ হয়ে রান হচ্ছে, তাই আমরা যখন কোন ইম্পটি ভ্যরিয়েবল ডিক্লেয়ার করবো তখন প্রতিটা রি-রেন্ডারে সেটা ইম্পটিই থাকবে, তাই আমরা handleStop হেন্ডেলারের ভিতরেও যদি সেই ভ্যারিয়েবল্টাকে ব্যাবহার করি, তাহলে প্রতিবার ইম্পটি পাওয়ার কারনে আমাদের লজিক কাজ করবেনা।এজন্যই আমরা এটাকে রেফারেন্সে রেখে কাজ করবো। কেননা রেফারেন্সটা আমাদের গ্লোবাল স্কোপে আছে, আর রেফারেন্স এর {current} প্রপার্টিতে আমরা যেইটা সেট করবো সেটা কম্পোনেন্ট যতবার রি-রেন্ডার নেক না কেন, তা সে মনে রাখতে পারবে,বা রেফারেন্স টা ধরে রাখবে।আর তাই আমরা এই সিচুয়েশনে একটা স্টোরেজ হিসেবে ref কে ব্যাবহার করবো।যহেতু IntervalId আমদের রেন্ডারিং এর মাঝে ব্যাবহার হয়না,তাই আমরা IntervalId কে স্টোর করার জন্য useRef ব্যাবহার করতে পারি।\nimport { useState, useRef } from \"react\";\nexport default function Stopwatch() {\n    const ref = useRef(null);\n    const [startTime, setStartTime] = useState(null); //যখন আমরা Start বাটনে ক্লিক করলাম সেই টাইম টা আমরা স্টেট দিয়ে ম্যানেজ করছি\n    const [now, setNow] = useState(null); // Start  করার পর বর্তমান পর্যন্ত কত সময় পার হয়েছে সেটা আমরা এর মাধ্যমে কেলকুলেট করবো।\n    function handleStart() {\n        // এখনে আমারে কাউন্টার টা Start  করলাম\n        setStartTime(Date.now());\n        setNow(Date.now());\n        ref.current = setInterval(() => {\n            // এখানে ref.current এর মদ্ধ্যে interval কে স্টোর করা হয়েছে\n            // প্রতি ১০ মিলিসেকন্ড পর পর আমরা  Stop Watch  এর ভ্যালু স্টেট দিয়ে আপডেট করছি\n            setNow(Date.now());\n        }, 10);\n    }\n    function handleStop() {\n        clearInterval(ref.current); // এখানে সেই interval এর রেফারেন্স ধরে clearInterval() কল করা হয়েছে।\n    }\n    let secondsPassed = 0;\n    if (startTime != null && now != null) {\n        secondsPassed = (now - startTime) / 1000;\n    }\n    return (\n        <>\n            <h1>Time passed: {secondsPassed.toFixed(3)}</h1>\n            <button onClick={handleStart}>Start</button>\n            <button onClick={handleStop}>Stop</button>\n        </>\n    );\n}","differences-between-refs-and-state-state-এবং-ref-এর-মদ্ধ্যে-পার্থক্য-#Differences between refs and state (state এবং ref এর মদ্ধ্যে পার্থক্য )":"রিয়াক্টের useState এবং useRef প্রায় সেম, তবে useState এর একটা setter function থাকে যার মাধ্যমে স্টেট চেঞ্জ করা হয় কিন্তু useRef এর কোন setter function থাকেনা। বরং এটা একটা অবজেক্ট রিটার্ন করে এবং তার currentনামে একটা প্রপার্টি থাকে,যা চেঞ্জ করার মাধ্যমে ref এর ভ্যালু চেঞ্জ করা হয়।চলুন একটু বিস্তারিত পার্থক্য দেখে নেই।\nrefs\tstate\tuseRef একটা ইনিশিয়াল ভ্যালু নেয় এবং রিটার্ন করে একটা অবজেক্ট,এবং সেই অবজেক্ট এর current নামক প্রপার্টির কাছে ইনিশিয়াল ভ্যালুটা থাকে\tuseState একটা ইনিশিয়াল ভ্যালু নেয়, এবং রিটার্ন করে একটা state ভ্যারিয়েবল এবং একটা setter function\tভ্যালু চেঞ্জ হলেও useRef রি-রেন্ডার ট্রিগার করেনা।\tভ্যালু আপডেট করলেই রি-রেন্ডার ট্রিগার করে\tuseRef এর ভ্যালু কে ইচ্ছামতো Muted করা যায়।\tuseState এর State এর ভ্যালু Muted করা যায়না\tuseRefএর current ভ্যালু কম্পোনেন্টের রেন্ডারিং এ ব্যাবহার করা যায়না\tযেকোন সময় স্টেট এর ভায়লুকে রিড করা যায়","when-to-use-ref-কখন-ref-ব্যাবহার-করা-উচিত#When to use ref (কখন ref ব্যাবহার করা উচিত)":"সাধারণত আমরা খুব বেশি একটা useRef ব্যাবহার করবোনা। কিন্তু যখন আমাদের রিয়াক্টের কনট্রোলের বাইরে গিয়ে কোন এক্সটারনাল API সাথে সাথে কাজ করবো এবং তা আমদের কম্পোনেন্ট এর রেন্ডারিং এর কোন এফেক্ট ফেলবেনা। তখন আমরা useRef ব্যাবহার করবো।\nStoring timeout / interval Ids (টাইমাউট আইডি বা ইন্টারভ্যাল আইডি স্টোর করে রাখার জন্য)\nStoring and manipulating DOM elements (DOM elements কে Stor করা এবং মডিফাই করার জন্য)\nStoring other objects that aren’t necessary to calculate the JSX (যেকোণ ধরনের অবজেক্ট স্টোর করা যেগুলো JSX এ রেন্ডার করার প্রয়োজন নাই)","best-practices-for-refs#Best practices for refs":"useRef ব্যাবহার করার জন্য আমদের দুইটা প্রিন্সিপল খুব ভালো করে মানতে হবে,\n**Treat refs as an escape hatch - রিয়াক্ট এ ref কে আমদের একটা escape hatch হিসেবে ব্যবাহর করতে হবে। অর্থাৎ যখন আমরা ব্রাউজারের কোন এক্সটার্নাল API এর সাথে কাজ করবো তখন আমরা useRef ব্যবাহার করতে পারি। **\nDon’t read or write ref.current during rendering - আমরা রিয়াক্ট এর রেন্ডারিং এ useRef ব্যবহার করতে পারবোনা"}},"/reactive-accilarator/React-js/module-4/reusing-logic-with-custom-hook":{"title":"Reusing Logic with Custom Hook","data":{"":"রিয়াক্টে বিভিন্ন কাজ করার জন্য বিভিন্ন বিল্ট-ইন হুক রয়েছে যেমনঃ useState, useEffect,useContext. কিন্তু কাজ করতে গিয়ে আপনার মাঝে মধ্যে মনে হতে পারে যে, আমার এই কাজটার জন্য যদি রিয়াক্টের কোন হুক থাকতো ! আপনি এমন সিচুয়েশনে আপনার নিজের একটা কাস্টম হুক বানাতে পারেন।আমরা এই লিসনে সেটাই জানবো যে, কাস্টম হুক কি ? কিভাবে বানাতে হয় ইত্যাদি বিস্তারিত।","custom-hooks-sharing-logic-between-components#Custom Hooks: Sharing logic between components":"ধরুন আপনি এমন একটা এপ্লিকেশন বানাচ্ছেন যেখানে আপনাকে বার বার চেক করতে হয় যে ইউজার online নাকি offline। যদি ইউজার অনলাইনে থাকে তাহলে আপনি অনলাইন নামে একটা স্ট্যাটাস দেখাতে চান আর অফলাইন হয়ে গেলে অফলাইন দেখাতে চান।তাহলে আপনাকে দুইটা কাজ করা লাগবে,\nএকটা স্টেট লাগবে যেটা ট্র্যাক করবে ইউজার অনলাইন নাকি অফলাইন আর সেটা JSX এর মাধ্যমে UI তে দেখাবে\nব্রাউজারের অনলাইন এবং অফলাইন ইভেন্টকে এক্সেস করার জন্য একটা ইফেক্ট লাগবে যেটা স্টেট কে আপডেট করবে।\nএক্ষেত্রে আপনার কোড হবে এমনঃ\nimport { useEffect, useState } from \"react\";\nconst StatusBar = () => {\n    const [isOnline, setIsOnline] = useState(true);\n    useEffect(() => {\n        function handleOnline() {\n            setIsOnline(true);\n        }\n        function handleOffline() {\n            setIsOnline(false);\n        }\n        window.addEventListener(\"online\", handleOnline);\n        window.addEventListener(\"offline\", handleOffline);\n        return () => {\n            window.removeEventListener(\"online\", handleOnline);\n            window.removeEventListener(\"offline\", handleOffline);\n        };\n    }, []);\n    return <div>{isOnline ? \"✅ Online\" : \"❌ Disconnected\"} </div>;\n};\nexport default StatusBar;\nএবং এতে আপনার কাজ হয়ে যাবে, কিন্তু ধরুন আপনি এমন আরও একটা কম্পোনেন্ট বানালেন যেখানে আপনাকে ইউজার অনলাইনে থাকলে একটা কিছু দেখাতে হবে আর যদি অফলাইন হয়ে যায় সেক্ষেত্রে আরেকটা কিছু দেখাতে হবে।ধরুন আরেকটা কম্পোনেন্টে একটা Play Now বাটন আছে, সেই বাটনটা ডিজেবল থাকবে যদি ইউজার এর নেটওয়ার্ক অফলাইন হয়ে যায় এবং সেক্ষেত্রে বাটনের টেক্সট দেখাবে Reconnecting...। এক্ষেত্রেও কিন্তু আপনাকে ইউজারের নেটওয়ার্ক স্ট্যাটাস টাই জানা লাগছে, এখন আপনি চাইলে সেই আগের কম্পোনেন্ট থেকে কোডটা কপি করে এই কম্পোনেন্টে পেস্ট করেও কাজ করে ফেলতে পারেন। কিন্তু এটা কোনভাবেই কোন এফিসিয়েন্ট উপায় হলোনা।কিন্তু তার চাইতে যদি এমন করা যেত যে, ইউজার অনলাইন নাকি অফলাইন এই স্টেটসহ লজিকটাকে একটা আলাদা রি-ইউজেবল কাস্টম হুক বানিয়ে নেয়া যেত ? তাহলে আমরা যত খুশি,যেখানে খুশি সেটাকে রি-ইউজ করতে পারতাম।এই স্টেটফুল লজিকগুলোকে একটা আলাদা হুক বানিয়ে নেয়টাই হলো একটা কাস্টম হুক বানানো। চলুন আগের লজিকটাকে একটা কাস্টম হুকে কনভার্ট করি।","extracting-your-own-custom-hook-from-a-component#Extracting your own custom Hook from a component":"","প্রথমে-হুকের-জন্য-একটা-আলাদা-ফাইল-বানাবো-এবং-এবং-তাতে-কাস্টম-হুক-বানানোর-জন্য-একটা-ফাংশন-ডিক্লেয়ার-করবো#প্রথমে হুকের জন্য একটা আলাদা ফাইল বানাবো এবং এবং তাতে কাস্টম হুক বানানোর জন্য একটা ফাংশন ডিক্লেয়ার করবো।":"আমাদেরকে একটা আলাদা ফাইল বানাতে হবে, ফাইলের নাম আমরা যেকোন কিছু দিতে পারি, কিন্তু কনভেনশন হলো যেই হুক বানাচ্ছি সেই হুকের সাথে মিলিয়ে ফাইলের নামটা দেওয়া । এবং হুকের জন্য যেই ফাংশনটা লিখবো সেটাও যেন যেই কাজ করতে চাচ্ছি, একদম সেই কাজ স্পেসিফিক হয়। আর অবশ্যই ফাংশনের নামের শুরুতে use দিয়ে শুরু করতে হবে এবং তার পরের প্রথম অক্ষর বড় হাতের দিয়ে শুরু করতে হবেনা।এই উদাহরণে আমরা ইউজারের online স্ট্যাটাস চেক করবো,আর তাই আমরা হুকের নাম দিচ্ছি useOnlineStatus।\nexport default function useOnlineStatus(){\n}","তারপর-কম্পোনেন্টের-ভিতর-আমরা-যেই-লজিক-লিখেছিলাম-সেটা-কম্পোনেন্ট-থেকে-cut-করে-এনে-হুকের-ভিতরে-paste-করতে-হবে#তারপর কম্পোনেন্টের ভিতর আমরা যেই লজিক লিখেছিলাম সেটা কম্পোনেন্ট থেকে cut করে এনে হুকের ভিতরে paste করতে হবে।":"import { useEffect, useState } from \"react\";\nexport default function useOnlineStatus() {\n    const [isOnline, setIsOnline] = useState(true);\n    useEffect(() => {\n        function handleOnline() {\n            setIsOnline(true);\n        }\n        function handleOffline() {\n            setIsOnline(false);\n        }\n        //syncronization\n        window.addEventListener(\"online\", handleOnline);\n        window.addEventListener(\"offline\", handleOffline);\n        //cleanup\n        return () => {\n            window.removeEventListener(\"online\", handleOnline);\n            window.removeEventListener(\"offline\", handleOffline);\n        };\n    }, []);\n}","তারপর-আমদের-যেই-ভ্যালুটা-বা-ভ্যারিয়েবলটা-আমাদের-কম্পোনেন্টে-দরকার-হবে-সেটা-হুকের-ফাংশন-থেকে-রিটার্ন-করে-দিতে-হবে#তারপর আমদের যেই ভ্যালুটা বা ভ্যারিয়েবলটা আমাদের কম্পোনেন্টে দরকার হবে সেটা হুকের ফাংশন থেকে রিটার্ন করে দিতে হবে।":"এক্ষেত্র যদি একাধিক ভ্যারিয়েবল প্রয়োজন হয় তাহলে অবজেক্ট আকারে রিটার্ন করা যেতে পারে। যেহেতু আমাদের কম্পোনেন্টর শুধু অনলাইন স্ট্যাটাস টা দরকার তাই আমরা এখান থেকে শুধু অনলাইন isOnline রিটার্ন করে দিচ্ছি।\nimport { useEffect, useState } from \"react\";\nexport default function useOnlineStatus() {\n    const [isOnline, setIsOnline] = useState(true);\n    useEffect(() => {\n        function handleOnline() {\n            setIsOnline(true);\n        }\n        function handleOffline() {\n            setIsOnline(false);\n        }\n        //syncronization\n        window.addEventListener(\"online\", handleOnline);\n        window.addEventListener(\"offline\", handleOffline);\n        //cleanup\n        return () => {\n            window.removeEventListener(\"online\", handleOnline);\n            window.removeEventListener(\"offline\", handleOffline);\n        };\n    }, []);\n    return isOnline;\n}","তারপর-কম্পোনেন্টের-ভিতরে-টপ-লেভেলে-হুকটাকে-কল-করে-isonline-টা-বের-করে-কন্ডিশনালি-কাজ-করতে-পারি#তারপর কম্পোনেন্টের ভিতরে টপ লেভেলে হুকটাকে কল করে isOnline টা বের করে কন্ডিশনালি কাজ করতে পারি।":"import useOnlineStatus from \"../../hooks/useOnlineStatus\";\nconst StatusBar = () => {\n    const isOnline = useOnlineStatus();\n    return <div>{isOnline ? \"✅ Online\" : \"❌ Disconnected\"} </div>;\n};\nexport default StatusBar;\nএই কয়টা স্টেপেই হয়ে গেলও আমাদের কাস্টম হুক। এখন এই হুক কে আমাদের যতবার খুশি,আর যেখানে খুশি ব্যাবহার করতে পারবো।","hook-names-always-start-with-use#Hook names always start with use":"রিয়াক্ট এপ্লিকেশনে কম্পোনেন্ট এবং হুকের জন্যে নিচের নেমিং কনভেনশন ফলো করতে হয়,\nReact component names must start with a capital letter রিয়াক্টের কম্পোনেন্টের নামের প্রথম অক্ষর বড় হাতের দিয়ে শুরু করতে হয়।\nHook names must start with use followed by a capital letter হুকের নামের শুরুতে use দিয়ে শুরু করতে হবে এবং তারপরের প্রথম অক্ষর অবশ্যই বড় হাতের দিতে হবে।","should-all-functions-called-during-rendering-start-with-the-use-prefix#Should all functions called during rendering start with the use prefix?":"না, নরমাল ফাংশনগুলোর নাম কখনও use দিয়ে শুরু করতে হয়না। use প্রিফিক্স একমাত্র হুকের (বিল্ট-ইন অথবা কাস্টম হুক) নামের শুরুতে ব্যাবহার করতে হবে।যদি কোন ফাংশন তার ভিতরে রিয়াক্টের কোন হুক কে ব্যাবহার না করে, তাহলে তাকে হুক না বানিয়ে নরমাল ফাংশন হিসেবে ব্যাবহার করতে হবে। কেননা রেগুলার ফাংশন হিসেবে লিখলে আপনি এটাকে কম্পোনেন্ট এর যেকোন জায়গায় ব্যাবহার করতে পারবেন অন্যদিকে হুক হিসেবে ব্যাবহার করলে এটাকে শুধু কম্পোনেন্ট এর টপ লেবেলে ব্যাবহার করতে হবে।","when-to-use-custom-hooks#When to use custom Hooks":"আপনাকে আপনার কোডের প্রতিটা ছোট ছোট ডুপ্লিকেট কমানোর জন্য কাস্টম হুক বানানোর দরকার নেই, আপনি কিছু কিছু যৌক্তিক ডুপ্লিকেট করতে পারবেন, আর এটা করা ভালো।আপনি যখন কোন ইফেক্ট ব্যাবহার করবেন, তখন আপনি রিয়াক্টের বাহিরের কোন কিছুকে এক্সেস করতে চাইছেন, এপ্নি হয়তো একবার একটা ইফেক্ট লিখছেন এবং এই এফেক্ট টা আপনাকে অনেক অনেক কম্পোনেন্টে ব্যাবহার করতে হবে, এই ক্ষেত্রে আপনি ইফেক্টকে কাস্টম হুক বানিয়ে নিতে পারেন","custom-hooks-help-you-migrate-to-better-patterns#Custom Hooks help you migrate to better patterns":"ইফেক্টগুলো হলো Escape Hatch। আপনি যখন কোন ইফেক্ট ব্যাবহার করছেন তখন আপনি রিয়াক্টের বাহিরের কোন API কে এক্সেস করছেন। রিয়াক্ট টিম এটা নিয়ে প্রতিনিয়ত কাজ করে যাচ্ছে যাতে আপনাকে খুব বেশি ইফেক্ট ব্যবহার না করতে হয়। তার ইফেক্টগুলোর জন্য কিছু বিল্ট-ইন হুক দিয়ে দিবে, তাই আপনি যদি আপনার বর্তমান কোডবেজের ইফেক্টগুলোকে কাস্টম হুক বানিয়ে ব্যাবহার করেন তাহলে আগামী ভার্সনে রিয়াক্ট যখন এসবের জন্য বিল্ট ইন হুক রিলিজ করবে তখন খুব সহজেই আপনি সেগুলো ব্যবহার করে খুব কম চেঞ্জ করার মাধ্যমে আপনি আপনার হুকগুলোকে সেগুলোতে মাইগ্রেট করতে পারবেন।"}},"/reactive-accilarator/React-js/module-4/seperating-events-from-effects":{"title":"Seperating Events from Effects","data":{"separating-events-from-effects#Separating Events from Effects":"ইউজার যখন কোন ইন্টারেকশন করে তখন মূলত ইভেন্ট হ্যান্ডেলার রান হয়, যদি সেম ইন্টারেকশন আরেকবার করে তাহলে আরেকবার ইভেন্ট-হ্যান্ডেলার রি-রান হয়, কিন্তু ইফেক্ট শুধু তখনই রি-রান হয় যখন তার ডিপেন্ডেন্সি অ্যারেতে থাকা কোন ভ্যালু আগের রেন্ডার থেকে পরের রেন্ডারে চেঞ্জ হয়।কখনো কখনো হয়তো আমরা দুইটা মিলিয়েই ব্যাবহার করবো,কিন্তু এই লেসনে আমরা শিখবো কিভাবে আমরা ইফেক্ট থেকে ইভেন্টগুলোকে আলাদা করবো।","choosing-between-event-handlers-and-effects-কখন-ইফেক্ট-ব্যাবহার-করবো-আর-কখন-ইভেন্ট-হ্যন্ডেলার-ব্যাবহার-করবো-#Choosing between event handlers and Effects (কখন ইফেক্ট ব্যাবহার করবো আর কখন ইভেন্ট হ্যন্ডেলার ব্যাবহার করবো ?)":"মনে করুন আপনি একটা চ্যাটরুম কম্পনেন্ট বানাচ্ছেন, এখন এক্ষেত্রে দুইটা রিকুয়ারমেন্ট আছে,\nআপনার কম্পোনেন্টকে অটোমেটিক ভাবে চ্যাটরুম সার্ভারের সাথে কানেক্টেড হতে হবে।\nযখন আপনি Send বাটনে ক্লিক করবেন,সুধুমাত্র তখনি মেসেজ সেন্ট হতে হবে।\nএখন আপনি চিন্তা করেন কোনটা কোথায় রাখা উচিত।অবশ্যই যেটা ক্লিক করার পর হবে সেটা হবে ইভেন্ট হ্যান্ডেলার, আর যেটা অটোমেটিক হবে সেটা হবে ইফেক্ট।","reactive-values-and-reactive-logic-রিয়াক্টিভ-ভ্যালু-এবং-রিয়াক্টিভ-লজিক-কি-#Reactive values and reactive logic (রিয়াক্টিভ ভ্যালু এবং রিয়াক্টিভ লজিক কি ?)":"","reactive-values#Reactive values":"সাধারণ ভাবে আমরা বলতে পারি যে, ইভেন্ট-হ্যান্ডেলারগুলো ট্রিগার হয় ম্যানুয়ালি,যেমন কোন বাটনে ক্লিক করার পর কোন কিছু হবে, এটাকে আমরা ইভেন্ট বলতে পারি। অন্যদিকে যদি কোনকিছু অটোমেটিক করার প্রয়োজন হয়, তখন সেই অটোমেটিক কাজগুলো হবে ইফেক্ট।প্রপ্স,স্টেট এবং ভ্যারিয়েবল যেগুলো কম্পোনেন্ট এর বডির ভিতরে ডিক্লেয়ার করা হয়েছে সেগুলো হলো রিয়াক্টিভ ভ্যালু।\nconst serverUrl = \"https://localhost:1234\";\nfunction ChatRoom({ roomId }) {\n    const [message, setMessage] = useState(\"\");\n    // ...\n}\nএই উদাহরণে serverUrl কোন রিয়াক্টিভ ভ্যালু নয়, কেননা এটা কম্পোনেন্ট এর রেন্ডারিং এর বাহিরে ডেক্লেয়ার করা একটা স্ট্যাটিক ভ্যালু। এটি কম্পোনেন্টের রি-রেন্ডারে কখনই চেঞ্জ হবেনা। কিন্তু roomId, আর message কিন্তু রিয়াক্টিভ ভ্যালু । কেননা roomId প্রপ্স হিসেবে এসেছে আর message হলো একটা স্টেট ভ্যারিয়েবল। তাই দুইটাই রিয়াক্টিভ ভ্যালু।","reactive-logic#reactive logic":"Logic inside event handlers is not reactive ইভেন্ট হ্যান্ডেলারের ভিতরে লিখা লজিকগুলো কখনো রিয়াক্টিভ না, কেননা এগুলো কখনো অটোমেটিক কোন কিছু করবেনা, একমাত্র কোন একশন ট্রিগার হলেই লজিকগুলো এক্সিকিউট হবে।\nLogic inside Effects is reactive এফেক্টের ভিতরে লিখা লজিকগুলো রিয়াক্টিভ। কেননা যদি ইফেক্টের ডিপেন্ডেন্সি এরের ভিতরে কোন কিছু রে-রেন্ডারে চেঞ্জ হয়,তাহলে ইফেক্টের ভিতরের লজিকগুলো অটোমেটিক রান হয়।","extracting-non-reactive-logic-out-of-effects#Extracting non-reactive logic out of Effects":"কখনো কখনো ইফেক্টের ভিতরে নন-রিয়াক্টিভ লজিক লিখতে হতে পারে। কিন্তু এতে করে আবার আমদের এপ্লিকেশনের বিহেবিয়ার চেঞ্জ হয়ে যেতে পারে, মানে যেটা আমরা অটোমেটিক চাইনা, সেটাও অটোমেটিক কল হয়ে যেতে পারে,এইরকম সিচুয়েশনে রিয়াক্টের একটা বিল্ট-ইন হুক যেটা useEffectEvent এখনো রিয়াক্টের স্টেবল ভার্সনে রিলিজ হয়নি,সেটা যখন স্টেবল ভার্সনের রিলিজ হবে তখন আমরা তা ব্যাবহার করতে পারবো। যেহেতু এটা এখনও স্টেবল ভার্সনের রিলিজ হয়নি, তাই এটার ডকুমেন্টেশন আমরা এখানে এড করছিনা। তবে আপনি চাইলে এই লিঙ্কে ক্লিক করে useEffectEvent সম্পর্কে বিস্তারিত জানতে পারেন"}},"/reactive-accilarator/React-js/module-4/syncronising-with-effets-overview":{"title":"Syncronising with Effets Overview","data":{"synchronizing-with-effects#Synchronizing with Effects":"যখন আমাদের কোন এক্সটার্নাল API নিয়ে কাজ করা লাগবে বা কোন সাইড ইফেক্ট (যেমনঃ API কল করা, এলার্ট দেখানো, ডাটাবেজ এক্সেস করা) হ্যান্ডেল করা লাগবে তখন আমরা useEffect ব্যাবহার করবো।মনে রাখতে হবে যে যেসব একশন অটোমেটিক ট্রিগার হতে হবে সেগুলাই useEffect এর মাধ্যমে হেন্ডেল করা লাগবে আর যেগুলো ইউজারের কোন একশনের ভিত্তিতে ট্রিগার হবে সেগুলো event handler এর মাধ্যমে হেন্ডেল করা লাগবে।যেমন ধরুন আমাদের কম্পোনেন্ট লোড হয়ে যাওয়ার সাথে সাথেই আমদের স্ক্রিনে সকল প্রডাক্ট এর লিস্ট দেখাতে হবে, এই প্রডাক্ট এর লিস্ট আসছে API থেকে। তাহলে এক্ষেত্রে আমাদের এমন কিছু করতে হবে যে আমাদের কোন event handler ছাড়াই কম্পোনেন্ট লোড হয়ে যাওয়ার সাথে সাথেই অটোমেটিক ভাবে API কল করে দিতে হবে। এই অটোমেটিক কাজটাই আমরা useEffect দিয়ে করতে পারি।আবার ধরুন কোন একটা প্রডাক্টের কার্ডে Show Details নামে একটা বাটন আছে,যেখানে ক্লিক করলে প্রডাক্টের ডিটেইলস দেখাবে, এইযে ক্লিক করলে কিছু হবে, এটা আমরা event handler দিয়ে করবোuseEffect শুধুমাত্র কম্পোনেন্ট রেন্ডার হয়ে কমিট হয়ে যাওয়ার পর এক্সিকিউট হয়। মানে হলো আমরা ইফেক্টের ভিতর যা লিখবো তা শুধুমাত্র আমাদের কম্পোনেন্ট লোড হয়ে স্ক্রিনে চলে আসার পর এক্সিকিউট হবে।","how-to-write-an-effect-কিভাবে-ইফেক্ট-লিখতে-হয়#How to write an Effect (কিভাবে ইফেক্ট লিখতে হয়)":"ইফেক্ট লিখতে হলে আমাদেরকে তিনটি স্টেপ ফলো করতে হয়, চলুন বিস্তারিত জেনে নেই।\nDeclare an Effect. (ইফেক্ট ডিক্লেয়ার করা)\nSpecify the Effect dependencies.(ইফেক্ট রান হউয়ার ডিপেন্ডেসিগুলো বলে দেয়া)\nAdd cleanup if needed.(ইফেক্ট ক্লিন-আপ করা যদি প্রয়োজন হয়)","declare-an-effect-ইফেক্ট-ডিক্লেয়ার-করা#Declare an Effect. (ইফেক্ট ডিক্লেয়ার করা)":"ইফেক্ট ডিক্লেয়ার করার জন্য সর্বপ্রথম আমাদের কম্পোনেন্টের ভিতর useEffect হুক কে ইম্পোর্ট করতে হবে। এবং তারপর useEffect কে কম্পোনেন্টের টপ লেবেলে কল করতে হবে।\nimport React from 'react'\nconst App = () => {\n    useEffect(()=>{\n         // effect code will go here\n     })\n  return (\n    <div>\n        <h1>Hello World! </h1>\n    </div>\n  )\n}\nexport default App\nইফেক্টের কোড শুধুমাত্র কম্পোনেন্ট রি-রেন্ডার হয়ে যাওয়ার পর স্ক্রিনে যখন ভিজিবল হয় শুধুমাত্র তখন এক্সিকিউট হয়। এই অবস্থায় ইফেক্টের ভিতরে আমরা যা লিখবো তা প্রতিবার আমাদের কম্পোনেন্ট রি-রেন্ডার হউয়ার সাথে সাথে রান হবে।কিন্তু এইটা তো একটা সমস্যা, কেননা আমরা যদি এফেক্ট এর ভিতরে এমন কিছু লিখি যা আমাদের শুধুমাত্র একবার কম্পোনেন্ট লোড হউয়ার সময় রান করা দরকার, পরে আর কম্পোনেন্ট রি-রেন্ডার হলেও আমারা ইফেক্টের ওই কোড রান করাতে চাইনা। যেমন ধরুনঃ আমরা কোন কম্পোনেন্টে কোন সার্ভারের সাথে কানেক্ট করালাম, এখন সেই কম্পোনেন্টে একটা ইনপুট ফর্ম আছে, তাহলেতো প্রতিবার টাইপিং এ আমাদের কম্পোনেন্ট রি-রেন্ডার হবে এবং প্রতিবার আমাদের ইফেক্ট রান হবে এবং সার্ভারের সাথে কানেকশন করাবে। কিন্তু এই কানেকশন করানো কি আমাদের প্রতিটা কি-প্রেসে দরকার আছে ? আমরা শুধু চাই আমাদের কম্পোনেন্ট যদি প্রথমবার লোড হয় তাহলে শুধুমাত্র যেন সার্ভারের সাথে কানেকশনটা হয়।তাহলে আমাদের এমন কিছু দরকার যা দিয়ে আমরা এই বিহেবিয়ার টা কনট্রোল করতে পারি। এই জন্যই আমরা এফেক্টে ডিপেন্ডেন্সি এড করবো।","specify-the-effect-dependenciesইফেক্ট-রান-হউয়ার-ডিপেন্ডেসিগুলো-বলে-দেয়া#Specify the Effect dependencies.(ইফেক্ট রান হউয়ার ডিপেন্ডেসিগুলো বলে দেয়া)":"রিয়াক্টের ইফেক্টের উপর আমাদের কনট্রোল আনার জন্য আমরা ডিপেন্ডেসি এড করবো। কেননা আমরা বলে দিতে চাই যে আমাদের কম্পোনেন্ট কখন কখন রান করা উচিত, এটা কি প্রতিটা রি-রেন্ডারে কল হবে নাকি শুধুমাত্র একবার কল হবে নাকি কোন নির্দিষ্ট বিষয়ের উপর ডিপেন্ড করে কল হবে।ডিপেন্ডেসি এড করার জন্য আমাদের ইফেক্ট এর সেকন্ড প্যারামিটারে কিছু ভ্যালু ( [] অথবা অন্যান্য ডিপেন্ডেন্সি) দিতে হয় ।যদি আমরা চাই যে প্রতিবার রি-রেন্ডারে ইফেক্ট কল হবে তাহলে এভাবে লিখতে হয়\nuseEffect(() => {\n    //code will go here\n});\nএক্ষেত্র কোন ডিপেন্ডেসি বলে দিতে হয়না ।যদি আমরা চাই যে শুধু প্রথম রেন্ডারে ইফেক্ট কল হবে এবং পরবর্তিতে কম্পোনেন্ট রি-রেন্ডার হলেও আর ইফেক্ট কল হবেনা, তাহলে এভাবে লিখতে হয়\nuseEffect(() => {\n    // code will go here\n}, []);\nএক্ষেত্র সেকন্ড প্যারামিটারে শুধুমাত্র একটা [] দিতে হয়যদি আমরা চাই যে কম্পোনেন্ট লোড হউয়ার সাথে সাথে একবার রান হবে এবং কোন স্পেসিফিক কিছু চেঞ্জ হলে আবার রান হবে,সেক্ষেত্রে আমাদের সেকেন্ড প্যারামিটারে [] এর ভিতরে ডীপেন্ডেন্সিগুলো বলে দিতে হবে\nuseEffect(() => {\n    //code will go here\n}, [a, b]);\nএক্ষেত্রে আমরা ডিপেন্ডেন্সিতে a এবং b এড করেছি, এটা যে কোন কিছু হতে পারে,যেগুলো আমরা আমাদের ইফেক্টের ভিতর ব্যাবহার করেছি, সেগুলো ডিপেন্ডেন্সিতে এড করা লাগবে, আমরা মাল্টিপল ডিপেন্ডেন্সি এড করতে পারি। আমাদের কি কি ডিপেন্ডেন্সি এড করা লাগবে তা eslint আমাদের অটোমেটিক সাজেশন দিবে। আমরা সেগুলো ফলো করেও ডিপেন্ডেন্সি এড করতে পারি।তবে আমাদের বুঝতে হবে যে কোন কোন ভ্যালূ চেঞ্জ হলে আমরা এফেক্ট আবার রান করাতে চাই,সেগুলোই আমরা ইফেক্টের ডিপেন্ডেন্সি হিসেবে ব্যাবহার করবো।আমরা ডিপেন্ডেন্সি তে যেসব ভ্যালু এড করবো রিয়াক্ট প্রতিবার কম্পোনেন্ট রেন্ডার হয়ে যাওয়ার পর চেক করে দেখবে যে সেই ভ্যালুগুলো আগের রেন্ডারে যা ছিল পরের রেন্ডারে কি তাই আছে নাকি চেঞ্জ হয়েছে, আর এটা করবে রিয়াক্ট জাভাস্ক্রিপ্টের Object.is() মেথডের মাধ্যমে। যদি কোন একটার ভ্যালু চেঞ্জ হয় তাহলেই রিয়াক্ট এফেক্টকে আরেকবার কল করবে।","add-cleanup-if-neededইফেক্ট-ক্লিন-আপ-করা-যদি-প্রয়োজন-হয়#Add cleanup if needed.(ইফেক্ট ক্লিন-আপ করা যদি প্রয়োজন হয়)":"চলুন একটা উদাহরণের কথা ভাবা যাক,যাতে আমরা বুঝতে পারি যে কখন আমাদের ক্লিন-আপ করা প্রয়োজন এবং ক্লিন-আপ কেন করতে হবে।ধরুন আমাদের একটা চ্যাট এপ্লিকেশন আছে। এখন যখনি কোন ইউজার চ্যাট করার জন্য এপ্লিকেশনটা অন করে চ্যাট কম্পোনেন্টে ক্লিক করবে সাথে সাথে ইফেক্টের মাধ্যমে একটা চ্যাট সার্ভারের সাথে কানেকশন ঘটাবে।\n  import { useEffect } from 'react';\n  import { createConnection } from './chat.js';\n export default function ChatRoom() {\n     useEffect(() => {\n         const connection = createConnection();\n         connection.connect();\n     }, []);\n     return <h1>Welcome to the chat!</h1>;\n }\n     export function createConnection() {\n      // A real implementation would actually connect to the server\n      return {\n        connect() {\n          console.log('✅ Connecting...');\n        },\n        disconnect() {\n          console.log('❌ Disconnected.');\n        }\n      };\n     }\nএখন ইউজার আবার বেক করে অন্য কম্পোনেন্টে চলে গেল এবং পুনরায় আবার এসে চ্যাট কম্পোনেন্টে ক্লিক করলো, এখন আবার একটা কানেকশন ঘটলো।খেয়াল করলে বুঝবেন যে, প্রথমবার যখন ইউজার চ্যাট আইকনে ক্লিক করার পর যেই কানেকশনটি হয়ছিল,ইউজার বেক করে অন্য পেজে চলে যাওয়ার পর কিন্তু সেই কানেকশনটি বন্ধ করা হয়নি এবং এবং ইউজার যখন আবার পুনরায় এসে আবার চ্যাট আইকনে ক্লিক করলো তখন আরও একটা কানেকশন ঘটলো, এভাবে যদি ইউজার বার বার বেক এন্ড ফোর্থ করতে থাকে তাহলে অসংখ্য কানেকশন রানিং হয়ে যাবে এবং এতে মেমরি লিক হবে। তাই সবসময় কম্পোনেন্ট যখন আনমাউন্ট হবে তখন প্রতিবার আমাদের ইফেক্টকে ক্লিন-আপ করে নিতে হবে।ক্লিন-আপ করার জন্য আমাদের ইফেক্ট এর কলব্যাক ফাংশনের ভিতর থেকে রিটার্ন করতে হবে একটা ফাংশন কল, তার ভিতর আমরা ক্লিন-আপ লিখে দিবো।\nuseEffect(() => {\n    const connection = createConnection();\n    connection.connect();\n    return () => {\n        connection.disconnect();\n    };\n}, []);"}},"/reactive-accilarator/React-js/module-4/the-lifecycle-of-an-effect":{"title":"The Lifecycle of an Effect","data":{"the-lifecycle-of-an-effect#The lifecycle of an Effect":"রিয়াক্টের প্রতিটা কম্পনেন্ট সেম লাইফ সাইকেলের ভিতর দিয়ে যায়,\nমাউন্টঃ কম্পোনেন্ট প্রথমে মাউন্ট হয় এবং স্ক্রিনে ভিজিবল হয়।\nআপডেটঃ প্রপ বা স্টেট চেঞ্জ এর উপর ভিত্ত করে কম্পোনেন্ট আপডেট হয়।\nআনমাউন্টঃ যখন স্ক্রিন থেকে রিমোভ করা হয় বা ইউজার নেভিগেট করে অন্য পেজে যায় তখন কম্পোনেন্ট আনমাউণ্ট হয়।\nরিয়াক্টের কম্পোনেন্টের ক্ষেত্রে এভাবে ভাবলে ঠিক আছে, কিন্তু ইফেক্টের লাইফসাইকেল কিন্তু এভাবে নয়। প্রতিটা ইফেক্ট কম্পোনেন্টের লাইফসাইকেল থেকে আলাদা। ইফেক্ট কম্পোনেন্টের স্টেট বা প্রপ এর সাথে এক্সটারনাল সার্ভারের Syncronize করে থাকে, তাই যখনি আমাদের কোড চেঞ্জ হতে থাকে তখন Syncronization টাও একাধিকবার দরকার হয়।চলুন একটু উদাহরণের মাধ্যমে বুঝি,ধরে নেই আমাদের এই কোড একটা এক্সটারনাল চ্যাট সার্ভারের সাথে কানেক্ট করে।\nconst serverUrl = \"https://localhost:1234\";\nfunction ChatRoom({ roomId }) {\n    useEffect(() => {\n        const connection = createConnection(serverUrl, roomId);\n        connection.connect();\n        return () => {\n            connection.disconnect();\n        };\n    }, [roomId]);\n    // ...\n}\nএখানে ইফেক্টের বডিতে বলা হয়েছে কিভাবে চ্যাট সার্ভারের সাথে কানেকশন ঘটাবে,\n// ...\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => {\n    connection.disconnect();\n};\n// ...\nআর এখানে ক্লিন-আপের মধ্যে বলা হয়েছে কিভাবে কানেকশন স্টপ করবে,\n// ...\nconst connection = createConnection(serverUrl, roomId);\nconnection.connect();\nreturn () => {\n    connection.disconnect();\n};\n// ...\nসাধারণভাবেই আপনি ভাবতে পারেন যে এখানে যখন কম্পোনেন্ট মাউট হবে তখন ইফেক্টের মাধ্যমে কানেশন স্টার্ট হবে এবং যদি কম্পোনেন্ট আনমাউন্ট হয় তাহলে কানেকশন স্টপ হয়ে যাবে।কিন্তু এখানেই কিন্তু সবকিছু শেষ না, আমদের কম্পোনেন্ট মাউন্ট থাকা অবস্থায় আমাদের আরও একাধিকবার সার্ভারের সাথে Syncronization দরকার হতে পারে।","why-synchronization-may-need-to-happen-more-than-once-কেন-একাধিকবার-syncronization-দরকার-হবে-#Why synchronization may need to happen more than once (কেন একাধিকবার Syncronization দরকার হবে ?)":"মনে করুন ChatRoom কম্পোনেন্ট তার প্রপ্স হিসেবে একটা roomId নেয় এবং যখনি roomId চেঞ্জ হয় তখনি কম্পোনেন্ট কে নতুন নতুন চ্যাটরুমের সাথে কানেক্টেড করতে হয়। ধরে নেন roomId গুলো ইউজার কোন সিলেক্ট অপশন থেকে সিলেক্ট করতে পারবে,এখন ধরুন প্রথমবার ইউজার সিলেক্ট অপশন থেকে General সিলেক্ট করলো এবং তাতে প্রথমে UI তে General চ্যাটরুম টা ভিজিবল হলো।\nconst serverUrl = \"https://localhost:1234\";\nfunction ChatRoom({ roomId /* \"general\" */ }) {\n    // ...\n    return <h1>Welcome to the {roomId} room!</h1>;\n}\nতারপর ইফেক্ট জেনারেল রুমের সাথে কানেকশন স্টার্ট করলো। এর মধ্যেই আবার ইউজার Travel চ্যাটরুম সিলেক্ট করলো এবং তাতে স্টেট চেঞ্জ হলো এবং প্রপ হিসেবে একটা নতুন roomId আসলো, এতে প্রথমে UI তে Travel চ্যাটরুম দেখানো হবে।কিন্তু এখনও কিন্তু আমাদের ইফেক্ট General চ্যাট সার্ভারের সাথেই কানেক্টেড হয়ে আছে, তাহলে এবার এখানে কিন্তু ইফেক্টকে re-Syncronize হতে হবে এবং general চ্যাট সার্ভার থেকে ডিসকানেন্ট হয়ে Travel চ্যাট সার্ভারের সাথে কানেক্ট হতে হবে।","how-react-re-synchronizes-your-effect-রিয়াক্ট-কিভাবে-ইফেক্ট-কে-re-syncronize-করে#How React re-synchronizes your Effect (রিয়াক্ট কিভাবে ইফেক্ট কে re-Syncronize করে)":"ইফেক্ট তার ডিপেন্ডেন্সি হিসেবে একটা Array আকারে কিছু রিয়াক্টিভ ভ্যালু নেয়, যেগুলো চেঞ্জ হলে রিয়াক্ট নিজেই ডিসিশন নেয় তাকে কি করতে হবে। যখন স্টেট চেঞ্জ এর কারনে কম্পোনেন্ট রি-রেন্ডার হয় এবং নতুন ভ্যালু পায়, তখন কম্পোনেন্ট প্রথমে UI তে আপডেট হয়, তারপর ইফেক্ট রান হয়। ইফেক্ট রান হউয়ার আগে সে চেক করে তার ডীপেন্ডেসি Array-এর কোন ভ্যালু সেকেন্ড রেন্ডারে চেঞ্জ হয়েছে কিনা, যদি চেঞ্জ হয় তাহলে সে প্রথমে প্রথম রেন্ডারের Syncronization টা স্টপ করে দেয়, এবং তারপর আবার নতুন করে ইফেক্ট রান করে।\nconst serverUrl = \"https://localhost:1234\";\nfunction ChatRoom({ roomId }) {\n    useEffect(() => {\n        const connection = createConnection(serverUrl, roomId);\n        connection.connect();\n        return () => {\n            connection.disconnect();\n        };\n    }, [roomId]);\n    // ...\n}","রিয়াক্টের-ইফেক্টের-লাইফসাইকেলের-চিত্রঃ#রিয়াক্টের ইফেক্টের লাইফসাইকেলের চিত্রঃ":"","each-effect-represents-a-separate-synchronization-process-আলাদা-আলাদা-ইফেক্ট-আলাদা-আলাদা-syncronization-কে-রিপ্রেজেন্ট-করে#Each Effect represents a separate synchronization process (আলাদা আলাদা ইফেক্ট আলাদা আলাদা Syncronization কে রিপ্রেজেন্ট করে)":"একই সাথে রিলেটেড ফিচারগুলো আমরা একটা ইফেক্টে ম্যানেজ করতে পারি, কিন্তু যদি এমন হয় যে আমাদের আলাদা আলাদা ফিচার ইমপ্লিমেন্ট করা লাগবে তাহলে আমরা আলাদা আলাদা ইফেক্টে সেগুলো ম্যানেজ করতে পারি।"}},"/reactive-accilarator/React-js/module-4/useImperativeHandle":{"title":"Useimperativehandle","data":{"":"forwardRef ব্যাবহার করলে আমরা আমদের কম্পোনেন্ট এর সকল এক্সেস প্যারেন্ট কম্পোনেন্ট কে দিয়ে দেই ফরোয়ার্ড করে, কিন্তু আমরা যদি চাই যে না, আমরা forwardRef করে রেফারেন্স টা ফরোয়ার্ড করবো ঠিকই কিন্তু সেই সাথে আমরা এটাও বলে দিবো যে সেই রেফারেন্স নিয়ে প্যারেন্ট কম্পোনেন্ট ঠিক কি কি করতে পারবে, মানে হলো আমরা চাইল্ড থেকে প্যারেন্ট কম্পোনেন্ট এর এক্সেস টা লিমিটেড করে দিতে চাচ্ছি, যদি এমনটা করতে চাই তাহলে আমাদেরকে useImperativeHandle নামে রিয়াক্টের একটা বিল্ট-ইন হুক ব্যাবহার করতে হবে। আমরা নিচের স্টেপগুলো ফলো করে এটা করতে পারি।","চাইল্ড-কম্পোনেন্টের-ভিতর-একটা-ref-নেয়া-লাগবে-সেই-কম্পোনেন্টের-node-এ-চাইল্ড-কম্পোনেন্টের-ref-ব্যাবহার-করা-লাগবে#চাইল্ড কম্পোনেন্টের ভিতর একটা ref নেয়া লাগবে সেই কম্পোনেন্টের NODE এ চাইল্ড কম্পোনেন্টের ref ব্যাবহার করা লাগবে।":"import { forwardRef, useRef } from \"react\";\nconst MyInput = forwardRef((props, ref) => {\n    const realInputRef = useRef(null);\n    return (\n        <input\n            {...props}\n            ref={realInputRef}\n        />\n    );\n});","useimperativehandle-হুক-এর-মাধ্যমে-বলে-দিতে-হবে-আমরা-কোন-কোন-বিষয়ের-এক্সেস-দিতে-চাই#useImperativeHandle হুক এর মাধ্যমে বলে দিতে হবে আমরা কোন কোন বিষয়ের এক্সেস দিতে চাই।":"import { forwardRef, useRef, useImperativeHandle } from \"react\";\nconst MyInput = forwardRef((props, ref) => {\n    const realInputRef = useRef(null);\n    // Only expose focus and nothing else\n    useImperativeHandle(ref, () => ({\n        focus() {\n            realInputRef.current.focus();\n        },\n    }));\n    return (\n        <input\n            {...props}\n            ref={realInputRef}\n        />\n    );\n});"}},"/reactive-accilarator/React-js/module-4/you-might-not-need-an-effect":{"title":"You Might Not Need an Effect","data":{"you-might-not-need-an-effect#You Might Not Need an Effect":"ইফেক্টকে রিয়াক্ট বলে escape hatch, মানে হলো শুধুমাত্র যখন আপনি রিয়াক্ট প্যারাডাইমের বাইরে গিয়ে কোন কিছু করবেন,তখনি একমাত্র ইফেক্ট ব্যাবহার করা উচিত না, অপ্রয়োজনীয় ইফেক্ট এপ্লিকশনের কোডবেজের মেইন্টেনেবিলিটি নষ্ট করে এবং অনেক বাগ এর সৃষ্টি করে,যদি আমরা শুধুমাত্র কোন প্রপ বা স্টেট চেঞ্জ এর ভিত্তিতে কোন কিছু করতে চাই তাহলে আমদের ইফেক্টের কোন দরকার নেই, কোন কোন ক্ষেত্রে আমাদের ইফেক্টের প্রয়োজন নেই সেগুলোই আমরা পরপর কয়েকটা উদাহরণে দেখবো। তার আগে কয়েকটা রুল অফ থাম্ব আমরা জেনে নেই, যেই যেই রুলস অনুযায়ী আমাদের ইফেক্টের কোন প্রয়োজন নেই।","you-dont-need-an-effect-to-transform-data-for-rendaring#You don't need an Effect to transform data for rendaring:":"যদি আমরা শুধুমাত্র কোন ডাটা ট্রান্সফর্ম করে UI তে দেখাতে চাই, সেই কাজে কখনই আমাদের Effect ব্যাবহার করা উচিত না। এক্ষেত্রে আমদের Deriver State প্যাটার্ন ব্যবহার করে কাজ করা উচিত।","you-dont-need-an-effect-to-do-something-when-state-or-prop-changes#You don't need an Effect to do something when state or prop changes:":"যদি কোন প্রপ বা কোন স্টেট চেঞ্জ হলে আমরা কোন কিছু করতে চাই, তাহলে কখনই আমদের Effect ব্যাবহার করা উচিত না।","you-dont-need-an-effect-to-do-something-on-user-events-specific-actions#You don't need an Effect to do something on user events specific actions:":"ইউজারের ঘটানো কোন এভেন্টে যেই কাজটা করা উচিত সেটা শুধুমাত্র ইভেন্ট হেন্ডেলার দিয়েই করা উচিত। ইভেন্ট স্পেসিফিক কোন একশনে কখনই আমাদের ইফেক্ট ব্যাবহার করা উচিত না।","when-you-dont-need-effects#When You don't need Effects":"","updating-state-based-on-props-or-state-যখন-কোন-প্রপ-বা-স্টেটের-উপর-বেইজ-করে-অন্য-স্টেট-আপডেট-করা-লাগবে#Updating state based on props or state (যখন কোন প্রপ বা স্টেটের উপর বেইজ করে অন্য স্টেট আপডেট করা লাগবে)":"ধরুন আমাদের একটা কম্পোনেন্ট আমরা ইউজারের firstname এবং lastname ইনপুট হিসেবে নিচ্চি,এবং আমরা সেটা থেকে ইউজারের Fullname টা জেনারেট করে UI তে দেখাচ্ছি। এরকম কেসে অনেকেই যেটা করে তা হলো তারা Fullname নামে একটা আলাদা স্টেট নেয়, এবং একটা ইফক্টের মধ্যে firstname এবং lastname কে Fullname এর স্টেটে আপডেট করে। এভাবে,\nfunction Form() {\n    const [firstName, setFirstName] = useState(\"Taylor\");\n    const [lastName, setLastName] = useState(\"Swift\");\n    // ❌ Avoid: redundant state and unnecessary Effect\n    const [fullName, setFullName] = useState(\"\");\n    useEffect(() => {\n        setFullName(firstName + \" \" + lastName);\n    }, [firstName, lastName]);\n    // ...\n}\nঅথচ এই কাজটা খুব সহজেই করা যেত,Derived State এর মাধ্যমে অতিরিক্ত কোন স্টেট এবং কোন ইফেক্ট ছাড়াই। আমরা একটা আলাদা লোকাল ভ্যারিয়েবল এর মধ্যে firstname এবং lastname কে কেলকুলেট করে রেন্ডারিং এর সময়ই UI তে দেখিয়ে দিতে পারতাম। যেমনঃ\nfunction Form() {\n    const [firstName, setFirstName] = useState(\"Taylor\");\n    const [lastName, setLastName] = useState(\"Swift\");\n    // ✅ Good: calculated during rendering\n    const fullName = firstName + \" \" + lastName;\n    // ...\n}","resetting-all-state-when-a-prop-changes-যখন-কম্পোনেন্টের-প্রপ-চেঞ্জ-হলে-তার-লোকাল-স্টেটগুলোকে-রিসেট-করা-লাগবে#Resetting all state when a prop changes (যখন কম্পোনেন্টের প্রপ চেঞ্জ হলে তার লোকাল স্টেটগুলোকে রিসেট করা লাগবে)":"যদি এমন হয় যে আমরা একই কম্পোনেন্ট বার বার রি-ইউজ করেছি এবং সেগুলোকে প্রপ দিয়ে কনট্রোল করেছি। এবং সেই কম্পোনেন্টের আবার নিজস্ব লোকাল স্টেট আছে, এখন আমরা চাচ্ছি যে যদি প্রপ চেঞ্জ হয় তাহলে যেন সেই কম্পনেন্টের লোকাল স্টেটও চেঞ্জ হয়ে যায়।উদাহরণস্বরূপ, ধরুন একটা ব্লগ পোস্ট এর জন্য পোস্ট নামে কম্পোনেন্ট আছে এবং সেই পোস্টের কমেন্টগুলো ম্যানেজ করার জন্য সেই কম্পোনেটের কিছু লোকাল স্টেট আছে, এখন হয়তো এমন একটা সমস্যা দেখা দিলো যে, আমরা প্রপ্স এর মাধ্যমে পোস্ট এর আইডি চেঞ্জ করে ডিফারেন্ট ডিফারেন্ট পোস্ট দেখাচ্ছি, কিন্তু পোস্টের ভিতরের স্টেটগুলো চেঞ্জ না হউয়ার কারনে সকল পোস্ট এ একই কমেন্ট শো করছে, এমন সিচুয়েশনে অনেকেই যেটা করে তা হলো, কম্পোনেন্টের ভিতরে একটা ইফেক্ট নেয় এবং যখনি প্রপ চেঞ্জ হয় তখনি ইফেক্ট দিয়ে লোকালস্টেটগুলোকে রিসেট করে দেয়। যেমন এভাবেঃ\nexport default function ProfilePage({ postId }) {\n    const [comment, setComment] = useState(\"\");\n    // ❌ Avoid: Resetting state on prop change in an Effect\n    useEffect(() => {\n        setComment(\"\");\n    }, [postId]);\n    // ...\n}\nএভাবে করলে হয়তো ঠিকঠাক কাজ করবে, কিন্তু এতে কিন্তু এপ্লিকেশনের পার্ফর্মেন্স খারাপ হবে। কারণ, আমরা জানি যে এফেক্ট রান হয় কম্পোনেন্ট লোড হয়ে স্ক্রিনে চলে আসার পর। এখন দেখেন প্রথমবার যখন কম্পোনেন্ট লোড হলো তখন সেই পোস্টের কমেন্টগুলো সহ UI তে লোড হলো, এর পর যখনি প্রপ চেঞ্জ হয়ে অন্য আরেকটা পোস্ট দেখানো হলো, তখন কিন্তু সবার প্রথমে আগের কমেন্টগুলো সহই আগে UI তে আসবে, তারপর ইফেক্ট রান হবে এবং  setComment(\"\") করে কমেন্টের স্টেট রিসেট করবে, এবং  setComment(\"\") করার সাথে সাথে কম্পোনেন্ট আবার রি-রেন্ডার হবে। এবং আগের কমেন্টগুলো মুছে যাবে।তাহলে চিন্তা করেন এটুকু কাজ করতে কম্পোনেন্ট কতবার রি-রেন্ডার হচ্ছে, তাই এই অতিরিক্ত রি-রেন্ডারের কারনে এপ্লিকেশন স্লো হয়ে যাবে।অথচ এই কাজটাই কোন এফেক্ট ছাড়াই খুব সহজেই করা যেতো key প্রপ্স ব্যাবহার করে।কম্পোনেন্ট রেন্ডার করানোর সময় postId দিয়ে ডায়নামিক ভাবে key প্রপ্স দিয়ে রেন্ডার করালে রিয়াক্ট প্রতিবার প্রপ চেঞ্জে অটোমেটিক এর ভিতরের লোকাল স্টেট গুলোকে রিসেট করে দিতো। যেমনঃ\nexport default function BlogPage({ postId }) {\n    return (\n        <Post\n            postId={postId}\n            key={postId}\n        />\n    );\n}\nfunction Posts({ postId }) {\n    // ✅ This and any other state below will reset on key change automatically\n    const [comment, setComment] = useState(\"\");\n    // ...\n}","sharing-logic-between-event-handlers-যখন-কোন-ইভেন্ট-স্পেসিফিক-লজিক-শেয়ার-করা-লাগবে#Sharing logic between event handlers (যখন কোন ইভেন্ট-স্পেসিফিক লজিক শেয়ার করা লাগবে)":"ধরুন একটা প্রোডাক্টপেজ আছে,এবং প্রতিটা প্রডাক্ট কার্ডে দুইটা বাটন আছে, একটা Buy Product আরেকটা হলো Checkout। এখন লজিক হলো দুটো বাটনেই ক্লিক করলে একটা নটিফিকেশন মেসেজ দেখাবে যে Product added to cart এবং Checkout বাটনে ক্লিক করলে /checkout পেজে নিয়ে যাবে।এখন অনেকেই যেটা করে সেটা হলো যে যেহেতু দুইটা বাটনে চাপ দিলে একই কাজ হচ্ছে, (নটিফিকেশন দেখানো) তাই useEffect এর মধ্যে লজিকটাকে শেয়ার করে এবং একটা নোটিফিকেশন শো করে।এভাবে,\nfunction ProductPage({ product, addToCart }) {\n    // ❌ Avoid: Event-specific logic inside an Effect\n    useEffect(() => {\n        if (product.isInCart) {\n            showNotification(`Added ${product.name} to the shopping cart!`);\n        }\n    }, [product]);\n    function handleBuyClick() {\n        addToCart(product);\n    }\n    function handleCheckoutClick() {\n        addToCart(product);\n        navigateTo(\"/checkout\");\n    }\n    // ...\n}\nএতে কিন্তু এপ্লিকেশনে একটা বাগ এর সৃষ্টি হয়, কেননা ইফেক্ট রান হয় কম্পোনেন্ট লোড হয় যাওয়ার পর, এখন যদি কোন ইউজার কোন প্রডাক্টের Buy Productবাটনে চাপ দিয়ে প্রোডাক্টটি কার্টে এড করলো, এসব রিয়েল লাইফ এপ্লিকেশনে ডাটা ডাটাবেসে সেভ হবে, তাই ইউজার যখন কোন প্রোডাক্ট কার্টে এড করে অন্য পেজে যাবে ,এবং আবার যখন প্রোডাক্ট পেজে ফিরে আসবে,তখন আসার সাথে সাথেই ইফেক্ট রান হবে, এবং আবার নোটিফিকেশন মেসেজ দেখাবে।অথচ এই কাজটা যেহেতু ইউজারের ইভেন্ট স্পেসিফিক কাজ, কেননা শুধুমাত্র যখন ইউজার Buy Product অথবা Checkout বাটনে চাপ দিবে তখনি একমাত্র নোটিফিকেশনটা দেখাবে,তাই এই কাজটা ইভেন্ট হ্যন্ডেলারের মধ্যেই করা উচিত। আমরা এভাবে এটা করতে পারি,\nfunction ProductPage({ product, addToCart }) {\n    // ✅ Good: Event-specific logic is called from event handlers\n    function buyProduct() {\n        addToCart(product);\n        `Added ${product.name} to the shopping cart!`;\n    }\n    function handleBuyClick() {\n        buyProduct();\n    }\n    function handleCheckoutClick() {\n        buyProduct();\n        navigateTo(\"/checkout\");\n    }\n    // ...\n}","sending-a-post-request-সার্ভারে-পোস্ট-রিকুয়েস্ট-সেন্ট-করা#Sending a POST request (সার্ভারে পোস্ট রিকুয়েস্ট সেন্ট করা)":"ধরুন আমাদের এপ্লিকেশনে কোন একটা কম্পোনেন্টে কেই ভিসিট করলেই অটোমেটিক একটা এনালাইটিক লগ সার্ভারে পোস্ট হবে, আবার ধরুন আরেকটি ফর্ম আছে যেখানে ইউজারের ইনফরমেশন ইনপুট করবে এবং সাবমিট করবে, সাবমিট বাটনে ক্লিক করলে সার্ভারে একটা পোস্ট রিকুয়েস্ট যাবে,তাহলে এই ক্ষত্রে দুইটা কেস, একটাতে আমাদের অটোমেটিক করতে হবে আরেকটাতে ইউজার সাবমিট বাটনে ক্লিক করার পর, তাই আমরা এখানে এভাবে করতে পারি,\nfunction Form() {\n    const [firstName, setFirstName] = useState(\"\");\n    const [lastName, setLastName] = useState(\"\");\n    // ✅ Good: This logic should run because the component was displayed\n    useEffect(() => {\n        post(\"/analytics/event\", { eventName: \"visit_form\" });\n    }, []);\n    //  ✅ Good: Event-specific logic inside an event handler\n    function handleSubmit(e) {\n        e.preventDefault();\n        post(\"api/register\", { firstName, lastName });\n    }\n    // ...\n}\nইনালাইটিক্স এর জন্য পোস্ট রিকুয়েস্ট যেহেতু অটোমেটিক পাঠাতে হবে তাই এটাকে ইফেক্টের মাঝে রাখতে হবে এবং ইউজার ফর্ম সাবমিট করলে যেই পোস্ট রিকুয়েস্ট sent হবে সেটা ইভেন্ট হ্যান্ডেলারের ভিতর রাখতে হবে।","initializing-the-application-এপ্লিকেশন-লোড-হওয়ার-পর-শুধুমাত্র-একবার-কোন-লজিক-রান-করতে-চাইলে#Initializing the application (এপ্লিকেশন লোড হওয়ার পর শুধুমাত্র একবার কোন লজিক রান করতে চাইলে)":"ধরুন কোন একটা লজিক আমরা চাইযে পুরো এপ্লিকেশনটা লোড হলে শুধুমাত্র একবার রান হবে, এক্ষত্রে কিন্তু কোন স্পেসিফিক কম্পোনেন্টের কথা বলছি না, পুরো এপ্লিকেশনে শুধুমাত্র একবার রান হবে এমন কোন লজিক যদি ইমপ্লিমেন্ট করতে হয় তাহলে অনেকে এভাবে করতে চায়,\nfunction App() {\n    // ❌ Avoid: Effects with logic that should only ever run once\n    useEffect(() => {\n        loadDataFromLocalStorage();\n        checkAuthToken();\n    }, []);\n    // ...\n}\nএপ্লিকেশনের টপ লেবেলে কোন ইফেক্ট লিখে কোন ডিপেন্ডেন্সি ছাড়া কল করে, কিন্তু এটা ভেভেলপমেন্ট মুডে দুইবার কম্পোনেন্ট মাউণ্ট হওয়ার কারনে এপ্লিকেশনের লজিক ব্রেক করতে পারে, তাই এমন সিচুয়েশনে আমরা নিচের দুটি পদ্ধতি অনুসরণ করতে পারি,\nlet didInit = false;\nfunction App() {\n    useEffect(() => {\n        if (!didInit) {\n            didInit = true;\n            // ✅ Only runs once per app load\n            loadDataFromLocalStorage();\n            checkAuthToken();\n        }\n    }, []);\n    // ...\n}\nif (typeof window !== \"undefined\") {\n    // Check if we're running in the browser.\n    // ✅ Only runs once per app load\n    checkAuthToken();\n    loadDataFromLocalStorage();\n}\nfunction App() {\n    // ...\n}","notifying-parent-components-about-state-changes-যদি-চাইল্ড-কম্পোনেন্টে-ইউজারের-কোন-একশনে-স্টেট-চেঞ্জ-হলে-সেটা-প্যারেন্ট-কম্পোনেন্টকে-জানাতে-হয়#Notifying parent components about state changes (যদি চাইল্ড কম্পোনেন্টে ইউজারের কোন একশনে স্টেট চেঞ্জ হলে সেটা প্যারেন্ট কম্পোনেন্টকে জানাতে হয়)":"মনে করুন আমাদের এমন একটা কম্পোনেন্ট আছে যেটা প্যারেন্ট কম্পোনেন্ট এ একটা স্টেট ম্যানেজ করছে এবং চাইল্ড কম্পোনেন্টে ইউজারের কোন একশনে সেই চাইল্ড কম্পোনেন্টের লোকাল স্টেট চেঞ্জ হলে সেটা প্যারেন্ট কম্পোনেন্টকে জানাতে হবে, এক্ষেত্রে অনেকেই যেটা করতে পারেন,সেটা হলো প্যারেন্ট কম্পোনেন্ট থেকে একটা setter function প্রপ্স দিয়ে চাইল্ড কম্পোনেন্টে পাস করে চাইল্ড কম্পোনেন্টে একটা ইফেক্ট দিয়ে চাইল্ড কম্পোনেন্ট এর স্টেট চেঞ্জ হলে প্যারেন্ট এর setter function কে কল করে দিতে পারেন। যেমনটা নিচে করা হয়েছে,\nfunction Toggle({ onChange }) {\n    const [isOn, setIsOn] = useState(false);\n    // ❌ Avoid: The onChange handler runs too late\n    useEffect(() => {\n        onChange(isOn);\n    }, [isOn, onChange]);\n    function handleClick() {\n        setIsOn(!isOn);\n    }\n    function handleDragEnd(e) {\n        if (isCloserToRightEdge(e)) {\n            setIsOn(true);\n        } else {\n            setIsOn(false);\n        }\n    }\n    // ...\n}\nকিন্তু এভাবে করাটা কোনভাবেই এফিসিয়েন্ট উপায় না, কেননা আমরা জানি ইফেক্ট রান হয় কম্পোনেন্ট লোড হয়ে যাওয়ার পার, তাই এখানে প্যারেন্টের স্টেটের সাথে প্রথমে Sync থাকবেনা, পরে সেটা এফেক্টের মাধ্যমে আরেকটা রি-রেন্ডার হয়ে Sync হবে। এতে অহেতুক রি-রেন্ডার হচ্চে,এতে এপ্লিকেশন স্লো হয়ে যাবে।তার চাইতে বরং আমরা চাইল্ড কম্পোনেন্টে যেই ইভেন্ট হ্যান্ডেলারের মাধ্যমে চাইল্ড কম্পোনেন্টের লোকাল স্টেট চেঞ্জ হবে সেই হ্যান্ডেলারের মধ্যেই প্যারেন্ট কম্পোনেন্ট থেকে পাওয়া setter function কল করে দিয়ে একটা রেন্ডার পাসেই চাইল্ড এবং প্যারেন্ট এর স্টেটকে Sync রাখতে পারি। এতে আমাদের কোডটা হবে এমনঃ\nfunction Toggle({ onChange }) {\n    const [isOn, setIsOn] = useState(false);\n    function updateToggle(nextIsOn) {\n        // ✅ Good: Perform all updates during the event that caused them\n        setIsOn(nextIsOn);\n        onChange(nextIsOn);\n    }\n    function handleClick() {\n        updateToggle(!isOn);\n    }\n    function handleDragEnd(e) {\n        if (isCloserToRightEdge(e)) {\n            updateToggle(true);\n        } else {\n            updateToggle(false);\n        }\n    }\n    // ...\n}","passing-data-to-the-parent-চাইল্ড-কম্পোনেন্ট-থেকে-ডাটা-প্যারেন্টে-পাস-করার-জন্য#Passing data to the parent (চাইল্ড কম্পোনেন্ট থেকে ডাটা প্যারেন্টে পাস করার জন্য)":"যখন কোন ডাটা আমদের চাইল্ড কম্পোনেন্টে প্রয়োজন হয় এবং একই সাথে সেম ডাটা প্যারেন্ট কম্পোনেন্টেও প্রয়োজন হয়, তখন অনেকেই যেটা করে চাইল্ড কম্পনেন্টে ডাটা fetch করে সেটা ইফেক্টের মাধ্যমে প্যারেন্টে পাস করার চেষ্টা করে। সেক্ষেত্রে তারা এভাবে করে,\nfunction Parent() {\n    const [data, setData] = useState(null);\n    // ...\n    return <Child onFetched={setData} />;\n}\nfunction Child({ onFetched }) {\n    const data = useSomeAPI();\n    // ❌ Avoid: Passing data to the parent in an Effect\n    useEffect(() => {\n        if (data) {\n            onFetched(data);\n        }\n    }, [onFetched, data]);\n    // ...\n}\nএভাবে করলে রিয়াক্টেড় ইউনি-ডিরেকশনাল ডাটা ফ্লো টা নষ্ট হচ্ছে, সেটা না করে যদি একই ডাটা চাইল্ড এবং প্যারেন্ট দুই জায়গাতেই প্রয়োজন হয় তাহলে ডাটা চাইল্ডে fetch না করে সরাসরি প্যারেন্টে fetch করে প্রপ্স আকারে চাইল্ডে পাঠালেই হয়। সেক্ষেত্রে এভাবে করা যায়।\nfunction Parent() {\n    const data = useSomeAPI();\n    // ...\n    // ✅ Good: Passing data down to the child\n    return <Child data={data} />;\n}\nfunction Child({ data }) {\n    // ...\n}"}},"/reactive-accilarator/React-router-dom":{"title":"React Router Dom","data":{"installation#Installation":"","setup-react-project#Setup React Project":"প্রথমে একটা রিয়াক্ট প্রজেক্ট সেটআপ করতে হবে, রিয়াক্ট প্রজেক্ট Vite দিয়ে সেটআপ করার জন্য নিচের কমান্ড ব্যবাহার করতে হবে, এবং তারপর প্রম্পট গুলো ফলো করে প্রজেক্ট সেটআপ করা লাগবে।\n    npx create-vite@latest\nতারপর, স্ক্রিনে আসা প্রম্পট গুলো ফলো করতে হবে।অথবা আরও একটু সর্টকাট আছে সেটা হলো এই কমান্ড ব্যাবহার করা,\nnpm create vite@latest your-project-name -- --template react\nতারপর, স্ক্রিনে আসা প্রম্পট গুলো ফলো করতে হবে।","add-react-router-dom-to-project#Add React Router Dom to Project":"রিয়াক্ট প্রজেক্টে React Router Dom সেটআপ করতে নিচের কমান্ড দিতে হবে।\nnpm install react-router-dom","adding-a-router#Adding A Router":"প্রথমে একটি ব্রাউজার রাউটার তৈরি করতে হবে এবং আমাদের প্রথম রুট কনফিগার করতে হবে। এটি আমাদের ওয়েব অ্যাপের জন্য ক্লায়েন্ট সাইড রাউটিং এনাবল করবে। একটি browser router বানানো এবং তা কনফিগার করে আমাদের এপ্লিকেশনে রাউটিং এনাবল করতে হলে নিচের স্টেপ ফলো করতে হবে।","একটি-ব্রাউজার-রাউটার-তৈরি-করা#একটি ব্রাউজার রাউটার তৈরি করা।":"এজন্য আমাদেরকে Main.jsx ফাইলে এসে react-router-dom থেকে createBrowserRouter নামে একটি হুক ইম্পোর্ট করতে হবে এবং সেখানে নিচের মতো করে browser router বানাতে হবে।\nimport { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { createBrowserRouter } from \"react-router-dom\";\nimport \"./index.css\";\nconst router = createBrowserRouter([\n    {\n        path: \"/\",\n        element: <div>Home Page</div>,\n    },\n]);\ncreateRoot(document.getElementById(\"root\")).render(\n    <StrictMode>\n        <App />\n    </StrictMode>\n);","তৈরি-করা-ব্রাউজার-রাউটার-টাকে-পুরো-এপ্লিকেশনের-প্রভাইড-করে-দেওয়া#তৈরি করা ব্রাউজার রাউটার টাকে পুরো এপ্লিকেশনের প্রভাইড করে দেওয়া।":"এজন্য আমাদেরকে react-router-dom থেকে RouterProvider নামে একটি কনটেক্সট প্রভাইডার ইম্পোর্ট করতে হবে এবং সেখানে নিচের মতো করে browser router টাকে প্রভাইড করতে হবে।\nimport { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { createBrowserRouter, RouterProvider } from \"react-router-dom\";\nimport \"./index.css\";\nconst router = createBrowserRouter([\n    {\n        path: \"/\",\n        element: <div>Home Page</div>,\n    },\n]);\ncreateRoot(document.getElementById(\"root\")).render(\n    <StrictMode>\n        <RouterProvider router={router} />\n    </StrictMode>\n);\nতাহলেই আমাদের Router সেটআপ করা শেষ এবং আমরা ব্রাউজারে আমাদের প্রথম রাউট টা দেখতে পাবো এবং সেখানে শুধুমাত্র Home Page এই টেক্সটটা দেখতে পাবো।","the-root-route--home-page-route#The Root Route / Home Page Route":"আমরা আমাদের এপ্লিকেশনে একটা / রাউট দেখতে পাচ্ছি যেখানে শুধুমাত্র Home Page এই টেক্সটটা দেখতে পাচ্ছি। এবার আমরা একটা Home Page বা মেইন লে-আউট সেটআপ করবো।সেজন্য প্রথমে আমাদেরকে Home Page বা মেইন লে-আউট এর জন্য আমাদের নিজস্ব কম্পোনেন্ট বানাতে হবে। যেহেতু এইটা / রাউট, তাই আমরা এর নাম দিতে পারি Rootতারপর আমরা আমদের সেই Root লে-আউট টাকে আমাদের / রাউটারে ব্যাবহার করবো।\nimport { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { createBrowserRouter, RouterProvider } from \"react-router-dom\";\nimport \"./index.css\";\nimport Root from \"./pages/Root\";\nconst router = createBrowserRouter([\n    {\n        path: \"/\",\n        element: <Root />,\n    },\n]);\ncreateRoot(document.getElementById(\"root\")).render(\n    <StrictMode>\n        <RouterProvider router={router} />\n    </StrictMode>\n);\nতাহলেই আমরা এবার আমার / রাউটে আমাদের Root লে-আউট এর সবকিছু দেখতে পাবো।","handling-not-found-errors#Handling Not Found Errors":"এখন আমাদের এপ্লিকেশনে শুধুমাত্র একটাই রাউট আছে / রাউট। আমরা যদি এখন URL এ অন্য কোন রাউট দেই, তাহলে আমরা একটা ইরর পেজ দেখতে পাবো। কিন্তু সেটা react-router-dom এর নিজস্ব ডিজাইন, কিন্তু আমরা এই ইররটাকে আমাদের নিজস্ব ইরর পেজ দিয়ে ম্যানেজ করতে চাই,তারজন্য আমাদের প্রথমে একটা ErrorPage বানাতে হবে এবং সেটা রাউটারের errorElement হিসেবে সেট করতে হবে।\nimport { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { createBrowserRouter, RouterProvider } from \"react-router-dom\";\nimport \"./index.css\";\nimport ErrorPage from \"./pages/ErrorPage\";\nimport Root from \"./pages/Root\";\nconst router = createBrowserRouter([\n    {\n        path: \"/\",\n        element: <Root />,\n        errorElement: <ErrorPage />,\n    },\n]);\ncreateRoot(document.getElementById(\"root\")).render(\n    <StrictMode>\n        <RouterProvider router={router} />\n    </StrictMode>\n);\nতাহলেই এবার আমাদের UI তে আমাদের বানানো ইরর পেজ দেখতে পাবোইরর পেজে আমরা react-router-dom থেকে useRouterError নামে একটা হুক ইম্পোর্ট করে ইররের ডিটেইলস দেখতে পারি।\nimport { useRouteError } from \"react-router-dom\";\nexport default function ErrorPage() {\n    const { status, statusText } = useRouteError();\n    return (\n        <div id='error-page'>\n            <h1>Oops!</h1>\n            <p>Sorry, an unexpected error has occurred.</p>\n            <p>\n                {status} | {statusText}\n            </p>\n        </div>\n    );\n}","add-more-route#Add More Route":"আমাদের এপ্লিকেশনে এখন একটাই রাউট আছে /। এবার আমরা চাইলে আমাদের যতগুলো রাউট প্রয়োজন হবে ততগুলা রাউট এড করতে পারি। এজন্য আমাদের যেই রাউট লাগবে সেই রাউটের জন্য প্রয়োজনীয় JSXটা বানিয়ে নিতে হবে । তারপর browser routerএর অ্যারেতে অবজেক্ট আকারে সেই রাউটের path এবং তার element ডিফাইন করে দিতে হবে।\nimport { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { createBrowserRouter, RouterProvider } from \"react-router-dom\";\nimport \"./index.css\";\nimport Contact from \"./pages/Contact\";\nimport ErrorPage from \"./pages/ErrorPage\";\nimport Root from \"./pages/Root\";\nconst router = createBrowserRouter([\n    {\n        path: \"/\",\n        element: <Root />,\n        errorElement: <ErrorPage />,\n    },\n    {\n        path: \"/contacts/:contactId\",\n        element: <Contact />,\n    },\n]);\ncreateRoot(document.getElementById(\"root\")).render(\n    <StrictMode>\n        <RouterProvider router={router} />\n    </StrictMode>\n);\nখেয়াল করুন, আমরা এখানে path: \"/contacts/:contactId\" দিয়েছি। এখানে /:contactId মানে হলো ডাইনামিক রাউট। /contacts এর পর আমরা স্পেসিফিক কোন একটা আইডি এক্সেস করতে চাইলে এভবে ডাইনামিক রাউট সেগমেন্ট ব্যাবহার করতে পারি।","nested-routes#Nested Routes":"আমরা যখন চাই যে, আমাদের এপ্লিকেশনে একটা Root লে-আউট থাকবে এবং সেই লে-আউটের কোন একটা স্পেসিফিক জায়গায় আমাদের অন্যন্য রাউটের কন্টেন্টগুলো ভিসিবল হবে,মানে পুরো এপ্লিকেশনের একটাই লে-আউট থাকবে এবং যখনি রাউট চেঞ্জ হবে শুধুমাত্র সেই রাউট স্পেসিফিক কন্টেন্টগুলো সেই লে-আউট ব্যাবহার করে লে-আউটের কোন একটা অংশে ভিজিবল হবে, তাহলে আমরা নেস্টেড রাউটিং করতে পারি। ধরে নেই আমরা আমদের /contacts রাউটটাকে নেস্টেড রাউট করতে চাচ্ছি। তাহলে আমরা এভাবে করতে পারি।\nimport { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { createBrowserRouter, RouterProvider } from \"react-router-dom\";\nimport \"./index.css\";\nimport Contact from \"./pages/Contact\";\nimport ErrorPage from \"./pages/ErrorPage\";\nimport Root from \"./pages/Root\";\nconst router = createBrowserRouter([\n    {\n        path: \"/\",\n        element: <Root />,\n        errorElement: <ErrorPage />,\n        children: [\n            {\n                path: \"/contacts/:contactId\",\n                element: <Contact />,\n            },\n        ],\n    },\n]);\ncreateRoot(document.getElementById(\"root\")).render(\n    <StrictMode>\n        <RouterProvider router={router} />\n    </StrictMode>\n);\nএক্ষেত্রে আমাদের Root লে-আউটের children হিসেবে সেই রাউটটা ডিফাইন করতে হবে।এবং Root লে-আউটের যেই অংশে সেই লে-আউটের কন্টেন্টগুলো শো করাতে চাই তা ডিফাইন করার জন্য react-router-dom এর <Outlet/>নামক কম্পোনেন্ট ইম্পোর্ট করে সেইটা দিয়ে বুঝিয়ে দিতে হবে।\nimport { Outlet } from \"react-router-dom\";\nexport default function Root() {\n    return (\n        <>\n            {/* all the other elements */}\n            <div id='detail'>\n                <Outlet />\n            </div>\n        </>\n    );\n}","client-side-routing#Client Side Routing":"এতক্ষণ আমদের সকল রাউট ঠিকঠাক কাজ করছিলো,কিন্তু খেয়াল করলে দেখা যাবে যে, যখনি আমরা রাউটিং করছি,তখন আমাদের এপ্লিকেশনের পেজগুলো রিলোড নিচ্ছে, এটা কিন্তু রিয়াক্ট এপ্লিকেশনের বিহেবিয়ার না। তাই আমরা এটাকে Client Side Routing করতে চাইলে আমাদের <a/> ট্যাগের পরিবর্তে react-router-dom এর <Link to=\"\"/> কম্পোনেন্ট ব্যাবহার করতে হবে এর href এর পরিবর্তে to ব্যাবহার করতে হবে।\nimport { Outlet, Link } from \"react-router-dom\";\nexport default function Root() {\n    return (\n        <>\n            <div id='sidebar'>\n                {/* other elements */}\n                <nav>\n                    <ul>\n                        <li>\n                            <Link to={`contacts/1`}>Your Name</Link>\n                        </li>\n                        <li>\n                            <Link to={`contacts/2`}>Your Friend</Link>\n                        </li>\n                    </ul>\n                </nav>\n                {/* other elements */}\n            </div>\n        </>\n    );\n}"}},"/reactive-accilarator/frontend-focus-topic":{"title":"Frontend Focus Topic","data":{"":"That's great! Since you've already learned React and Next.js, you're off to a solid start. To become a well-rounded frontend developer, here are some key areas to focus on next:","1-advanced-javascript#1. Advanced JavaScript":"Deepen your understanding of JavaScript (ES6+).\nLearn about asynchronous programming (Promises, Async/Await).\nStudy closures, event loops, and execution contexts.","2-state-management#2. State Management":"Learn advanced state management tools like Redux, Recoil, or Zustand.\nUnderstand context API more deeply for managing local state.","3-typescript#3. TypeScript":"Since many modern React/Next.js projects use TypeScript, learning this will make your code more robust and reduce bugs.","4-css-and-design-systems#4. CSS and Design Systems":"Explore CSS frameworks like TailwindCSS, Material-UI, or Chakra UI.\nLearn about CSS-in-JS libraries like Styled Components and Emotion.\nStudy responsive design and grid systems (Flexbox, Grid).\nUnderstand design systems and how to create or work with component libraries.","5-testing#5. Testing":"Learn to test your components using Jest, React Testing Library, or Cypress.\nUnderstand the concepts of unit testing, integration testing, and end-to-end testing.","6-version-control--collaboration#6. Version Control & Collaboration":"Improve your understanding of Git and tools like GitHub, GitLab, or Bitbucket.\nLearn about branching strategies, pull requests, and code reviews.","7-performance-optimization#7. Performance Optimization":"Learn about code-splitting, lazy loading, and optimizing images in React/Next.js.\nFocus on Lighthouse, PageSpeed Insights, and tools for optimizing web performance.","8-seo-for-frontend#8. SEO for Frontend":"Dive deeper into Next.js SEO features.\nLearn about server-side rendering (SSR), static site generation (SSG), and dynamic routing.","9-progressive-web-apps-pwa#9. Progressive Web Apps (PWA)":"Learn how to build PWAs, including service workers, caching strategies, and offline functionality.","10-build-tools#10. Build Tools":"Familiarize yourself with Webpack, Babel, Vite, or Parcel.\nUnderstand CI/CD pipelines and how to automate testing, building, and deployment.","11-authentication-and-security#11. Authentication and Security":"Explore OAuth, JWT, and integrating authentication systems (e.g., Firebase Auth, NextAuth).\nLearn about web security essentials (XSS, CSRF, HTTPS, etc.).\nBy working through these topics, you'll significantly enhance your frontend development skills and become more prepared for real-world projects."}},"/reactive-accilarator/git":{"title":"গিট এবং গিটহাব","data":{"গিট-কি-#গিট কি ?":"গিট হলো একটি ভার্সন কনট্রোল টুল।ভার্সন কনট্রোল কি ?ধরুন আপনি আপনার কম্পিউটার এ কোন ডকুমেন্ট লিখছেন,সেখানে হয়তো আজ কিছু লিখছেন আবার হয়তো অন্যদিন কিছু লিখছেন। এভাবে হয়তো আপনার কখনও মনে হলো যে আপনি গত দুইদিন যা লিখেছেন তা হয়তো সঠিক নয়, আপনি তা ডিলিট করে আবার দুই দিন আগে যা লিখেছেন সেই অবস্থায় ফিরত যেতে চান। এক্ষেত্র আপনাকে যেটা করা লাগবে তা হলো এই দুইদিনের সমস্ত লিখা মুছে ফেলতে হবে। এখন এই অবস্থায় আপনার যদি মনে না থাকে যে আপানর ঠিক কোন পর্যন্ত মুছা উচিত বা দুইদিন আগে ঠিক কতটুকু লেখা হয়েছিলো,তখন আপনি কি করবেন? ঠিক এই কাজটায় গিট হেল্প করে থাকে। গিট কোন ফাইলের প্রতিটা চেঞ্জেস গুলোকে মনিটরিং করে বা ট্র্যাক রাখে এবং প্রতিটা চেঞ্জেস গুলোকে ভার্সনাইজ করে। যাতে আপনি যেকোন সময় যেকোনো ভার্সনে সুইচ করতে পারেন ।","গিটের-কিছু-প্রয়োজনীয়-কমান্ড-যা-আমাদের-গিটের-লোকাল-রিপজিটরিতে-ফাইল-ম্যানেজ-করতে-প্রয়োজন-হবে#গিটের কিছু প্রয়োজনীয় কমান্ড যা আমাদের গিটের লোকাল রিপজিটরিতে ফাইল ম্যানেজ করতে প্রয়োজন হবে।":"গিট ইনিশিয়ালাইজ করা\n git init\nগিট এর স্ট্যাটাস চেক করা\ngit status\nফাইলকে গিটের ট্রাক করার জন্য স্টেজ এ উঠানো\ngit add <filename> //For stage any specific file\nor\ngit add --all // if you want to add all files\nor\ngit add .  // if you want to add all files in the current working directory\nকমিট করা\ngit commit -m \"<commit massage>\"\nগিট লগ চেক করা\ngit log\nor\ngit log --oneline\nএকটা কমিট থেকে অন্য কমিটের অবস্থায় ফিরে যাওয়া\ngit reset --hard <commit id>\nগিটের প্রতিটা চেঞ্জের রেফারেন্স সহ লগ দেখার জন্য\ngit reflog\nগিটের ট্র্যাক থেকে কোন ফাইল রিমূভ করা\ngit rm <filename>\nব্রাঞ্চ তৈরী করা\ngit branch <branch name eg: bugfix/fixname >\nব্রাঞ্চ লিস্ট দেখা\ngit branch --list\nএক ব্রাঞ্চ থেকে অন্য ব্রাঞ্চ এ সুইচ করা\ngit switch <branch name >\nএক ব্রাঞ্চের কোড অন্য ব্রাঞ্চে মার্জ করা\nএক্ষেত্রে যেই ব্রাঞ্চে অন্য ব্রাঞ্চের কোড আনতে হবে,প্রথমে git switch <branchname> করে প্রথমে সেই ব্রাঞ্চে যেতে হবে। তারপর কমান্ড দিতে হবে।\ngit merge <branch name >\nগিট থেকে ব্রাঞ্চ ডিলিট করা\ngit branch -d <branch name >\nব্রাঞ্চ নেম পরিবর্তন করতে চাইলে\n এক্ষেত্রে যেই ব্রাঞ্চের নাম পরিবর্তন করতে হবে আমাদেরকে প্রথমে git switch <branchname> করে প্রথমে সেই ব্রাঞ্চে যেতে হবে। তারপর কমান্ড দিতে হবে। \ngit branch -m <updated branch name >\nগিট স্ট্যাস করা (আনকমিটেড কাজ গিটের ড্রাফট এ সেভ রাখা)\ngit stash\nগিট স্ট্যাস লিস্ট চেক করা\ngit stash list\nগিটের স্ট্যাস এ কি কি সেভ রাখা হয়েছিল তা দেখতে\ngit stash show -p\nগিটের স্ট্যাস এপ্লাই করার জন্য\ngit stash apply <statsh id>\nor\ngit stash pop\nকোন ফাইল ভুলবশত গিটে এড করে ফেললে বা কমিট করার পর যদি মনে হয় ফাইলটা গিট থেকে ইগনোর করতে হবে তাহলে:","১ম-স্টেপঃ#১ম স্টেপঃ":"একটা .gitignore ফাইল বানাতে হবে এবং তাতে উক্ত ফাইলের নাম এড করা লাগবে ।","২য়-স্টেপঃ#২য় স্টেপঃ":"git rm --cached <filename>\nগিটহাব বা রিমোট রিপোজিটরিতে ফাইল এড করা বা পুশ করার জন্যঃ","১ম-স্টেপঃ-1#১ম স্টেপঃ":"git remote add <origin name eg: orgin or something > <github repository link>\nexample:git remote add origin git@github.com:Deveripon/reactive-accelarator.git","২য়-স্টেপঃ-1#২য় স্টেপঃ":"git push -u <origin name> <branch name>\nexample:git push -u origin main\nরিমোট রিপোজিটরি থেকে পুল করা\ngit pull"}},"/reactive-accilarator":{"title":"Index","data":{"কিভাবে-এই-কোর্স-থেকে-সর্বোচ্চ-ফলাফল-পেতে-পারি-#কিভাবে এই কোর্স থেকে সর্বোচ্চ ফলাফল পেতে পারি ?":"এই কোর্স থেকে সবচেয়ে ভালো ফলাফল পেতে হলে আমাদের নিচের পয়েন্টগুলো অবশ্যই মাথায় রাখতে হবে।\nধৈর্যঃ\nরিডিং পড়ার অভ্যাস\nভিডিও স্কিপ করা যাবেনা\nকুইজে অংশগ্রহণ\nআসাইন্মেন্ট জমা দেয়া\nনিজেকে পুশ করা ও মোটিভেটেড রাখা\nনিঃসংকোচে আস্ক ফর হেল্প\nএটেন্ড লাইভ সেশনস\nলজিকাল হতে হবে"}},"/reactive-accilarator/javascript-refresher":{"title":"Advanced JavaScript","data":{"scope-in-javascript#Scope in JavaScript":"","primitive-and-reference-types-value#Primitive and Reference types Value":"","primitive#Primitive":"প্রিমিটিভ এর বাংলা অর্থ হলো আদিম। জাভাস্ক্রিপ্টে যেসব DATATYPE আছে যেমনঃ\nString\nNumber\nBoolean\nNull\nUndefined\nএইগুলো হলো জাভাস্ক্রিপ্টের মূল বা একক। এগুলো ব্যাবহার করে অন্যান্য ডাটা বানানো হয়। এগুলোকে বলা হয় প্রিমিটিভ ডাটা বা ভ্যালু ।","references#References":"জাভাস্ক্রিপ্টের Array এবং Object কে বলা হয় রেফারেন্স টাইপ ডাটা বা ভ্যালু ।","প্রিমিটিভ-এবং-রেফারেন্স-টাইপ-ডাটার-পার্থক্যঃ#প্রিমিটিভ এবং রেফারেন্স টাইপ ডাটার পার্থক্যঃ":"প্রিমিটিভ এবং রেফারেন্স টাইপ ডাটার মধ্যে মূল যেই পার্থক্য রয়েছে তা হলো এর ডাটার বিহেবিয়ার নিয়ে। যেমন নিচে উদাহরণের মাধ্যমে বুঝানো হলোঃ","primitive-1#Primitive":"প্রিমিটিভ ডাটা শুধুমাত্র ভ্যালুটা শেয়ার করে। ডাটার রেফারেন্স শেয়ার করেনা।","reference#Reference":"এখানে a কে যখন b দ্বারা রি-এসাইন করা হয়েছে তখন স্বাভাবিক ভাবেই আ এর ভ্যালু চেঞ্জ হয়ে b এর যেই ভ্যালু ছিল তা হয়ে গিয়েছে। কিন্তু নিচে যখন b এর ভ্যালু চেঞ্জ করা হয়েছে সেই চেঞ্জটা a তেও এসে প্রভাব ফেলেছে এবং a সহ চেঞ্জ হয়ে গেছে। কারণ এখানে a তে যখন b এসাইন করা হয়েছিল তখন a তে b এর রেফারেন্স সহ চলে গেছিল,তাই যেকোন একটা কে চেঞ্জ করলেই দুইটাই চেঞ্জ হয়ে যাচ্ছে।এখানে যেই বিষয়টা হয়েছে তা হলোঃa আর b যখন ডিফাইন করা হয়েছে তখন মেমরিতে দুইটা Array এলোকেটেড করা হয়েছে এবং Array দুটি তাদের যেই Variables এর নাম a এবং b তার দিয়ে পয়েন্ট করে আছে। কিন্তু যখন a = b করা হয়েছে তখন দুইটা পয়েন্টার এক হয়ে b এর ভ্যালু থেকে a আর b এর দিকে পয়েন্ট হয়ে গেছে। তাই এখন a অথবা b যেইটাই চেঞ্জ করা হউক না কেন তা দুইটাকেই চেঞ্জ করবে।এটাই হলো primitives আর References ভ্যালুর মধ্যে মূল পার্থক্য ।","shallow-copy-vs-deep-copy#Shallow Copy Vs Deep Copy":"জাভাস্ক্রিপ্টে \"শ্যালো কপি\" (Shallow Copy) এবং \"ডিপ কপি\" (Deep Copy) হল দুটি আলাদা প্রক্রিয়া যেগুলো ব্যবহার করে একটি Object বা Array'র কপি তৈরি করা হয়। তবে এদের মধ্যে বড় পার্থক্য হচ্ছে কিভাবে ডেটা কপি করা হয়। নিচে প্রতিটি কনসেপ্ট বিস্তারিতভাবে ব্যাখ্যা করছি:","শ্যালো-কপি-shallow-copy#শ্যালো কপি (Shallow Copy)":"শ্যালো কপিতে কেবলমাত্র অবজেক্টের প্রথম লেভেলের ভ্যালুগুলি কপি করা হয়। এর মানে হলো, যদি অবজেক্ট বা আরে'র মধ্যে নেস্টেড অবজেক্ট থাকে, তাহলে সেগুলি রেফারেন্স হিসেবে কপি হয়। অর্থাৎ, নেস্টেড অবজেক্ট বা আরে'র জন্য একটি রেফারেন্স তৈরি হয়, নতুন অবজেক্টে একই ডেটা শেয়ার করে।","উদাহরণ#উদাহরণ:":"let originalArray = [1, 2, { a: 3, b: 4 }];\n// শ্যালো কপি তৈরি করা\nlet shallowCopy = [...originalArray];\nconsole.log(shallowCopy); // [1, 2, { a: 3, b: 4 }]\n// নেস্টেড অবজেক্ট পরিবর্তন করা\nshallowCopy[2].a = 10;\nconsole.log(originalArray); // [1, 2, { a: 10, b: 4 }]\nconsole.log(shallowCopy); // [1, 2, { a: 10, b: 4 }] // নেস্টেড অবজেক্ট রেফারেন্স একারে কপি হওয়ার কারনে কপি ডাটাতে চেঞ্জ করলেও তা মেইন ডাটাকেও চেঞ্জ করে দিয়েছে।\nএই উদাহরণে দেখা যাচ্ছে যে, originalArray এবং shallowCopy একই নেস্টেড অবজেক্ট শেয়ার করছে। যখন shallowCopy[2].a পরিবর্তন করা হয়, তখন মূল অবজেক্টেও পরিবর্তন ঘটে। এটি শ্যালো কপির একটি সীমাবদ্ধতা।","শ্যালো-কপি-তৈরি-করার-পদ্ধতি#শ্যালো কপি তৈরি করার পদ্ধতি:":"Spread Operator: let copy = [...array];","ডিপ-কপি-deep-copy#ডিপ কপি (Deep Copy)":"ডিপ কপিতে একটি অবজেক্টের প্রতিটি লেভেলের কপি তৈরি করা হয়, এমনকি নেস্টেড অবজেক্টেরও আলাদা কপি করা হয়। এর ফলে মূল অবজেক্টের কোনো পরিবর্তন নতুন কপি অবজেক্টকে প্রভাবিত করে না এবং বিপরীতও ঘটে না।","উদাহরণ-1#উদাহরণ:":"let originalArray = [1, 2, { a: 3, b: 4 }];\n// ডিপ কপি তৈরি করা (JSON পদ্ধতি ব্যবহার করে)\nlet deepCopy = JSON.parse(JSON.stringify(originalArray));\nconsole.log(deepCopy); // [1, 2, { a: 3, b: 4 }]\n// নেস্টেড অবজেক্ট পরিবর্তন করা\ndeepCopy[2].a = 10;\nconsole.log(originalArray); // [1, 2, { a: 3, b: 4 }]\nconsole.log(deepCopy); // [1, 2, { a: 10, b: 4 }]\nএখানে দেখা যাচ্ছে যে, deepCopy[2].a পরিবর্তন করার পরেও originalArray এর নেস্টেড অবজেক্ট অপরিবর্তিত রয়েছে। কারণ, ডিপ কপিতে নেস্টেড অবজেক্টের নতুন কপি তৈরি হয়।","ডিপ-কপি-তৈরি-করার-পদ্ধতি#ডিপ কপি তৈরি করার পদ্ধতি:":"JSON.parse(JSON.stringify(obj)): সহজ পদ্ধতি, তবে ফাংশন ও undefined হ্যান্ডেল করতে পারে না।\nLodash লাইব্রেরির cloneDeep মেথড Lodash একটি জনপ্রিয় জাভাস্ক্রিপ্ট লাইব্রেরি, যা অনেক ধরনের ইউটিলিটি ফাংশন সরবরাহ করে। cloneDeep হল একটি বিশেষ মেথড যা ডিপ কপি তৈরি করতে পারে।\nউদাহরণ:প্রথমে lodash ইনস্টল করতে হবে:\n npm i --save lodash\nতারপর\nconst _ = require(\"lodash\");\nlet originalObject = { a: 1, b: { c: 2, d: 3 } };\nlet deepCopiedObject = _.cloneDeep(originalObject);\ndeepCopiedObject.b.c = 10;\nconsole.log(originalObject); // { a: 1, b: { c: 2, d: 3 } }\nconsole.log(deepCopiedObject); // { a: 1, b: { c: 10, d: 3 } }\nLodash এর cloneDeep মেথড সমস্ত ডেটা টাইপ এবং নেস্টেড অবজেক্ট সঠিকভাবে হ্যান্ডেল করতে পারে। এটি ফাংশন, তারিখ, Map, Set এবং অন্যান্য জটিল ডেটা স্ট্রাকচার হ্যান্ডেল করার ক্ষেত্রে খুবই কার্যকর।","শ্যালো-কপি-বনাম-ডিপ-কপি-পার্থক্য#শ্যালো কপি বনাম ডিপ কপি পার্থক্য:":"শ্যালো কপি\tডিপ কপি\tশুধুমাত্র প্রথম লেভেলের কপি করে।\tপ্রতিটি লেভেলের জন্য নতুন কপি তৈরি করে।\tনেস্টেড অবজেক্টগুলো রেফারেন্স হিসেবে কপি হয়।\tনেস্টেড অবজেক্টগুলোর সম্পূর্ণ নতুন কপি হয়।\t\nএই দুই ধরনের কপির মধ্যে পার্থক্য নির্ভর করে আপনার প্রয়োজনের উপর।","this-এর-ব্যাবহার-কোথায়-এবং-কিভাবে-#this এর ব্যাবহার। কোথায় এবং কিভাবে ।":"","implicit-binding#Implicit Binding":"👉রুলসঃ দেখতে হবে যে,ফাংশন কল হয়েছে কোথায়, যেখানে কল হয়েছে তার সামনে কি কোন ডট আছে কিনা,যদি থাকে তাহলে তার সামনে কি আছে। যদি কিছু থাকে তাহলে সেটাই হলো this । এক্ষেত্রে এক্সেপ্সন হলো this শুধু নরমাল ফাংশনেই কাজ করবে। কিন্তু Arrow ফাংশন this বলে কিছু চিনবেনা।উদাহরণঃ\nlet player = {\n    name: \"Mashrafe\",\n    age: 38,\n    printPlayerName: function () {\n        console.log(this.name); // এখানে this দিয়ে `player` অবজেক্টটাকে পয়েন্ট করা হয়েছে।\n    },\n};\nplayer.printPlayerName();","explicitly-binding#Explicitly Binding":"","call#.call()":"👉 কখনও কখনও বাহিরের কোন ফাংশনকে অন্য কোন অবজেক্ট দিয়ে কল করার প্রয়োজন হয় । সেক্ষেত্রে সিনট্যাক্স হয় এরকমঃ\nfunction printName() {\n    // এটা একটা গ্লোবাল ফাংশন\n    console.log(this.name);\n}\nlet player = {\n    name: \"Sakib\",\n    age: 33,\n};\nprintName.call(player); // এই গ্লোবাল ফাংশনটাকে `player` অবজেক্ট দিয়ে `.call()` করা হয়েছে ।\nএক্ষেত্রে .call() এর ভিতরে যা পাস করা হয়, this সেটাকেই পয়েন্ট করে। এক্ষেত্রে explicitly বলে দেয়া হচ্ছে যে this কি হবে ।","apply#.apply()":"👉 .apply() আর .call() একই কাজ করে। সবকিছুই সেম। তবে.apply() তার second parameter এ Array নিতে পারে । যেকানে .call() Array নিতে পারেনা।\nfunction printPlayerName() {\n    console.log(`${this.name} is ${vertue} `);\n}\nlet mashrafe = {\n    name: \"Mashrafe\",\n    age: 36,\n};\nlet vartu1 = \"Honest\";\nlet vartu2 = \"Captain\";\nlet vartu3 = \"Leader\";\nlet vertue = [vartu1, vartu2, vartu3];\nprintPlayerName.apply(mashrafe, vertue);","bind#.bind()":"👉 .bind() ও .call() এর মতোই সেম কাজ করে। তবে পার্থক্য হলো .bind() ফাংশনটিকে সরাসরি কল না করে দিয়ে ফাংশনের একটা নতুন ইন্সটেন্স রিটার্ন করে। এবং সেই ইন্সটেন্সকে যেই ভেরিয়েবলে রাখা হয় সেই ভেরিয়েবল দ্বারা কল করতে হয়।উদাহরনঃ\nfunction printAPlayerName() {\n    console.log(this.name);\n}\nlet bdPlayer = {\n    name: \"Ashraful\",\n    age: 39,\n};\nlet printFunction = printAPlayerName.bind(bdPlayer);\nprintFunction();","itarables-কি-#Itarables কি ?":"Itarables বলতে মূলত সেই সমস্ত জিনিস বা অবজেক্ট কে বোঝায়,যেগুলোর মধ্যে দিয়ে লুপ eg: for...of করে স্টেপ বাই স্টেপ যাওয়া যায়। যেমনঃ Array,String,Map,Setটেকনিক্যালি বললে, যেসব অবজেক্টের প্রোটোটাইপের ভিতরে symbol.itarator প্রপার্টি রয়েছে সেটাই itarable symbol.itarator এর মাধ্যমেই জাভাস্ক্রিপ্ট ডিফাইন করে যে, কোনটা itarable আর কোনটা নয় ।\nMap,Set বলতে এখানে জাভাস্ক্রিপ্ট এর Map Set ডাটা স্ট্রাকচার কে\nবুঝানো হয়েছে","itarator-বলতে-কি-বুঝায়-#itarator বলতে কি বুঝায় ?":"itarable অবজেক্টকে যার দ্বারা itarate করা যায়,সেটাই হলো itarator","itarating-বলতে-কি-বুঝায়-#itarating বলতে কি বুঝায় ?":"itarating বলতে মূলত Itarables অবজেক্টগুলোকে লুপ করে স্টেপ বাই স্টেপ যাওয়ার যেই প্রসেস সেটাকে বুঝায় । যখন itarate করা হয় তখন সেটা হলো itarating","array-কে-itarate-করা-#Array কে itarate করা ।":"const arr = [1, 2, 3, 4, 5, 6, 7];\nfor (item of arr) {\n    console.log(item);\n}\n//Output: 1 2 3 4 5 6 7","string-কে-itarate-করা-#String কে itarate করা ।":"const str = \"Bangladesh\";\nfor (character of str) {\n    console.log(character);\n}\n// Output : B a n g l a d e s h\nজাভাস্ক্রিপ্ট হলো সিঙ্গেল থ্রেডেড প্রোগ্রামিং ল্যাঙ্গুয়েজ"}},"/reactive-accilarator/React-js/module-3/passing-data-deeply-with-context":{"title":"Passing Data Deeply with Context","data":{"passing-data-deeply-with-context#Passing Data Deeply with Context":"সাধারণত আমরা প্যারেন্ট কম্পোনেন্ট থেকে ডাটা চাইল্ড কম্পোনেন্টে Props এর মাধ্যমে পাস করে থাকি। কিন্তু যদি এমন এমন হয় যে আমরা যেই কম্পোনেন্টে ডাটা পাস করতে চাঁচছিসে কম্পোনেন্টটা কম্পোনেন্ট ট্রি এর অনেক ভিতরে নেস্টেড অবস্থায় রয়েছে, সেই ক্ষেত্রে আমাদের ডাটা কে সেই কাঙ্খিত কম্পোনেন্টে পাঠানোর জন্য আমাদের অনেকগুলো কম্পনেন্টকে শুধুমাত্র একটা কেরিয়ার হিসেবে ব্যাবহার করতে হচ্চে,এবং যেই কম্পোনেন্টের সেই ডাটা-টি দরকার নেই সেখানেও আমাদের ডাটা পাস করতে হচ্ছে। এইযে এভাবে এক কম্পোনেন্ট থেকে অন্য কম্পোনেন্টে ডাটা পাস করতে হচ্ছে শুধুমাত্র ডাটাকে কাঙ্খিত কম্পোনেন্টে পৌঁছানোর জন্য, এটাকে বলা হয় Props Drilling।তাহলে আমরা বুঝতে পারছি যে, এভাবে শুধুমাত্র কেরিয়ার হসেবে এতগুলো কম্পোনেন্টকে ব্যবহার করে ডাটাকে একটা নির্দিষ্ট কম্পোনেন্টে নিয়ে যাওয়া এটা খুবই ঝামেলার এমনকি অনেকসময় এটা বাগ তৈরি করতেও পারে। আর এই Props Drilling সমস্যার সমাধান করার জন্যই useContext এসেছে।","context-is-an-alternative-to-passing-props#Context is an alternative to passing props":"Context হলো Props Drilling এর অল্টারনেটিভ। Context এর সাহায্যে আমরা যেসকল ডাটা কোন নেস্টেড কম্পোনেন্ট এ পাঠাতে চাই, সেগুলোকে আমরা একটা আলাদা জায়গায় মেনেজ করে Context এর Provider এর মাধ্যমে কমোনেন্টের কাছে পাঠিয়ে দিতে পারি।","how-to-use-context#How to use Context":"আমরা তিনটা স্টেপ ফলো করে useContext হুক ব্যাবহার করতে পারি।\nকনটেক্সট তৈরি করা (Create a Context)\nপ্রভাইডারের মাধ্যমে কনটেক্সট এর ডাটা প্রভাইড করা (Provide Context data by provider)\nকম্পোনেন্টের ভিতর কনটেক্সট ব্যাবহার করা (Use Context in Component)","কনটেক্সট-তৈরি-করা-create-a-context#কনটেক্সট তৈরি করা (Create a Context)":"প্রথমে আমাদের এভাবে একটি কনটেক্সট তৈরি করতে হবে ।\nimport {createContext} from \"react\"\nexport const CounterContext = createContext(0)\nআমরা এখানে একটা কাউন্টার এপ্লিকেশনের জন্য Context তৈরি করে নিয়েছি এবং Context এর ডিফল্ট ভ্যালু দিয়েছি 0","প্রভাইডারের-মাধ্যমে-কনটেক্সট-এর-ডাটা-প্রভাইড-করা-provide-context-data-by-provider#প্রভাইডারের মাধ্যমে কনটেক্সট এর ডাটা প্রভাইড করা (Provide Context data by provider)":"তারপর যেই কম্পোনেন্টে আমরা Context এর ভ্যালু এক্সেস করতে চাই তার প্যারেন্ট কম্পোনেন্ট কে Context.Provider দিয়ে wrap করে দিতে হবে, এবং ভ্যালু হিসেবে যেসব ডাটা পাঠানো দরকার সেগুলো value={} Attribute এর মাধ্যমে পাস করে দিতে হবে।\nimport { CounterContext } from \"./counterContext.js\";\nconst countValue = 3;\nexport default function App() {\n    return (\n        <section className='section'>\n            <CounterContext.Provider value={countValue}>\n                {children}\n            </CounterContext.Provider>\n        </section>\n    );\n}","কম্পোনেন্টের-ভিতর-কনটেক্সট-ব্যাবহার-করা-use-context-in-component#কম্পোনেন্টের ভিতর কনটেক্সট ব্যাবহার করা (Use Context in Component)":"এরপর আমরা যেই কম্পোনেন্ট এ আমাদের ডাটা প্রয়োজন হবে সেই কম্পোনেন্ট এ useContext কল করে ডাটা এক্সেস করতে পারি।\nimport { useContext } from \"react\";\nconst countValue = useContext();\nexport default function App() {\n    return (\n        <div>\n            <h1> Count Value is : {countValue}</h1>\n        </div>\n    );\n}\nএভাবে আমরা যেই পেরেন্টকে Context.Provider দিয়ে wrap করে দিব তার সকল চাইল্ড কম্পোনেন্ট থেকে আমরা Context এর ডাটা এক্সেস করতে পারবো।","using-and-providing-context-from-the-same-component#Using and providing context from the same component":"আগের উদাহরণে আমরা দেখেছিলাম যে আমরা প্যারেন্ট কম্পোনেন্টে Context.Provider দিয়ে ডাটা পাস করছিলাম এবং চাইল্ড কম্পোনেন্টে useContext ব্যাবহার করার মাধ্যমে ডাটা এক্সেস করতে পারছিলাম,আমরা কিন্তু চাইলে একই কম্পোনেন্টে useContext ব্যাবহার করে ডাটা ধরতেও পারি,আবার সেই কম্পোনেন্ট থেকেই আবার ডাটা চাইল্ড কম্পোনেন্ট এ পাঠাতেও পারি।\nimport { CounterContext } from \"./counterContext.js\";\nimport { useContext } from \"react\";\nexport default function App() {\n    const count = useContext(CounterContext);\n    return (\n        <section className='section'>\n            <CounterContext.Provider value={count+1}>\n                {children}\n            </CounterContext.Provider>\n        </section>\n    );\n}","context-passes-through-intermediate-components-or-nestating-multiple-context#Context passes through intermediate components or Nestating multiple Context":"আমাদের যদি একাধিক Context থাকে এবং তা যদি আমাদের একই কম্পোনেন্টে ব্যবাহার করতে হয় তাহলে আমরা তা এভাবে নেস্টেড করতে পারি।\nimport { CounterContext } from \"./counterContext.js\";\nimport { OtherContext } from \"./otherContext.js\";\nimport { useContext } from \"react\";\nexport default function App() {\n    const count = useContext(CounterContext);\n    return (\n        <section className='section'>\n            <CounterContext.Provider value={count+1}>\n                <OtherContext.Provider value={something}>\n                    {children}\n                </OtherContext.Provider>\n            </CounterContext.Provider>\n        </section>\n    );\n}\nএখানে এইযে আমরা একটি Context কে অন্য আরেকটি দিয়ে Nested করেছি এতে কিন্তু একটার কারণে অন্যটায় কোন এফেক্ট পরবেনা।","before-you-use-context-কনটেক্সট-ব্যাবহার-করার-আগে-আমদের-যে-বিষয়গুলো-অবশ্যই-মাথায়-রাখতে-হবে#Before you use context (কনটেক্সট ব্যাবহার করার আগে আমদের যে বিষয়গুলো অবশ্যই মাথায় রাখতে হবে)":"Context এর সহজ ব্যবাহার এবং বার বার Props পাস করার ঝামেলা থেকে বাচার জন্য ম্যক্সিমাম টাইম আমাদের Context ব্যাবহার করার ইচ্ছা করতে পারে। কিন্তু শুধুমাত্র কিছু কম্পোনেন্টে ডাটা পাস করার ঝমেলা থেকে বাচার জন্য কখনই Context ব্যাবহার করা উচিত না।আমাদের এপ্লিকেশনের শুরুতে আমরা নিচের এর দুইভাবে কনটেক্সট ব্যাবহার ছাড়া কাজ করতে পারি।\nStart by passing props (প্রপ্স পাস করে শুরু করা) যদি আমদের কম্পোনেন্ট মারাত্মক লেভেলের কমপ্লেক্স না হয় তাহলে আমাদের Props পাস করেই কাজ করা উচিত। এতে যতগুলো প্রপ্স পাস করা লাগে লাগুক,এটা মোটেও কোন সমস্যা না।\nExtract components and pass JSX as children (চিলড্রেন প্রপ আকারে JSX পাস করে কম্পোনেন্টের নেস্টং কমিয়া আনা) আমরা যদি চিলড্রেন প্রপ এর ব্যাবহার বাড়িয়ে খুব সুন্দর করে আমদের কম্পোনেন্টগুলোকে কম্পোস করতে পারি,তাহলে দেখা যাবে যে আমদের কম্পোনেন্টগুলোর নেস্টিং অনেক কমে এসেছে, এবং আমরা খুব সহজেই ডাটা পাস করতে পারছি।","use-cases-for-context-কখন-কখন-context-ব্যাবহার-করা-উচিত#Use cases for context (কখন কখন Context ব্যাবহার করা উচিত)":"Context কে যখন তখন যেকোন জায়গায় ব্যাবহার করা উচিত না। যদি এমন কোন ডাটা হয় যেটা আমদের পুরো এপ্লিকেশনের যেকোন জায়গায় যখন তখন লাগতে পারে, প্রায় সকল কম্পোনেন্টেই ডাটার প্রয়োজন হচ্ছে, সেক্ষেত্রে মরা Context ব্যাবহারের কথা ভাবতে পারি। তাছাড়াও,\nTheming আমদের এপ্লকেশনে কোন ব্যাবহার হবে,বা ইউজারের ইন্টারেকশনের কিভাবে থিম ম্যানেজ হবে এজন্য আমাদের থিম এর ডাটাটা কম্পোনেন্ট এর যেকোন জায়গায় ব্যাবহার হতে পারে, তাই Theming এর ক্ষেত্রে Context ব্যাবহার হতে পারে।\nAuthentication এপ্লিকেশনের বিভিন্ন জায়গা থেকে আমদের ইউজারের ইনফরমেশন বা অথেনটিকেশন এর ডাটা প্রয়োজন হতে পারে,তাই Authentication ম্যানেজ করার জন্য Context ব্যাবহার করা যেতে পারে।\nRouting রাউটিং এর জন্য বেশিরভাগ লাইব্রেরিগুলোই বিহাইন্ড দ্যা সিন Context ব্যবাহার করে থাকে।\nComplex State with Reducer যখন আমদের এপ্লিকেশনের অনেক কমপ্লেক্স লজিক আমাদের ম্যানেজ করা লাগবে এবং তা কম্পোনেন্ট এর অনেক ডীপলি নেস্টেড কম্পোনেন্ট এ পাস করা লাগবে তখন useREducer হুক এর সাথে useContext ব্যাবহার করা যেতে পারে।"}},"/reactive-accilarator/React-js/module-3/scaling-up-with-reducer-and-context":{"title":"Scaling up with Reducer and Context","data":{"scaling-up-with-reducer-and-context#Scaling Up with Reducer and Context":"reducer আমদের কম্পোনেন্ট এর কমপ্লেক্স স্টেট লজিকগুলোকে কম্পোনেন্ট থেকে আলাদা করে একটা ফাংশনের ভিতরে ম্যানেজ করতে দেয়। এবং Context আমাদের props drilling ছাড়াই ডিপলি ডাটা পাস করতে দেয়। আমরা reducer এবং Context দুইটাকে একসাথে কমবাইন করে কমপ্লেক্স কম্পোনেন্টগুলোকে অনেক সিম্পল এবং সুন্দর করতে পারি।","combining-a-reducer-with-context#Combining a reducer with context":"আমরা তিনটা স্টেপে Context এবং Reducer কে একসাথে করে ব্যাবহার করে এপ্লিকেশনের যেকোন কম্পোনেন্ট এ ডাটা পাস করতে পারি।\nCreate the context.\nCreate a Reducer and Provide the state and dispatch via Provider\nUse context anywhere in the tree.","create-the-context-একটি-কনটেক্সট-তৈরি-করা#Create the context (একটি কনটেক্সট তৈরি করা)":"একটা আলাদা ফাইলে একটি কনটেক্সট তৈরি করে নিতে হবে এবং তা এক্সপোর্ট করে দিতে হবে যাতে অন্যান্য ফাইল থেকে তা ইম্পোর্ট করে কাজ করা যায়।\nimport {createContext} from \"react\"\nconst CounterContext = createContext(0)\nexport default CounterContext","create-a-reducer-and-provide-the-state-and-dispatch-via-provider-একটি-রিডিওসার-তৈরি-করতে-হবে-এবং-রিডিওসারের-state-এবং-dispatch-ফাংশন-প্রভাইডারে-মাধ্যমে-প্রভাইড-করা#Create a Reducer and Provide the state and dispatch via Provider (একটি রিডিওসার তৈরি করতে হবে এবং রিডিওসারের state এবং dispatch ফাংশন প্রভাইডারে মাধ্যমে প্রভাইড করা)":"আমাদেরকে একটি রিডিউসার বানাতে হবে সেই রিডিওসারের state এবং dispatch ফাংশন যেগুলো আমাদের কম্পোনেন্টের দরকার পরবে সেগুলো আমরা যেই কম্পোনেন্ট ট্রি তে ডাটা পাস করবো তাদের মেইন প্যারেন্টে পাস করবো, এতে সকল নেস্টেড চাইল্ড কম্পোনেন্ট সেই ডাটা এক্সেস করতে পারবে।কিভাবে Reducer বানাতে হয় তা না জানলে এখানে ক্লিক করুন\n    import React from 'react'\n    import Counter from \"./Counter\"\n    import counterReducer from \"./CounterReducer.js\"\n    import CounterContext from \"./CounterContext.js\"\n    const App = () => {\n    const initialState = 0\n    const [count,dispatch] = useReducer(counterReducer,initialState)\n      return (\n        <div>\n        <CounterContext.Provider value={{count,dispatch}}>\n          <Counter/>\n        </CounterContext.Provider>\n        </div>\n      )\n    }\n    export default App\n       export default function Counter(){\n      return <button>\n          <h1> Count : 0</h1>\n          <button>Incriment</button>\n          <button>Decriment</button>\n      </>\n   }\n   import {createContext} from \"react\"\n    const CounterContext = createContext(0)\n    export default CounterContext\nexport const counterReducer = (state, action) => {\nswitch (action.type) {\n    case \"INCRIMENT\": {\n        return state + 1;\n    }\n    case \"DECRIMENT\": {\n        return state - 1;\n    }\n    default: {\n        return state;\n    }\n}\n};","use-context-anywhere-in-the-treeকম্পোনেন্ট-ট্রি-এর-যেকোন-জায়গায়-কনটেক্সট-ব্যাবহার-করে-ডাটা-রিসিভ-করা-#Use context anywhere in the tree.(কম্পোনেন্ট ট্রি এর যেকোন জায়গায় কনটেক্সট ব্যাবহার করে ডাটা রিসিভ করা )":"এই স্টেপে আমাদের যেসকল কম্পোনেন্টে ডাটা প্রয়োজন হবে সেখানে সেখানে আমরা useContext এর মাধ্যমে ডাটা রিসিভ করতে পারবো। এই উদাহরণের সাপেক্ষে আমাদের শুধুমাত্র Counter কম্পোনেন্টে ডাটা প্রয়োজন, তাই আমরা এখন Counter কম্পোনেন্ট থেকে ডাটা রিসিভ করে ব্যাবহার করবো।\n   import {useContext} from \"react\"\n   import CounterContext from \"./CounterContext.js\"\n   export default function Counter(){\n       const {state,dispatch} = useContext(CounterContext)\n      return <button>\n          <h1> Count : {count}</h1>\n          <button onClick={()=> dispatch({type:\"INCRIMENT\"})}>Incriment</button>\n          <button onClick={()=> dispatch({type:\"DECRIMENT\"})}>Decriment</button>\n      </>\n   }\n    import React from 'react'\n    import Counter from \"./Counter\"\n    import counterReducer from \"./CounterReducer.js\"\n    import CounterContext from \"./CounterContext.js\"\n    const App = () => {\n    const initialState = 0\n    const [count,dispatch] = useReducer(counterReducer,initialState)\n      return (\n        <div>\n        <CounterContext.Provider value={{count,dispatch}}>\n          <Counter/>\n        </CounterContext.Provider>\n        </div>\n      )\n    }\n    export default App\n   import {createContext} from \"react\"\n    const CounterContext = createContext(0)\n    export default CounterContext\nexport const counterReducer = (state, action) => {\nswitch (action.type) {\n    case \"INCRIMENT\": {\n        return state + 1;\n    }\n    case \"DECRIMENT\": {\n        return state - 1;\n    }\n    default: {\n        return state;\n    }\n}\n};\nএখন যদি আমাদের কোড রান করি,দেখবো এটা পারফেক্টলি কাজ করছে। এই হলো মূলত তিনটা স্টেপ, এই তিনটা স্টেপেই আমরা Reducer উইথ Context ব্যাবহার করতে পারি।","moving-all-wiring-into-a-single-file---a-better-approach#Moving all wiring into a single file - A Better Approach":"এবার আমরা আরেকটু সুন্দর এপ্রোচে Reducer with Context ব্যাবহার করবো। আমরা আমাদের Context রিলেটেড সমস্ত কাজ আলাদা একটা ফাইলে ম্যানেজ করবো এবং স্টেটগুলোও সেই ফাইল থেকে ম্যনেজ করবো।\n    import React from 'react'\n    import Counter from \"./Counter\"\n    import CounterProvider from \"./CounterProvider\"\n    const App = () => {\n      return (\n        <div>\n        <CounterProvider>\n          <Counter/>\n        </CounterProvider>\n        </div>\n      )\n    }\n    export default App\nimport React from 'react'\nimport {createContext,useReducer} from \"react\"\nimport counterReducer from \"./counterReducer.js\"\nconst CounterContext = createContext(0)\nconst initialState = 0\n const CounterProvider = ({children}) => {\n    const [count,dispatch] = useReducer(counterReducer,initialState)\n      return (\n        <CounterContext.provider value={{count,dispatch}}>\n            {children}\n        </CounterContext.provider>\n      )\n    }\n export default CounterProvider\nexport const counterReducer = (state, action) => {\nswitch (action.type) {\n    case \"INCRIMENT\": {\n        return state + 1;\n    }\n    case \"DECRIMENT\": {\n        return state - 1;\n    }\n    default: {\n        return state;\n    }\n}\n};\n   import {useContext} from \"react\"\n   import CounterContext from \"./CounterContext.js\"\n   export default function Counter(){\n       const {state,dispatch} = useContext(CounterContext)\n      return <button>\n          <h1> Count : {count}</h1>\n          <button onClick={()=> dispatch({type:\"INCRIMENT\"})}>Incriment</button>\n          <button onClick={()=> dispatch({type:\"DECRIMENT\"})}>Decriment</button>\n      </>\n   }\nএভাবে আমাদের মেইন প্যারেন্ট কম্পোনেন্ট থেকে সমস্ত কিছু সরিয়ে নিয়ে আমরা একটা আলদা ফাইলে ম্যানেজ করতে পারি।\nএছাড়াও আমরা\n   const {state,dispatch} = useContext(CounterContext)\nএইভাবে Context কে বার বার কল না করে একটা আলাদা কাস্টম হুক বানিয়ে নিয়ে ব্যবাহার করতে পারি,\nimport {useContext} from \"react\"\nimport CounterContext from \"./CounterContext.js\"\nexport default function useCounterContext(){\n    return useContext(CounterContext)\n}\n   import {useContext} from \"react\"\n   import useCounterContext from \"./hooks.js\"\n   export default function Counter(){\n       const {state,dispatch} = useCounterContext()\n      return <button>\n          <h1> Count : {count}</h1>\n          <button onClick={()=> dispatch({type:\"INCRIMENT\"})}>Incriment</button>\n          <button onClick={()=> dispatch({type:\"DECRIMENT\"})}>Decriment</button>\n      </>\n   }"}}}