{"/reactive-accilarator/React-js/module-1/React-installation-and-development-environment-setup":{"title":"React Installation and Development Environment Setup","data":{"":"রিয়াক্ট জে এস ইন্সটল করা এবং ইডীটর সেটআপ করা ।","কমান্ড-প্রমট-এর-মাদ্ধ্যমে-রিয়াক্ট-ইন্সটল-করা-#কমান্ড প্রমট এর মাদ্ধ্যমে রিয়াক্ট ইন্সটল করা ।":"npm create vite@latest --template react","follow-the-command#Follow the command":""}},"/reactive-accilarator/React-js/module-1/basics-of-react-component":{"title":"Basics of React Component","data":{"components-কি-#Components কি ?":"Component হলো রিয়াক্টের কোর কনসেপ্টগুলোর মধ্যে একটি । এটিকে UI বানানোর বিল্ডিং ব্লক বলা হয়ে থাকে । UI এর প্রতিটা অংশের কোড, যা বার বার রি-ইউজ করা যায় সেগুলোকে একেকটা কম্পোনেন্ট বলা যায়। একটি ছোট বাটনও একটা কম্পোনেট হতে পারে ।রিয়াক্ট আমাদের মার্কাপ গুলোকে ছোট ছোট রি-ইউজেবল কোড ব্লকে এ লিখতে সাহায্য করে,যার একেকটি ব্লক হলো একেকটি কম্পোনেন্ট।তবে কম্পোনেন্ট বানানোর জন্য কিছু নিয়ম রয়েছে যা নিচে দেখানো হয়েছে।","কিভাবে-একটি-রিয়াক্ট-component-বানাতে-হয়-#কিভাবে একটি রিয়াক্ট Component বানাতে হয় ?":"রিয়াক্ট কম্পোনেট হলো একটি জাভাস্ক্রিপ্ট ফাংশন। যাতে আমাদের মার্কাপের সাথে জাভাস্ক্রিপ্টের সংমিশ্রণ থাকে।রিয়াক্ট কম্পোনেন্টের সিনট্যাক্স\nexport default function Profile() {\n    return (\n        <img\n            src='https://i.imgur.com/MK3eW3Am.jpg'\n            alt='Katherine Johnson'\n        />\n    );\n}\nএকটি কম্পোনেন্ট বানাতে যেসব স্টেপ ফলো করতে হয়,তা হলোঃ","কম্পোনেন্টকে-এক্সপোর্ট-করা#কম্পোনেন্টকে এক্সপোর্ট করা":"export default ব্যাবহার করে একটা কম্পোনেন্টকে রি-ইউজেবল করতে হয়, যাতে আমরা অন্য ফাইলে কম্পোনেন্টটিকে import\nকরে ব্যাবহার করতে পারি।","ফাংশন-ডিফাইন-করা#ফাংশন ডিফাইন করা":"export default এর পর একটা নেমড ফাংশন ডিফাইন করতে হয়।\n    export default function Profile(){}\nReact Component বানাতে হলে অবশ্যই ফাংশনের নামের প্রথম অক্ষর Capital later এ লিখতে হবে,নাহলে তা কাজ করবেনা।","ফাংশনের-ভিতরে-মার্কাপ-যুক্ত-করা#ফাংশনের ভিতরে মার্কাপ যুক্ত করা":"ফাংশনের ভিতরে JSX (Javascript XML) সিনট্যাক্সে মার্কাপ রিটার্ন করতে হয়।\nexport default function Profile() {\n    return img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n}\nreturn Statement যদি এক লাইনের বেশি লিখতে হয় তাহলে () এর ভিতরে লিখতে হয়\nউদাহরণঃ\nexport default function Profile() {\n  return (\n  <div>\n       <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n  </div>\n  )\n}","কম্পোনেট-কিভাবে-ব্যাবহার-করতে-হয়ঃ#কম্পোনেট কিভাবে ব্যাবহার করতে হয়ঃ":"একটা কম্পোনেন্ট বানানোর পর সেম ফাইলে অন্য আরেকটা কম্পোনেন্ট এর ভিতরে অথবা চাইলে অন্য ফাইলে কম্পোনেন্ট import করে ব্যাবহার করা যায়।উদাহরনঃ\nimport Profile from \"Profile\";\nexport default function Gallery() {\n    return (\n        <section>\n            <h1>Amazing scientists</h1>\n            <Profile />\n            <Profile />\n            <Profile />\n        </section>\n    );\n}","কম্পোনেন্ট-নেস্টিং-করার-ক্ষেত্রে-যেসব-রুলস-মানতে-হয়ঃ#কম্পোনেন্ট নেস্টিং করার ক্ষেত্রে যেসব রুলস মানতে হয়ঃ":"Rules:1 - যদি এমন কম্পোনেন্ট হয়,যেটা খুব ছোট এবং রি-ইউজ হবেনা সেটা চাইলে একই ফাইলে লেখা যায়,এবং ব্যাবহার করা যায়। কিন্তু যদি কম্পোনেন্ট অনেক বড় হয় এবং interactivity বেশি হয়, এবং বিভিন্ন জায়গায় রি-ইউজ করতে হয় তাহলে আলাদা আলাদা ফাইলে কম্পোনেন্ট বানাতে হবে।Rules:2 - একটা কম্পোনেন্ট এর ভিতর আরেকটা কম্পোনেন্টকে নেস্টেড করা যাবে,কিন্তু একটা কম্পোনেট এর ভিতর অন্য আরেকটা ফাংশন ডেফিনেশন নেস্টেড করা যাবেনা।"}},"/reactive-accilarator/React-js/module-1/component-export-import":{"title":"Component Export Import","data":{"রিয়াক্টে-কিভাবে-import--export-করতে-হয়#রিয়াক্টে কিভাবে import & export করতে হয়?":"**রিয়াক্টে দুইভাবে কম্পোনেন্ট import & export করা যায়ঃ **\ndefault export and import\nnamed export and import","default-export-and-import#default export and import":"উদাহরনঃ","default-export#default export":"export default function Gallery() {\n    return; //Jsx will return\n}\nতাছাড়া আরেকভাবে default export করা যায়,\nfunction Gallery() {\n    return; //Jsx will return\n}\nexport default Gallery;","default-import#default import":"import Gallery from \"Gallery\"; // এখানে .js বা .jsx না লিখলেও কোন সমস্যা নেই\ndefault import এর ক্ষেত্রে আমরা যেকোন নামে কম্পোনেন্ট import করতে পারি। তবে, যেই নামে কম্পোনেন্ট import করা হবে সেই নামেই ব্যাবহার করতে হবে।","named-export-and-import#named export and import":"উদাহরনঃ","named-export#named export":"export function Gallery() {\n    return; //Jsx will return\n}\nnamed export এর মাধ্যমে আমরা চাইলে একটা ফাইল থেকে একাধিক কম্পোনেন্ট এক্সপোর্ট করতে পারি, যেমনঃ\nexport function Card() {\n    return; //Jsx will return\n}\nexport function Image() {\n    return; //Jsx will return\n}\nexport function Profile() {\n    return; //Jsx will return\n}","named-import#named import":"import { Card, Image, Profile } from \"Gallery\"; // এভাবে আমরা এক্লাইনেই একাধিক কম্পোনেন্ট ইম্পোর্ট করতে পারি।","alias-named-import#Alias Named Import":"named import এর ক্ষেত্রে আমরা চাইলে Alias দিয়ে রিনেম করেও কম্পোনেন্ট ইম্পোর্ট করতে পারি।\nimport { Card as ImageCard } from \"Gallery\";"}},"/reactive-accilarator/React-js/module-1/conditional-renderaing":{"title":"Conditional Renderaing","data":{"কন্ডিশনাল-রেন্ডারিং-কি-#কন্ডিশনাল রেন্ডারিং কি ?":"রিয়াক্টে আমরা কোন শর্তের উপর ডিপেন্ড করে কোন কিছু দেখাতে পারি। আমরা কি দেখাবো আর কি দেখাবোনা তা নির্দিষ্ট লজিকের উপর ভিত্তি করে করতে পারি। এটাকে রিয়াক্টে কন্ডিশনাল রেন্ডারিং বলা হয়।আমরা বেশ কিছু উপায়ে রিয়াক্টে কন্ডিশনাল রেন্ডারিং করতে পাড়িঃ\nif else statements\ncondition ? true : false - Ternery Operator\n&& - Logical AND Operator\n|| - Logical OR operator\n?? - Nullish Coalesing operator","if-else-statements#if else statements":"আমাদের যদি অনেক কমপ্লেক্স লজিক থাকে,এবং তার উপর ভিত্তি করে আমাদের কিছু রেন্ডার করা লাগে,তাহলে আমরা if else statements এর মাধ্যমে তা করতে পারি। সেক্ষেত্রে আমাদেরকে JSX এর বাহিরে if else statements ডিফাইন করতে হবে।** উদাহরণঃ**\nfunction Item({ name, isPacked }) {\n    if (isPacked) {\n        return <li className='item'>{name} ✅</li>;\n    }\n    return <li className='item'>{name}</li>;\n}\nexport default function PackingList() {\n    return (\n        <section>\n            <h1>Sally Ride's Packing List</h1>\n            <ul>\n                <Item\n                    isPacked={true}\n                    name='Space suit'\n                />\n                <Item\n                    isPacked={true}\n                    name='Helmet with a golden leaf'\n                />\n                <Item\n                    isPacked={false}\n                    name='Photo of Tam'\n                />\n            </ul>\n        </section>\n    );\n}","condition--true--false---ternery-operator#condition ? true : false - Ternery Operator":"আমাদের কন্ডিশন যদি অনেক বেশি কমপ্লেক্স না হয় এবং ম্যক্সিমাম ২-৩ লেবেলের বেশি ডিপ না হয় তাহলে আমরা খুব সহজেই JSX এর ভিতরেই Ternery Operator ব্যাবহার করে কন্ডিশনাল রেন্ডারিং করতে পারি।** উদাহরণঃ**\nfunction Item({ name, isPacked }) {\n    return <li className='item'>{isPacked ? name + \" ✅\" : name}</li>;\n}","---logical-and-operator#&& - Logical AND Operator":"যদি আমাদের কন্ডিশন এমন হয় যে, কন্ডিশন মিললে কিছু রেন্ডার করবো আর না মিললে কিছুই রেন্ডার করবোনা,তাহলে আমরা আরও শর্টকাটে && - Logical AND Operator ব্যাবহার করে সেটা করতে পারি।\nfunction Item({ name, isPacked }) {\n    return (\n        <li className='item'>\n            {name} {isPacked && \"✅\"}\n        </li>\n    );\n}\nলজিকাল && এর মানে হলো যে, && এর বাম পাশে truthy ভ্যালু হয় তাহলে ডান পাশের ভ্যালু রিটার্ন করবে,আর falsy হলে কিছুই রিটার্ন করবেনা।\nlet logic = \"true\";\nlogic && \"Something to Render\"; // এখানে লজিকের ভ্যালু `truthy` হলেই শুধ্যমাত্র `&&` এর ডান পাশে যা থাকবে তা রিটার্ন করবে,আর না হলে কিছুই রিটার্ন করবেনা।\nতবে এক্ষেত্র মনে রাখতে হবে যে, && এর বাম পাশের ডাটাটাইপ যেন নাম্বার না হয়,কেননা যদি নাম্বার হয় তাহলে নাম্বারের falsy ভ্যালু হিসেবে 0রিটার্ন করে দিবে।","---logical-or-operator#|| - Logical OR operator":"লজিকাল && এর মতো || - Logical OR operator ব্যাবহার করেও সেম কাজ করতে পারি।\nfunction Item({ name, isPacked }) {\n    return (\n        <li className='item'>\n            {name} {isPacked || \"✅\"}\n        </li>\n    );\n}\nতবে লজিকাল || এর মানে হলো যে, || এর বাম পাশে falsy (0,null,undefined,\"\",false,NaN) ভ্যালু হয় তাহলেই শুধুমাত্র ডান পাশের ভ্যালু রিটার্ন করবে,আর না হলে কিছুই রিটার্ন করবেনা।\nlet logic = \"false\";\nlogic || \"Something to Render\"; // এখানে লজিকের ভ্যালু `falsy` হলেই শুধ্যমাত্র `||` এর ডান পাশে যা থাকবে তা রিটার্ন করবে,আর না হলে কিছুই রিটার্ন করবেনা।","---nullish-coalesing-operator#?? - Nullish Coalesing operator":"যদি কোন ডাইনামিক ভ্যালু null অথবা undefined হয় তাহলে যদি আমরা কোন কিছু করতে চাই, তাহলে আমরা ?? - Nullish Coalesing operator ব্যাবহার করে তা করতে পারি।\nfunction Item({ name, isPacked, data }) {\n    return (\n        data ?? (\n            <li className='item'>\n                {name} {isPacked || \"✅\"}\n            </li>\n        )\n    );\n}"}},"/reactive-accilarator/React-js/module-1/introduction-to-react":{"title":"Introduction to React","data":{"react-কি-#React কি ?":"রিয়াক্ট হলো ফেসবুকের ডেভেলপ করা একটা জাভাস্ক্রিপ্ট লাইব্রেরি। যা একই সাথে ন্যটিভ এবং ওয়েব ইন্টারফেস ডিজাইন করতে সহায়তা করে থাকে। এটি জাভাস্ক্রিপ্ট এ লেখা জাভাস্ক্রিপ্ট এর ই একটা লাইব্রেরি।ফেসবুকের সফটওয়্যার ইঞ্জিনিয়ার Jordan Walke 2011 সালে PHP এর একটা Component Based Framework XHP-js থেকে ইন্সপায়ার হয়ে React.js তৈরি করেন। 2011 সালে এটা প্রথম ফেসবুকের নিউজফিডে ইম্পিলিমেন্ট করা হয় এবং ২০১২ সালে এটা ইন্সটাগ্রামে ব্যবহার করা হয়। ২০১৩ সালে React.js কে ওপেন সোর্স করে দেয় ফেসবুক কোম্পানি। রিয়্যাক্ট এর ওপেন সোর্স গিটহাব রিপোজিটরি React.js এ ভ্যানিলা জাভাস্ক্রিপ্ট ছাড়া আর কিচ্ছু নাই।","reactকেন-ব্যাবহার-করা-উচিতভ্যানিলা-জাভাস্ক্রিপ্ট-এ-কি-প্রব্লেম-#Reactকেন ব্যাবহার করা উচিত,ভ্যানিলা জাভাস্ক্রিপ্ট এ কি প্রব্লেম ?":"যখন আমরা ভ্যানিলা জাভাস্ক্রিপ্ট এ কাজ করি,তখন যেটা হয় যে, ইউজারের ইন্টারেকশনের কারনে যখন কোথাও কোন UI চেঞ্জ করা লাগে, তখন আমাদের প্রতিটা UI চেঞ্জ ম্যানুয়ালি করে দিতে হয়। কিন্তু React এ আমাদের তা করা লাগেনা। রিয়াক্টে ইউজারেরে কোন ইন্টারেকশনের কারনে যখনি কোন ডেটা বা স্টেট চেঞ্জ হয়,তখন UI টা অটোমেটিক রিয়াক্ট করে,এবং UI টা অটোমেটিক চেঞ্জ হয়। এইযে বার বার যেই UI আপডেট করার প্রসেস, এই প্রসেসটাই অটোমেটিক করার জন্যই মূলত রিয়াক্ট তৈরি করাব হয়েছে।","react-এবং-react-dom-কি-#React এবং React DOM কি ?":"একটা UI বানাতে আসলে তিনটা দিক ম্যানেজ করা লাগে,\nUI/ DOM টাকে বানানো।\nUser Interaction হ্যান্ডেল করা।\nDOM টা ব্রাউজারে রেন্ডার করা ।\nReact এবং React DOM এই দুইটা প্যাকেজ আসলে এই কাজগুলোই করে থাকে।React USER INTERFACE বানাতে হেল্প করে এবং ইউজারের ইন্টারেকশনের কারনে যদি কোন ডাটা চেঞ্জ হয় সেটা ম্যানেজ করে।React DOM এই প্যাকেজটা DOM টাকে ব্রাউজারে রেন্ডার করে,এবং একবার ব্রাউজারে রেন্ডার করানো হয়ে গেলে সে ডেটা চেঞ্জ এর জন্য অপেক্ষা করতে থাকে,যদি কোথাও কোন ডেটা চেঞ্জ হয়,তাহলে সে তার VERTUAL DOM এর সেই চেঞ্জটাকে শনাক্ত করে, UI এর যা যা চেঞ্জ করা লাগে তা করে সরাসরি ব্রাউজারে পেইন্ট করে দেয়। এবং ইউজার আপডেটেড UI তা দেখতে পারে।"}},"/reactive-accilarator/React-js/module-1/javascript-in-jsx":{"title":"JavaScript in JSX","data":{"":"JSXএ আমরা জাভাস্ক্রিপ্ট এবং HTML মার্কাপ একসাথে লিখতে পারি। যখনি মার্কাপে কোন ডাইয়ামিক ভ্যালু ব্যাবহার করতে হয়,অথবা কোন লজিকাল অপারেসন চালাতে হয় এমনকি যদি কোন ভ্যারিয়াবল বা অবজেক্টের ভ্যালু এক্সেস করার প্রয়োজন হয়,তখন তা { } ডাবল কার্লি ব্রেসেস এর ভিতরে লিখতে হয়।উদাহরনঃ\nexport default function Profile(name) {\n    let age = 30;\n    return (\n        <div className='profile-card'>\n            <h1>Hello Mr {name}</h1> // name হলো একটা ডাইনামিক ভ্যালূ যা {} দিয়ে\n            জাভাস্ক্রিপ্টের মাধ্যমে লেখা হয়েছে।\n            <p>Your age is {age}</p> // age একটা ভ্যারিয়েবল থেকে পাওয়া ডাইনামিক ভ্যালু\n            যা {} দিয়ে লেখা হয়েছে।\n            <p>\n                You are {age >= 21 ? \"Eligable\" : \"Not Eligable\"} for Marraige\n                // এই লাইনে জাভাস্ক্রিপ্টের মাধ্যমে লজিকাল অপারেশন করা হয়েছে\n            </p>\n        </div>\n    );\n}\nঅর্থাৎ { } দিয়ে এর ভিতরে আমরা জাভাস্ক্রিপ্টের এক্সপ্রেশন লিখতে পারি।","using-double-curlies-css-and-other-objects-in-jsx#Using “double curlies”: CSS and other objects in JSX":"উদাহরনঃ\nexport default function Profile(name) {\n    let age = 30;\n    return (\n        <div\n            className='profile-card'\n            style={{\n                // এই লাইনে অবজেক্ট লেখা হয়েছে\n                backgroundColor: \"gray\",\n                color: \"black\",\n                fontWeight: \"bold\",\n            }}>\n            <h1>Hello Mr {name}</h1> // name হলো একটা ডাইনামিক ভ্যালূ যা {} দিয়ে\n            জাভাস্ক্রিপ্টের মাধ্যমে লেখা হয়েছে।\n            <p>Your age is {age}</p> // age একটা ভ্যারিয়েবল থেকে পাওয়া ডাইনামিক ভ্যালু\n            যা {} দিয়ে লেখা হয়েছে।\n            <p>\n                You are {age >= 21 ? \"Eligable\" : \"Not Eligable\"} for Marraige\n                // এই লাইনে জাভাস্ক্রিপ্টের মাধ্যমে লজিকাল অপারেশন করা হয়েছে\n            </p>\n        </div>\n    );\n}\nযখন JSX এ { } এর ভিতরে কোন অবজেক্ট লিখা লাগবে তখনও একই স্টেপ ফলো করতে হবে, এতে হয়তো মনে হতে পারে যে আমরা দুইবার { } ব্যাবহার করছি, কিন্তু না, প্রথম { } টা হলো জাভাস্ক্রিপ্টের জন্য জায়গা বানানো এবং দ্বিতীয় { } টা হলো অবজেক্ট এর জন্য।"}},"/reactive-accilarator/React-js/module-1/jsx-markup":{"title":"JSX Markup","data":{"jsx-কি-#JSX কি ?":"JSX হলো জাভাস্ক্রিপ্টের একটি সিনট্যাক্স এক্সটেনশন যা আমাদেরকে HTML এর মতো মার্কাপ লিখতে সাহায্য করে । JSX এর বড় সুবিধা হলো এখানে একই জায়গায়(কম্পোনেন্টের ভিতর) জাভাস্ক্রিপ্টের লজিক ও HTML এর মার্কাপ লিখা যায়। যা পরবর্তিতে কোথাও কিছু চেঞ্জ করতে হলে আমাদের এক্সট্রা ফ্লেক্সিবিলিটি দেয়।JSX দেখতে একদম HTML এর মতো হলেও এটা কিন্তু HTML নয়,বরং HTML এর চাইতে অনেক বেশি Strict। JSX এ কোথাও কোন ভুল করলে তা সাথে সাথে Error দিয়ে দেয়।HTML এ আমরা শুধুমাত্র স্ট্যাটিক কন্টেন্ট লিখতে পারি,কিন্তু JSX এ আমারা ডাইনামিক ভ্যালু ব্যাবহার করতে পারি।","jsx-লিখার-রুলসগুলো-কি-কি-#JSX লিখার রুলসগুলো কি কি ?":"JSX এ বেশ কিছু রুলস ফলো করতে হয় তা হলোঃ","1-return-a-single-root-element#1. Return a Single root element:":"JSX এক্টিমাত্র সিঙ্গেল রুট এলিমেন্ট রিটার্ন করতে হবে, যদি মাল্টিপল এলিমেন্ট রিটার্ন করতে হয় তাহলে অবশ্যই একটি প্যারেন্ট এলিমেন্ট দিয়ে wrap করে দিতে হবে। এক্ষেত্র চাইলে <div> </div> এলিমেন্ট ব্যাবহার করা যায়। তবে <div> </div> ব্যাবহার করলে HTML এর Eliment Tree তে একটা অতিরিক্ত <div> </div> এলিমেন্ট রেন্ডার হয়।❌ ভুল\nexport default function Profile() {\n    return (\n            <h1>Hello Mr XX</h1>\n            <p>Your age is 30</p>\n        // এই কোডটা কাজ করবেনা,কারণ দুইটা এলিমেন্টকে রিটার্ন করা হয়েছে\n    );\n}\n✅ সঠিক\nexport default function Profile() {\n    return (\n        <div>\n            <h1>Hello Mr XX</h1>\n            <p>Your age is 30</p>\n        </div>\n        // এই কোডটা কাজ করবে,কারণ দুইটা এলিমেন্টকে একটা প্যারেন্ট `<div> </div>` দিয়ে wrap করা হয়েছে\n    );\n}\nতবে আপানর ইচ্ছা যদি হয় যে আপনি কোন অতিরিক্ত <div> </div> এলিমেন্ট রেন্ডার করবেন না তাহলে, <></> এভাবে ব্যাবহার করতে পারেন। এটাকে বলা হয় Fragment ট্যাগ। আবার যদি কখনও Fragment এর ভিতরে key পাস করা লাগে,তাহলে ফ্রাগমেন্ট <></> এভাবে না লিখে <Fragment></Fragment> এভাবে লিখতে হবে।","কেন-আমাদের-একটি-মূল-jsx-রিটার্ন-করতে-হয়#কেন আমাদের একটি মূল JSX রিটার্ন করতে হয়?":"Credit to : Saffaullah Shuvo\nWell, যে কোন প্রোগ্রামিং এই function থেকে কেবল একটি data type/structure এর ডেটা রিটার্ন করা যায়। যেমন একটি সিম্পল নাম্বার অথবা কোন কমপ্লেক্স ডেটা স্ট্রাকচার,\nfunction returnOne() { return 1; } // দুইটা নাম্বার রিটার্ন করা কি সম্ভব?\nfunction returnTwo() { return (100 500) } // এটা একটা syntax error // তারমানে Compiler এইরকম syntax সাপোর্ট করেনা\nতাহলে দুইটা নাম্বার কি রিটার্ন করা যাবে না? যাবে-\nfunction returnTwo() { return [100, 500]; // আরো অনেকভাবেই করা যায় }\nJSX গুলা যেহেতু javascript Object তাই\nfunction returnTwoJSX() {\nreturn (<h1>Hi</h1> <h2>Hello</h2>)\n }\n  // Behind the scene\n  function returnTwoJSX() {\n   return (\n    {type: 'h1', props: { children: 'Hi'}} // object1\n    {type: 'h2', props: { children: 'Hello'}} // object2\n    )\n    }\n     // তাই এটাও syntax error\nকিন্তু আমরা একটা Array এর ভিতরে রেখে কিংবা একটা প্যারেন্ট এলিমেন্টের ভিতরে রেখে একটা ডেটা হিসেবেই return করতে পারি।\nসল্যুশন ১ - প্যারেন্ট এলিমেন্ট দিয়ে Wrap করে দেয়া\nfunction returnParentJSX() {\n    return (\n        <div>\n            <h1>Hi</h1>\n            <h2>Hello</h2>\n        </div>\n    );\n}\n// Behind the scene\nfunction returnParentJSX() {\n    return {\n        type: \"div\",\n        props: { children: [object1, object2] },\n        // ...additional properties\n    };\n}\nসল্যুশন ২ - প্যারেন্ট হিসেবে Fragment ব্যবহার করা।\nfunction returnFragmentJSX() {\n    return (\n        <Fragment>\n            {\" \"}\n            // short form <></>\n            <h1>Hi</h1>\n            <h2>Hello</h2>\n        </Fragment>\n    );\n}\n// Behind the scene\nfunction returnFragmentJSX() {\n    return {\n        type: Symbol(react.fragment),\n        props: { children: [object1, object2] }, // ...additional property\n    };\n}\nJSX এর বদলে ডিরেক্ট Object Return করলে কি কাজ করবে? যেমনঃ\nfunction returnDirectObject() {\n    return {\n        type: \"div\",\n        props: {\n            className: \"bg-white\",\n            children: [\n                {\n                    type: \"h1\",\n                    props: { className: \"text-2xl\", children: \"Hi\" },\n                },\n                { type: \"p\", props: { children: \"Hello World\" } },\n            ],\n        },\n    };\n}\nনা, কারন এই Object টা React এর ওয়েতে বানানো হয়নি। রিয়েক্ট আরও Additional Property রাখে Object er ভিতর। রিয়েক্ট যেভাবে বানায় -\nimport { createElement } from \"react\";\nfunction returnDirectObject() {\n    return createElement(\n        \"div\",\n        { className: \"bg-white\" },\n        createElement(\"h1\", { className: \"text-2xl\" }, \"Hi\"),\n        createElement(\"p\", null, \"Hello World\")\n    );\n}","2-close-all-the-tags#2. Close all the tags:":"JSX এ ব্যাবহার করা প্রতিটা ট্যাগ অবশ্যই ক্লোজ করা লাগবে। সেলফ ক্লোজিং ট্যাগ যেগুলো আছে যেমনঃ <img>,<hr>,সেগুলোও অবশ্যই এভাবে <img />,<hr /> ক্লোজ করা লাগবে ।","3-camelcase-all-most-of-the-things#3. camelCase all most of the things!:":"JSX এ যেহেতু আমারা JavaScript লিখছি,সেহেতু আমাদের জাভাস্ক্রিপ্ট এর রুলস অনুযায়ী multiple-word এর Attribute গুলোকে camelCase এ লিখতে হবে।class Attribute টা যেহেতু জাভাস্ক্রিপ্টের রিজার্ভ কিওয়ার্ড,তাই আমরা class ব্যাবহার করতে পারবোনা। class এর পরিবর্তে আমদের className ব্যাবহার করতে হবে ।"}},"/reactive-accilarator/React-js/module-1/pure-components":{"title":"Pure Components","data":{"পিওর-ফাংশন-কী#পিওর ফাংশন কী?":"একটি ফাংশনকে পিওর (pure) বলা হয় যদি তা নিচের দুটি শর্ত পূরণ করে:\nসেম ইনপুটের জন্য সেম আউটপুট: পিওর ফাংশন সবসময় তার ইনপুট অনুযায়ী নির্দিষ্ট আউটপুট প্রদান করে। অর্থাৎ একই ইনপুটের জন্য সবসময় একই আউটপুট পাওয়া যাবে।\nসাইড-ইফেক্টের অনুপস্থিতি: পিওর ফাংশন বাইরের কোনো স্টেট বা ভ্যারিয়েবল পরিবর্তন করে না। এটি শুধুমাত্র ইনপুট অনুযায়ী কাজ করে এবং বাইরে কোনো পরিবর্তন আনে না।","পিওর-ফাংশনের-উদাহরণ#পিওর ফাংশনের উদাহরণ:":"function add(a, b) {\n    return a + b;\n}\nএখানে add ফাংশনটি পিওর, কারণ এটি কেবল তার ইনপুট অনুযায়ী আউটপুট দিচ্ছে এবং বাহ্যিক কোনো স্টেট পরিবর্তন করছে না।","ইমপিওর-ফাংশনের-উদাহরণ#ইমপিওর ফাংশনের উদাহরণ:":"let x = 10;\nfunction addWithSideEffect(a, b) {\n    x = a + b; // বাহিরের ভ্যারিয়েবল পরিবর্তন করা হচ্ছে\n    return x;\n}\nএই ফাংশনটি ইমপিওর, কারণ এটি বাহ্যিক ভ্যারিয়েবল x এর মান পরিবর্তন করছে, যা একটি সাইড-ইফেক্ট সৃষ্টি করছে।","কেন-react-এ-পিওর-ফাংশনাল-কম্পোনেন্ট-ব্যবহার-করা-উচিত#কেন React-এ পিওর ফাংশনাল কম্পোনেন্ট ব্যবহার করা উচিত?":"React কম্পোনেন্টগুলোকে পিওর রাখতে রিকমেন্ড, কারণ এতে বেশ কিছু সুবিধা রয়েছে। মূলত, পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের মাধ্যমে React এর পারফরম্যান্স ও ব্যবহারে সুবিধা পাওয়া যায়। আসুন, এই সুবিধাগুলো বিস্তারিতভাবে দেখি:","১-অপ্রয়োজনীয়-রেন্ডার-এড়ানো#১. অপ্রয়োজনীয় রেন্ডার এড়ানো":"React পিওর ফাংশনাল কম্পোনেন্টগুলোর ক্ষেত্রে ইনপুট বা প্রপসে কোনো পরিবর্তন না হলে কম্পোনেন্টটি পুনরায় রেন্ডার করে না। অর্থাৎ, ইনপুট এক থাকলে React আগের আউটপুট ব্যবহার করতে পারে, যা অ্যাপ্লিকেশনের রেন্ডারিংয়ের কার্যকারিতা বৃদ্ধি করে।","উদাহরণ#উদাহরণ:":"import React from \"react\";\nconst Greeting = React.memo(function Greeting({ name }) {\n    console.log(\"Rendering Greeting\");\n    return <h1>Hello, {name}!</h1>;\n});\nএখানে React.memo ব্যবহারের মাধ্যমে এই কম্পোনেন্টকে পিওর করা হয়েছে। যদি name প্রপসের কোনো পরিবর্তন না ঘটে, তাহলে React পূর্বের রেন্ডারকৃত আউটপুটই পুনরায় ব্যবহার করবে, নতুন করে রেন্ডার করা প্রয়োজন হবে না।","২-সহজ-এবং-ক্লিন-কোড#২. সহজ এবং ক্লিন কোড":"পিওর ফাংশনাল কম্পোনেন্টের ব্যবহারে কোড সহজ ও ক্লিন হয়। যেহেতু এগুলো শুধু ইনপুটের ওপর নির্ভরশীল এবং কোনো বাহ্যিক স্টেটের উপর নির্ভর করে না, তাই এগুলো সহজেই বোঝা যায় এবং প্রয়োগ করা যায়।","উদাহরণ-1#উদাহরণ:":"function WelcomeMessage({ user }) {\n    return <p>Welcome, {user}!</p>;\n}\nএই ধরনের কম্পোনেন্ট অত্যন্ত ক্লিন এবং সহজপাঠ্য, কারণ এটি কোনো বাহ্যিক স্টেট পরিবর্তন করে না, বরং শুধুমাত্র প্রপসের মাধ্যমে আউটপুট প্রদান করে।","৩-প্রেডিক্টেবল-আচরণ#৩. প্রেডিক্টেবল আচরণ":"পিওর ফাংশনাল কম্পোনেন্ট সবসময় নির্দিষ্ট ইনপুট অনুযায়ী নির্দিষ্ট আউটপুট দেয়। এতে করে এদের আচরণ প্রেডিক্টেবল হয়, অর্থাৎ আগেভাগেই অনুমান করা সম্ভব। এটি ডিবাগিং এবং বাগ সমাধানের ক্ষেত্রে গুরুত্বপূর্ণ, কারণ আচরণ সবসময় পূর্বানুমানযোগ্য থাকে।","৪-সহজ-টেস্টিং#৪. সহজ টেস্টিং":"পিওর ফাংশনাল কম্পোনেন্ট সহজেই টেস্ট করা যায়, কারণ এগুলো ইনপুট এবং আউটপুটের উপর নির্ভরশীল। ইনপুট অনুযায়ী আউটপুট পরীক্ষা করলেই সহজে বোঝা যায় যে ফাংশনটি সঠিকভাবে কাজ করছে কি না।","উদাহরণ-2#উদাহরণ:":"function sum(a, b) {\n    return a + b;\n}\n// টেস্টিং উদাহরণ:\nconsole.log(sum(2, 3)); // আউটপুট হবে: 5","৫-memoization-এর-সুবিধা#৫. Memoization এর সুবিধা":"React-এ পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের ফলে memoization সহজ হয়। একই ইনপুটের জন্য React আগের আউটপুট সংরক্ষণ করতে পারে, ফলে অপ্রয়োজনীয় রেন্ডার এড়িয়ে পারফরম্যান্স উন্নত করা যায়। React.memo এই কাজে বিশেষভাবে ব্যবহৃত হয়।React-এ পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের মাধ্যমে কোডের সহজ হয়, প্রেডিক্টেবিলিটি এবং পারফরম্যান্স বৃদ্ধি পায়। অপ্রয়োজনীয় রেন্ডারিং এড়ানো, সহজে টেস্ট করা, এবং কোড ক্লিন রাখার জন্য পিওর ফাংশন ব্যবহার অত্যন্ত গুরুত্বপূর্ণ। তাছাড়া, React এর memoization ফিচারের কারণে পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের মাধ্যমে অ্যাপ্লিকেশনের কার্যকারিতা উল্লেখযোগ্যভাবে বৃদ্ধি পায়।","যদি-আমাদেরকে-এমন-কোন-কাজ-করতেই-হয়-যাতে-কম্পোনেন্টের-পিওরিটি-নষ্ট-হলেও-করতে-হবেএমনবস্থায়-কি-করবো-#যদি আমাদেরকে এমন কোন কাজ করতেই হয় যাতে কম্পোনেন্টের পিওরিটি নষ্ট হলেও করতে হবে,এমনবস্থায় কি করবো ?":"হ্যা,এটা ঠিক যে সবসময় কম্পোনেন্টের পিওরিটি বজায় রাখা সম্ভব নাও হতে পারে,আমাদের এমন কিছু করা লাগতে পারে যাতে হয়তো কম্পোনেন্টের পিওরিটি নষ্ট হবে, এমন অবস্থায় আমরা দুটি কাজ করতে পাড়িঃ","manage-with-event-handler#Manage With Event Handler:":"যেসব সাইড-এফেক্টগুলো আমরা event-handler এর মাধ্যমে করতে পারবো,তা আমরা event-handler এর ভিতর করার চেষ্টা করবো। কারণ event-handler রিয়াক্টের রেন্ডারিং টাইমে একটিভ হয়না তাই event-handler পিওর হউয়ার প্রয়োজন নাই ।  event-handler Hydration (রিয়াক্টের কম্পোনেন্ট লোড হউয়ায়র পর যেই টাইমটায় জাভাস্ক্রিপ্ট একটিভ হয়, ওই প্রসেসটা হলো Hydration) টাইমে একটিভ হয়। মূল কোথা হলো যাতে রিয়াক্টের রেন্ডারিং টাইমে কোন সাইড-এফেক্ট না হয় ।","useeffect-হুকের-মাধ্যমে-সাইড-এফেক্ট-ম্যানেজ-করাঃ#useEffect হুকের মাধ্যমে সাইড-এফেক্ট ম্যানেজ করাঃ":"যদি আর কোন উপায় নাই থাকে,তাহলে একেবারে লাস্ট স্টেজ হিসেবে রিয়াক্ট সাইড-এফেক্ট হ্যান্ডেল করার জন্য একটা বিল্ট-ইন হুক দিয়ে দিয়েছে,যার নাম useEffect। এই হুক ব্যাবহার করে সাইড-এফেক্ট ম্যানেজ করতে হবে। এই হুকটাও রিয়াক্টের রেন্ডারিং শেষ হয়ে যাওয়ার পর একটিভ হয়। তাই সাইড-এফেক্ট হ্যান্ডেল করার জন্য এই হুকটা ইউজ করা যেতে পারে,তবে সেটা হলো একেবারে সর্বশেষ রাস্তা।","ফাংশনের-ভিতরের-ভ্যারিয়েবলগুলো-কি-চেঞ্জ-করা-যাবে#ফাংশনের ভিতরের ভ্যারিয়েবলগুলো কি চেঞ্জ করা যাবে?":"হ্যা,ফাংশনের ভিতরের ভ্যারিয়েবল চেঞ্জ করা যাবে। এতে কম্পোনেন্টের পিওরিটি নষ্ট হবেনা। এটাকে বলা হয় local mutation। লোকাল মিউটেশনে কোন সমস্যা নাই।"}},"/reactive-accilarator/React-js/module-1/rendering-list":{"title":"Rendering List","data":{"":"রিয়াক্টে আমাদেরকে প্রায় সময়ই লিস্ট অফ ডাটা বা ডাটা Array থেকে ডাটা রেন্ডার করার প্রয়োজন হয়। সেক্ষেত্রে আমারা map, filter ব্যাবহার করে তা দেখাতে পারি।উদাহরনঃ\nconst users = [\"Mr x\", \"Mr y\", \"Mr z\"];\nexport function ListOfUser() {\n    const user = users.map((person) => <li>{person}</li>);\n    return <ul>{user}</ul>;\n}","key-এর-ব্যাবহারঃ#key এর ব্যাবহারঃ":"লিস্ট অফ আইটেম map করে রেন্ডার করার সময় প্রতিটা লিস্ট এলিমেন্টে অবশ্যই key ব্যাবহার করতে হবে।\nconst users = [\n    {\n        id: 1,\n        name: \"Mr X\",\n    },\n    {\n        id: 2,\n        name: \"Mr XX\",\n    },\n];\nexport function ListOfUser() {\n    const user = users.map((person) => <li key={person.id}>{person.name}</li>);\n    return <ul>{user}</ul>;\n}","key-কিভাবে-পেতে-পারি-#key কিভাবে পেতে পারি ?":"বিভিন্ন ডাটা থেকে বিভিন্ন ভাবে key পেতে পারি, যেমনঃ\nডাটাবেস থেকে প্রাপ্ত ডাটাঃ যেসব ডাটা আমরা ডাটাবেস থেকে পাই সেগুলোর সাথে আমারা অটোমেটিক Id পেয়ে যাই, এই Id আমরা key হিসেবে ব্যাবহার করতে পারি।\nলোকাল ডাটার ক্ষেত্রেঃ যেসব ডাটা লোকালি অটোমেটিক জেনারেটেড হয় সেসব ডাটার ক্ষেত্রে আমারা crypto.randomUUID() অথবা uuid ব্যাবহার করে id/key জেনারেট করে সেভ করতে পারি।","রুলস-অফ-key#রুলস অফ key":"key অবশ্যই ইউনিক হতে হবে। একই লিস্টের বিভিন্ন এলিমেন্টে একই key ব্যাবহার করা যাবেনা।\nkey পরিবর্তন করা যাবেনা বা রেন্ডারিং এর সময়ে key জেনারেট করে ব্যবাহার করা যাবেনা।\nArrayর ইনডেক্সকে কখনো কি হিসেবে ব্যাবহার করা যাবেনা।","রিয়াক্টে-কেন-key-ব্যাবহার-করা-লাগে#রিয়াক্টে কেন key ব্যাবহার করা লাগে?":"রিয়াক্ট তার DOM TREEতে প্রতিটা আইটেমকে ইউনিকভাবে আইডেন্টিফাই করার জন্য keyর প্রয়োজন হয়। যাতে কখনও লিস্ট থেকে কোন আইটেম ডিলিট হয়ে গেলে,বা কখনো sort করা লাগলে যেন রিয়াক্ট সহজে বুঝতে পারে যে কোন আইটেমে পরিবর্তন হয়েছে।"}},"/reactive-accilarator/React-js/module-1/understanding-props":{"title":"Understanding Props","data":{"props-কি-#Props কি ?":"রিয়াক্টে Parent Component থেকে Child Component এ ডাটা প্রদানের জন্য Props ব্যাবহার করা হয়ে থাকে। Props অনেকটা ফাংশনের Parameters এর মতো।আমরা যেভাবে HTML এর Attributes লিখি সেভাবেই Parent Component থেকে Child Component এ Props পাঠাতে পারি।উদাহরনঃ\nexport default function Profile() {\n    return (\n        <Avater //imgurl এবং size নামে দুটি props পাঠানো হয়েছে চাইল্ড কম্পোনেন্ট Avater এ।\n            imgurl='https://example.com/image/1.png'\n            size={100}\n        />\n    );\n}\nexport default function Avater(props) {\n    // parent  Avater কম্পোনেন্ট থেকে props নামে একটা Object হিসেবে props গুলো রিসিভ করা হয়েছে\n    return (\n        <img\n            src={props.imgurl}\n            alt='Avater Image'\n            size={props.size}\n        />\n    );\n}\nProps এ আমরা যেকোন জাভাস্ক্রিপ্ট ভ্যালু পাঠাতে পারি,এমনকি ফাংশন ও পাঠাতে পারি।","কিভাবে-props-পাঠাতে-হয়-এবং-props-রিসিভ-করতে-হয়-#কিভাবে Props পাঠাতে হয় এবং Props রিসিভ করতে হয় ?":"যেভাবে Props পাঠাতে হয় এবং Props রিসিভ করতে হয় নিচে তা বিস্তারিত ব্যাখ্যা করছি।","step-1---pass-props-to-the-child-component#Step 1 :  Pass props to the child component":"export default function Profile() {\n        return (\n          <Avatar\n            person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}\n            size={100}\n          />\n        );\n      }\nএখানে Avatarকম্পোনেন্ট থেকে তার চাইল্ড কম্পোনেন্টে\nperson = যা একটি অবজেক্ট,\nsize = যা একটি নাম্বার,\nপাঠানো হয়েছে।","step-2--read-props-inside-the-child-component#Step 2 : Read props inside the child component":"export default function Avater(props) {\n    return (\n        <img\n            src={props.imgurl}\n            alt='Avater Image'\n            size={props.size}\n        />\n    );\n}\nparent Avater কম্পোনেন্ট থেকে props নামে একটা Object হিসেবে props গুলো রিসিভ করা হয়েছে","distructuring-পদ্ধতিতে-props-রিসিভ-করা-#Distructuring পদ্ধতিতে Props রিসিভ করা ।":"Distructuring পদ্ধতিতে Props রিসিভ করা যায়, সেক্ষেত্রে আমারা এভাবে করতে পারি।\nexport default function Avater({ imgurl, size }) {\n    return (\n        <img\n            src={imgurl}\n            alt='Avater Image'\n            size={size}\n        />\n    );\n}","props-এ-ডিফল্ট-ভ্যালু-ব্যাবহার-করা#Props এ ডিফল্ট ভ্যালু ব্যাবহার করা।":"কখনও কখনও Props এর ভ্যালু Undefined আসতে পারে,তখন আমাদের Props এর ডিফল্ট ভ্যালু সেট করা লাগতে পারে, সেক্ষেত্রে আমারা এভাবে = দিয়ে ডিফল্ট ভ্যালু সেট করতে পারি।\nexport default function Avater({ imgurl, size = 100 }) {\n    return (\n        <img\n            src={imgurl}\n            alt='Avater Image'\n            size={size}\n        />\n    );\n}","forwarding-props-with-the-jsx-spread-syntax#Forwarding props with the JSX spread syntax":"কখনও কখনও এমন হতে পারে যে আমরা কোন কম্পোনেন্ট এ যেই Props গুলো রিসিভ করেছি, তার সবগুলো Props ওই কম্পোনেন্টের ভিতরেই অন্য আরেকটা কম্পোনেন্টের চাইল্ড কম্পোনেন্টে পাঠানো বা ফরওয়ার্ড করা লাগতে পারে। তখন আমরা ওই Props গুলো বার বার না লিখে JSX spread syntax {...props}  পাস করে দিতে পারি।এক্ষেত্রে আমরা মেইন যে কম্পোনেন্ট এ Props গুলো রিসিভ করবো সেখানে আমাদের Distructuring Method রিসিভ না করে props নামক অবজেক্ট হিসেবে ধরতে হবে।উদাহরণঃ","step-1#Step 1:":"প্রথম App কম্পোনেন্ট থেকে Profile কম্পোনেন্টে name,age,gender নামে তিনটা Props পাস করা হয়েছে।\nexport default function App() {\n    return (\n        <div>\n            <div>\n                <Profile\n                    name='Ripon'\n                    age={30}\n                    gender='male'\n                />\n            </div>\n        </div>\n    );\n}","step-2#Step 2:":"এখানে Profile কম্পোনেন্ট এ সমস্ত propsগুলো props নামক অবজেক্ট হিসেবে রিসিভ করা হয়েছে।\nexport default function Profile(props) {\n    return (\n        <div>\n            <Card {...props} />\n        </div>\n    );\n}","step-3#Step 3:":"এখানে Card কম্পোনেন্ট এ সমস্ত propsগুলো {...props} করে Spread করে পাঠানো হয়েছে ।\nexport default function Profile(props) {\n    return (\n        <div>\n            <Card {...props} />\n        </div>\n    );\n}","চিলড্রেন-প্রপ্স-হিসেবে-jsxবা-component-পাঠানো#চিলড্রেন প্রপ্স হিসেবে JSXবা Component পাঠানো।":"আমরা একটা কম্পোনেন্ট দিয়ে wrap করে অন্য আরেকটা Component কে Props হিসেবে পাঠাতে পারি। এটাকে বলা হয় children Props। এবং রিসিভ করার সময়ও সেটাকে children নামেই রিসিভ করতে হয়।\nexport default function Profile() {\n    return (\n        <Card>\n            <Profile />\n        </Card>\n    );\n}\nexport default function Card({ children }) {\n    // এখানে `Profile` কম্পোনেন্টকে `children` হিসেবে রিসিভ করা হয়েছে।\n    return (\n        <div className='card'>\n            <h1>This is Profile Card</h1>\n            {children}\n        </div>\n    );\n}","props-are-immutable-why-#Props are Immutable: why ?":"Props গুলো সরাসরি চেঞ্জ করা যায়না। কারণ props হলো Immutable. props কে শুধুমাত্র Parent Component থেকে State দ্বারা ম্যানেজ করতে হয়। কখনো কোন ইউজারের ইন্টারেকশনের কারনে যদি props এর ভ্যালু চেঞ্জ করা লাগে, তাহলে রিয়াক্ট তখন নতুন Props পাস করে Child Component এ। কিন্তু কখনই আগের পাঠানো props কে পরিবর্তন করেনা।নতুন Props পাঠানোর পর আগের Propsটা কে জাভাস্ক্রিপ্ট মেমরি থেকে ফেলে দেয় বা গার্বেজ কালেক্টেড করে ফেলে।তাই কখনই Child Component এর ভিতর Props এর ভ্যালূ পরিবর্তন বা ওভাররাইড করা যাবেনা।"}},"/reactive-accilarator/React-js/module-1/vertual-dom":{"title":"Vertual Dom","data":{"dom-কি-আসলেই-স্লো#DOM কি আসলেই স্লো?":"নাহ, ডম কখনোই স্লো না । আসলে যদি ভালোভাবে কোড করা হয় তাহলে ডম যেকোন কিছুর থেকে ফাস্ট। কিন্তু বর্তমান বিশ্বে ওয়েব অ্যাপ্লিকেশনগুলো অনেক বেশি ইন্টারেক্টিভ,তাই যখনই ইউজার কোন ইন্টারেকশন করে তখন ব্রাউজারকে আবার তা নতুন করে পুরো ওয়েবসাইটটা রি-পেইন্ট করতে হয়। এইরকম যখন অনেকগুলো রিয়াকশনের কারনে ব্রাউজারকে বার বার রি পেইন্ট করতে হয় তখন সেই রি-পেইন্টিং প্রসেসটা স্লো হয়ে যায়,মুলত ডম কিন্তু স্লো নয় ।","ব্রাউজার-কিভাবে-dom-রেন্ডার-করে-#ব্রাউজার কিভাবে DOM রেন্ডার করে ?":"আমরা দেখতে পাচ্ছি যে উপরে একটা গ্রাফ এর মাদ্ধমে ব্রাউজার এর রেন্ডারিং প্রসেস দেখানো হয়েছে । এখানে আমরা কি দেখতে পাচ্ছি ? আমরা দেখতে পাচ্ছি যে, যখন ব্রাউজার কোন HTML CSS ফাইল পায়,তখন সেই ফাইলটা একটা পারসিং এর মদ্ধে দিয়ে নিয়ে যায়, এক্ষেত্রে HTML এর জন্য HTML PARSER ও CSS এর জন্য CSS PERSER ব্যাবহার হয়। এসব পারসার দিয়ে পারসিং এর পর ব্রাউসার HTML দিয়ে একটা DOM TREE বানায় এর CSS দিয়ে CSSOM নামে একটা STYLE RULES বানায় , এবং DOM TREE ও STYLE RULES একসাথে ATTACH হয়ে একটা RENDER TREE বানায়। এই RENDER TREE ব্রাউসারে একটা LAYOUT ফেস এর মদ্ধে দিয়ে যায়। এই LAYOUT ফেস এ DOM TREE টা ব্রাউসার এর কোথায় রেন্ডার হবে তার একটা CORDINATE রেডি হয়ে যায় । এবং ফাইনালি ব্রাউজার তার PAINTING মেকানিজম এর মাদ্ধমে তা ব্রাউসারে পেইন্ট করে দেয় এবং আমরা ফাইনাল আউটপুট দেখতে পাই।","ভার্চুয়াল-ডম-কি--কিভাবে-ভার্চুয়াল-ডম-কাজ-করে#ভার্চুয়াল ডম কি ? কিভাবে ভার্চুয়াল ডম কাজ করে?":"ভার্চুয়াল ডম রিয়াক্ট এর একটা ফান্ডামেন্টাল বিষয় । রিয়াক্ট এর ভিত্তিটাই মূলত এই ভার্চুয়াল ডম ।ব্রাউজারের রি-পেন্টিং প্রসেসটা এপ্লিকেশনকে স্লো ডাউন করে দেয়, এই সমস্যা এড়ানোর জন্য আমরা কি করতে পারি ভাবুনতো। আমরা মূলত দুইটা ভাবে এটার সমাধান করতে পারি :\nআমরা ব্যাচ আপডেট করতে পারি,\nআমরা ডম ম্যানুপুলেশন কম করতে পারি।\nরিয়াক্ট তার ভার্চুয়াল ডমের মাদ্ধমে সেই কাজটাই করে । রিয়াক্ট একেবারে মিনিমাম ডম ম্যানুপুলেশন করে ।যখন এপ্লিকেশনে কোন ইউজার কোন ইন্টারেকশন করে তখন যদি UI তে কোন চেঞ্জ করতে হয় তখন রিয়াক্ট সরাসরি HTML এর DOM TREE টাকে চেঞ্জ করে দেয়না। যখনি UI তে কোন চেঞ্জ আসে,রিয়াক্ট তার ভার্চুয়াল DOM এর সাহায্যে UI এর একটা রেপ্লিকা বা কপি বানিয়ে নেয় । তারপর রিয়াক্ট তার একটা নিজস্ব বানানো এলগরিদম Diffng বা Reconciliation এলগরিদম এর মাদ্ধমে চেক করে যে UI এর ঠিক কোন জায়গায় চেঞ্জ হয়েছে । এতে করে পুরো ওয়েবসাইটটা রি-রেন্ডার না করে শুধুমাত্র যেই অংশে পরিবর্তন হয়েছে,সেই অংশটুকু DOM এ আপডেট করে দেয়। এতে করে রিয়াক্ট মিনিমাম ডম অপারেশনের মাদ্ধমে এপ্লিকেশনএর পার্ফমেন্স ইম্প্রুভ করে ।"}},"/reactive-accilarator/React-js/module-1/your-ui-as-a-tree":{"title":"Your UI as a Tree","data":{"রেন্ডার-ট্রি-render-tree-এবং-মডিউল-ট্রি-module-tree--রিয়াক্টের-প্রেক্ষাপটে#রেন্ডার ট্রি (Render Tree) এবং মডিউল ট্রি (Module Tree) – রিয়াক্টের প্রেক্ষাপটে":"","১-রেন্ডার-ট্রি-render-tree-কী#১. রেন্ডার ট্রি (Render Tree) কী?":"রেন্ডার ট্রি হলো ডকুমেন্ট অবজেক্ট মডেল (DOM) এবং স্টাইলিং ইনফরমেশন (CSS) এর সম্মিলিত রূপ। এটি একটি ট্রি স্ট্রাকচার যেখানে প্রতিটি নোড একটি UI এলিমেন্টের প্রতিনিধিত্ব করে।রিয়াক্টে, আমরা JSX দিয়ে কম্পোনেন্ট লিখি, যা শেষে HTML DOM এ রূপান্তরিত হয়। রিয়াক্ট তখন একটি ভার্চুয়াল DOM তৈরি করে এবং সেই DOM এর ওপর কাজ করে।","রেন্ডার-ট্রি-কিভাবে-কাজ-করে#রেন্ডার ট্রি কিভাবে কাজ করে?":"DOM ও CSSOM তৈরি: প্রথমে ব্রাউজার HTML থেকে একটি DOM (ডকুমেন্ট অবজেক্ট মডেল) তৈরি করে। তারপর CSS থেকে CSSOM (CSS অবজেক্ট মডেল) তৈরি করে।\nরেন্ডার ট্রি নির্মাণ: DOM এবং CSSOM একসাথে মিলে রেন্ডার ট্রি তৈরি করে।\nলেআউট এবং পেইন্টিং: এরপর ব্রাউজার প্রতিটি এলিমেন্টকে তার যথাযথ জায়গায় বসিয়ে দেয় (লেআউট), এবং পরিশেষে সেই এলিমেন্টগুলোকে পেইন্ট করে।","রেন্ডার-ট্রির-প্রয়োজনীয়তা-ও-সুবিধা#রেন্ডার ট্রির প্রয়োজনীয়তা ও সুবিধা:":"রেন্ডার ট্রি প্রয়োজন, কারণ এটি ব্রাউজারের কাছে নির্দিষ্ট ভাবে জানায়, কিভাবে পেজটি দেখাবে।\nএর মাধ্যমে DOM এর পরিবর্তন হলে, ব্রাউজার শুধু সংশ্লিষ্ট অংশটুকু পুনরায় রেন্ডার করে। ফলে পারফরম্যান্স বৃদ্ধি পায়।\nরিয়াক্টের ভি-ডম (Virtual DOM) রেন্ডার ট্রির উপর ভিত্তি করে কাজ করে। ভি-ডম পারফরম্যান্স অপটিমাইজ করার জন্য রেন্ডার ট্রির শুধুমাত্র পরিবর্তিত অংশ পুনরায় আপডেট করে।","উদাহরণ#উদাহরণ:":"function App() {\n    return (\n        <div>\n            <h1>React Render Tree Example</h1>\n            <p>This is a paragraph.</p>\n        </div>\n    );\n}\ndiv এবং তার child nodes (h1 এবং p) একসাথে রেন্ডার ট্রি তৈরি করবে।\nযদি শুধু p ট্যাগ আপডেট হয়, রিয়াক্ট শুধুমাত্র সেই অংশে রেন্ডার করবে, বাকি অংশ অপরিবর্তিত থাকবে।","২-মডিউল-ট্রি-module-tree-কী#২. মডিউল ট্রি (Module Tree) কী?":"মডিউল ট্রি হলো আমাদের অ্যাপ্লিকেশনের সব জাভাস্ক্রিপ্ট মডিউলগুলোর একটি ডিপেনডেন্সি চেইন। এটি দেখায় কোন মডিউলটি কোন মডিউলের উপর নির্ভর করে।","মডিউল-ট্রি-কিভাবে-কাজ-করে#মডিউল ট্রি কিভাবে কাজ করে?":"রিয়াক্ট এবং অন্যান্য মডুলার ফ্রেমওয়ার্কে, বিভিন্ন ফাইল/মডিউল একে অপরের উপর নির্ভর করে কাজ করে। Webpack বা অন্য কোন মডিউল বান্ডলার, মডিউলগুলোকে একটি ট্রি স্ট্রাকচারে সাজায় যেখানে প্রতিটি মডিউল অন্য মডিউলের সাথে সম্পর্কিত হয়।","উদাহরণ-1#উদাহরণ:":"ধরা যাক, আপনার তিনটি ফাইল আছে: App.js, Header.js, এবং Footer.js। App.js তে আপনি Header.js এবং Footer.js কে ইম্পোর্ট করছেন।\n// App.js\nimport Header from \"./Header\";\nimport Footer from \"./Footer\";\nfunction App() {\n    return (\n        <>\n            <Header />\n            <Footer />\n        </>\n    );\n}\nexport default App;\nএখানে মডিউল ট্রি এরূপ হবে:\nApp.js\n  ├── Header.js\n  └── Footer.js","মডিউল-ট্রির-প্রয়োজনীয়তা-ও-সুবিধা#মডিউল ট্রির প্রয়োজনীয়তা ও সুবিধা:":"মডিউল ট্রির কারণে অ্যাপ্লিকেশনকে ছোট ছোট মডিউলে ভাগ করা সম্ভব হয়, যা রক্ষণাবেক্ষণ সহজ করে।\nএটি কোডের পুনরায় ব্যবহারযোগ্যতা বাড়ায়।\nমডিউল ডিপেনডেন্সি বুঝতে এবং অপ্রয়োজনীয় মডিউল বাদ দিতে সাহায্য করে।","রেন্ডার-ট্রি-এবং-মডিউল-ট্রির-সম্মিলিত-কাজ#রেন্ডার ট্রি এবং মডিউল ট্রির সম্মিলিত কাজ":"রিয়াক্ট অ্যাপ্লিকেশন যখন ব্রাউজারে চলে, তখন মডিউল ট্রি মডিউলগুলোকে লোড এবং রিজলভ করে এবং এরপর রেন্ডার ট্রি সেই সব মডিউল থেকে UI রেন্ডার করে।","ইলাস্ট্রেশন#ইলাস্ট্রেশন:":"রেন্ডার ট্রি: একটি গাছের মতো যেখানে প্রতিটি শাখা DOM এর একটি অংশ। শীর্ষে div থাকে এবং তার নিচে child elements।\nমডিউল ট্রি: একটি ডিপেনডেন্সি গাছ যেখানে App.js হলো মূল শাখা এবং অন্যান্য child modules তার সাথে যুক্ত থাকে।","সংক্ষেপে#সংক্ষেপে:":"রেন্ডার ট্রি UI কে ব্রাউজারে দেখানোর জন্য DOM এবং CSSOM এর সম্মিলিত অবস্থা।\nমডিউল ট্রি অ্যাপ্লিকেশনের মডিউলগুলো একে অপরের সাথে কিভাবে সংযুক্ত তা বুঝায়।"}},"/reactive-accilarator/React-js/module-2/event-propagation":{"title":"Event Propagation","data":{"ইভেন্ট-ডেলিগেশন-event-deligation-কি-#ইভেন্ট ডেলিগেশন (event deligation) কি ?":"ইভেন্ট ডেলিগেশন হলো একাধিক এলিমেন্টের জন্য একটাই ইভেন্ট লিসেনার রাখা এবং নতুন কোন এলিমেন্ট যুক্ত হলেও যেন লিসেনার কাজ করে ।ইভেন্ট ডেলিগেশন হলো এমন একটা টেকনিক যা মূলত দুইটা জিনিসে ফোকাস করেঃ-\nএকাধিক এলিমেন্টের জন্য একটাই ইভেন্ট লিসেনার থাকবে ।\nযদি কখনো নতুন এলিমেন্ট যুক্ত হয় তাতেও যেন ইভেন্ট লিসেনার ঠিকঠাক ভাবে কাজ করে।\nধরুন আমাদের একটি প্রোডাক্টের ডাটার লিস্ট আছে যা API থেকে আসতেছে। এবং আমরা চাই এই প্রতিটা ডাটার জন্য এমন একটা ফাংশনালিটি বানাতে যাতে প্রতিটা ডাটার নামে উপর ক্লিক করলেই সেই ডাটার নামের পিছনে একটা ব্যাকগ্রাউন্ড কালার যুক্ত হবে।এখন বিষয়টি এমন ভাবে করতে পারি যে আমরা প্রতিটা আইটেমকে ধরে ধরে তাতে ইভেন্ট লিসেনার লাগিয়ে কাজ করতে পারি। এতে হয়তো একটা সমাধান হতে পারে, কিন্তু যেহেতু ডাটাগুলো API থেকে আসছে তাই আমরা জানিনা হয়তো ডাটার সংখ্যা চেঞ্জ হয়ে যেতে পারে,বা ডাটা বারতে পারে। তখন কি প্রতিটা বারতি ডাটার জন্য আমরা প্রতিবার ইভেন্ট লিসেনার এড করবো ? এটা কখনই সম্ভব না। তাছাড়া প্রতিটা এলিমেন্টের জন্য আলাদা আলাদা লিসেনার এড করতে গেলেও ব্যাপারটা messy হয়ে যাবে। তাহলে উপায় ? উপায় হলো ইভেন্ট ডেলিগেশন টেকনিকচলুন জেনে নেই সেটা কিভাবে করেঃ\n<div class='list-of-item'>\n    <ul id='list'>\n        <li class='item'>Apple</li>\n        <li class='item'>Orange</li>\n        <li class='item'>Strawberry</li>\n        <li class='item'>Banana</li>\n    </ul>\n</div>\nউপরের এই লিস্ট অফ আইটেমগুলোতে আমরা ইভেন্ট ডেলিগেশন টেকনিক এপ্লাই করবো। এতে আমাদের item গুলোর প্যারেন্ট এলিমেন্ট ul এ গিয়ে ইভেন্ট লিসেনার এড করা লাগবে। যাতে আমরা একটা লিসেনার দিয়েই সমস্ত itemগুলোকে ধরতে পারি।\nconst list = document.getElimentById(\"list\");\nlist.addEventListener(\"click\", (e) => {\n    e.target.style.backgroundColor = \"yellow\";\n});\nএখানে আমরা itemগুলোর প্যারেন্ট এলিমেন্ট ulএ ইভেন্ট লিসেনার এড করেছি এবং প্রতিবার ক্লিক এ e.target করে যেটাতে ক্লিক করা হয়েছে সেটাতে ব্যাকগ্রাউন্ড কালার এড করেছি। এর মাধ্যমেই আমরা ইভেন্ট ডেলিগেশন করে ফেলেছি। মানে আমরা ইভেন্টটাকে প্যারেন্টের কাছে ডেলিগেট করেছি।এখন কথা হলো যে, এতে তো ul এর এরিয়াতে ক্লিক পড়লে ul এও ব্যকগ্রাউণ্ড কালার চেঞ্জ হয়ে যাবে।সেক্ষেত্রে আমাদের হেল্প করবে html DOM এর element.matches() মেথড।element.matches()মেথড string হিসেবে একটা ভ্যালু নেয় এবং তা ম্যাচ করে দেখে যে এলিমেন্টের সাথে ম্যাচ করেছে কিনা, এবং Boolean ভ্যালু রিটার্ন করে।তাহলে আমরা এভাবে করতে পারিঃ\nconst list = document.getElimentById(\"list\");\nlist.addEventListener(\"click\", (e) => {\n    if(e.target.matches(\"li\"){\n        e.target.style.backgroundColor = \"yellow\";\n    }\n});\nএভাবে করলে দেখবেন যদি লিস্ট এ নতুন আইটেম যুক্তও হয় তবুও এই একটা লিসেনারই ঠিকঠাক ভাবে কাজ করবে।এটাকেই মূলত ইভেন্ট ডেলিগেশন বলা হয়ে থাকে।","ইভেন্ট-প্রপাগেশন-event-propagation-কি-#ইভেন্ট প্রপাগেশন (event propagation) কি ?":"প্রপাগেশন শব্দের বাংলা অর্থ হলো বিস্তার করা বা প্রসারণ করা বা চলাচল করা।ইভেন্ট প্রপাগেশন হলো জাভাস্ক্রিপ্টের একটা টার্ম । মূলত ইভেন্ট প্রপাগেশন বলতে বুঝায়, যে যদি কোন নেস্টেড এলিমেন্ট থাকে এবং তার প্রতিটা এলিমেন্টেই একটা করে ইভেন্ড লিসেনার এড করা থাকে,তখন যদি একদম ভিতরের কোন এলিমেন্ট ইভেন্টটা ট্রিগার করা হয় তখন আসলে কি ঘটবে?যেমনঃউপরের ছবিতে আমরা তিনটা নেস্টেড এলিমেন্ট দেখতে পাচ্ছি যার প্রতিটাতেই ইভেন্ট লিসেনার এড করা আছে। এবং লিসেনার গুলো এলিমেন্টগুলোতে ক্লিক করলে ট্রিগার হবে।\n<div class='main'>\n    <div class='parent'>\n        <button>Click Me</button>\n    </div>\n</div>\nconst main = document.querySelector(\".main\");\nconst parent = main.querySelector(\".parent\");\nconst button = parent.querySelector(\"button\");\nmain.addEventListener(\"click\", listener);\nparent.addEventListener(\"click\", listener);\nbutton.addEventListener(\"click\", listener);\nfunction listener() {\n    console.log(e.target);\n}\nএখন যদি আমরা button এলিমেন্টে ক্লিক করবো তাহলে আমরা দেখতে পাবো প্রতিটা লিসেনার এ কল হয়ে গেছে এবং কনসল এ তিনটার আউটপুট এসেছে । এইযে একটা ব্যাপার যে ক্লিক করলাম একটাতে আর লিসেনার কল হয়ে গেল তিনটাই, এই ব্যাপারটাকেই বলা হয় event Propagation। মানে ইভেন্টগুলো বাকিদের মাঝেও ছড়িয়ে গেছে।","ইভেন্ট-বাবলিং-bubbling-কি-#ইভেন্ট বাবলিং (Bubbling) কি ?":"const main = document.querySelector(\".main\");\nconst parent = main.querySelector(\".parent\");\nconst button = parent.querySelector(\"button\");\nmain.addEventListener(\"click\", listener);\nparent.addEventListener(\"click\", listener);\nbutton.addEventListener(\"click\", listener);\nfunction listener() {\n    console.log(e.currentTarget);\n}\nআউটপুটঃউপরের কোডটার আউটপুট দেখলে আমরা বুঝতে পারবো যে প্রথমে button তারপর parent এবং সবশেষে main এলিমেন্টে ইভেন্ট লিসেনার ট্রিগার হয়েছে, তার মানে হলো প্রপাগেশন ভিতর থেকে শুরু হয়ে বাহিরের দিয়ে যায়। এটাই হলো প্রোপাগেশন এর ডিফল্ট বিহেবিয়ার। এই যে ভিতর থেকে শুরু হলে বাহিরের দিয়ে ছড়িয়ে যাওয়ার ব্যাপারটাকে অনেকটা বাবল এর মতো চিন্তা করা হয়, তাই একে বলা হয় ইভেন্ট বাবলিং (event bubbling)","ইভেন্ট-কেপচারিং-বা-ট্রিকলিং-capturing-or-trickling-কি-#ইভেন্ট কেপচারিং বা ট্রিকলিং (capturing or trickling) কি ?":"আমরা ইভেন্ট প্রপাগেশনের ডিফল্ট বিহেবিয়ার জানলাম যে প্রপাগেশন ভিতর থেকে শুরু হয়ে বাহিরের দিকে ছড়ায়, কিন্তু আমরা চাইলে এটাকে চেঞ্জ করতে পারি, আমরা চাইলে এটাকে পরিবর্তন করে বাহির থেকে শুরু করে ভিতর দিকে নিতে পারি।তারজন্য আমাদের ইভেন্ট লিসেনার এর তৃতীয় প্যারামিটার এ {capture:true} করে দিতে হয়। ডিফল্টভাবে {capture:false} করা থাকে।\nconst main = document.querySelector(\".main\");\nconst parent = main.querySelector(\".parent\");\nconst button = parent.querySelector(\"button\");\nmain.addEventListener(\"click\", listener, { capture: true });\nparent.addEventListener(\"click\", listener, { capture: true });\nbutton.addEventListener(\"click\", listener, { capture: true });\nfunction listener() {\n    console.log(e.currentTarget);\n}\nআউটপুটঃএইযে আমরা প্রপাগেশনকে capture করে এর ডিরেকশন চেঞ্জ করলাম এটাকে বলা হয় ইভেন্ট কেপচারিং বা ট্রিকলিং (capturing or trickling)।","propagation-in-react#Propagation in React":"রিয়াক্টে সকল ইভেন্ট ই প্রপাগেট হয়,শুধুমাত্র onScroll ইভেন্ট ছাড়া ।","কিভাবে-রিয়াক্টে-প্রপাগেশন-স্টপ-করতে-হয়-#কিভাবে রিয়াক্টে প্রপাগেশন স্টপ করতে হয় ?":"রিয়াক্টে প্রপাগেশন স্টপ করার জন্য event handler এর ভিতরে e.stopPropagation() মেথড কল করে দিতে হয় ।\nfunction Button({ onClick, children }) {\n    return (\n        <button\n            onClick={(e) => {\n                e.stopPropagation(); // এখানে প্রপাগেশন স্টপ করা হয়েছে\n                onClick();\n            }}>\n            {children}\n        </button>\n    );\n}\nexport default function Toolbar() {\n    // এই কম্পোনেন্টে তিনটা এলিমেট আছে নেস্টেড ভাবে এবং প্রতিটা এলিমেন্টেই ইভেন্ট হ্যান্ডেলার এড করা আছে। তার মানে ডিফল্ট ভাবে এখানে প্রপাগেশন হবে ।\n    return (\n        <div\n            className='Toolbar'\n            onClick={() => {\n                alert(\"You clicked on the toolbar!\");\n            }}>\n            <Button onClick={() => alert(\"Playing!\")}>Play Movie</Button>\n            <Button onClick={() => alert(\"Uploading!\")}>Upload Image</Button>\n        </div>\n    );\n}","preventing-the-default-behavior#Preventing the default behavior":"আমরা যখন কোন ফর্ম এর সাবমিট বাটনে ক্লিক করি,তখন ফর্মের ডিফল্ট বিহেবিয়ার হলো ফর্মটা সাবমিট হউয়ার সাথে সাথে ব্রাউজারে পেজটাও রিলোড হয়।আমরা যদি এই ডিফল্ট বিহেবিয়ার কে বন্ধ করতে চাই, তাহলে আমরা e.preventDefault() মেথড কল করে দিতে পারি।\nexport default function Signup() {\n    return (\n        <form\n            onSubmit={(e) => {\n                e.preventDefault();\n                alert(\"Submitting!\");\n            }}>\n            <input />\n            <button>Send</button>\n        </form>\n    );\n}"}},"/reactive-accilarator/React-js/module-2/how-rendering-works":{"title":"How Rendering Works","data":{"":"রিয়াক্ট এপ্লিকেশনে আমরা ব্রাউজার স্ক্রিনে যা কিছু দেখি তার সবকিছুই রিয়াক্টের দ্বারা রেন্ডার হয়ে আসতে হয় ।","রেন্ডার-এবং-কমিট#রেন্ডার এবং কমিট":"এই যে স্ক্রিনে আমরা UI দেখতে পাই তা রিয়াক্টের তিনটা প্রসেসের পর স্ক্রিনে ভিসিবল হয় । চলুন তাহলে জেনে নেই রিয়াক্টের রেন্ডারিং এর এই তিনটা প্রসেস কি আর কিভাবে কাজ করে ।\nTrigering a render:\nRendering the component:\nCommiting to the DOM:","trigger-a-render-ট্রিগারিং-স্টেপ#Trigger a render (ট্রিগারিং স্টেপ):":"মূলত দুইটা করনে রিয়াক্টের render মেথডটা কল হয় বা রেন্ডারিং ট্রিগার হয়ঃ\nইনিশিয়াল রেন্ডার (initial render): একদম সর্বপ্রথম যখন এপ্লিকেশন রান হয় তখন রিয়াক্ট HTML এর একটা root এলিমেন্টের ভিতর রিয়াক্টের সমস্ত কম্পোনেন্টকে রেন্ডার করে দেয় তার React.render() মেথডটাকে কল করার মাধ্যমে ।\nযখন কোন স্টেট আপডেট হয় (Re-render when state update): প্রথমবার সমস্ত কম্পোনেন্ট UI তে এসে যাওয়ার পর, যখন কোন কম্পোনেন্টের ভিতরে কোন স্টেট চেঞ্জ হয় তখন রিয়াক্ট অটেমেটিক ভাবে তার render() মেথডকে কল করে বা রি-রেন্ডার ট্রিগার হয় ।","react-render-your-component-রেন্ডারিং-স্টেপ#React render your component (রেন্ডারিং স্টেপ):":"যখন রিয়াক্টের রেন্ডারিং টা ট্রিগার হয় তখন রিয়াক্ট তার কম্পোনেন্টগুলোকে কল করে। যাতে সে বুঝতে পারে কোথায় পরিবর্তনটা হয়েছে।\nএক্ষেত্রে প্রথম রেন্ডারে রিয়াক্ট তার রুট (root) কম্পোনেন্টকে কল করে\nপরবর্তি সময়ে রি-রেন্ডার ট্রিগার হলে যেই কম্পোনেন্ট থেকে রি-রেন্ডার ট্রিগার হয়েছে সেই কম্পোনেন্টকে কল করে এবং তার প্রথম রেন্ডারের যে Render Tree তার একটা snapshot নিয়ে রাখে এবং পরবর্তি রেন্ডারেরে একটা snapshot নিয়ে তার ভার্চুয়াল ডম এ Diffing এলগরিদমের মাধ্যমে কেলকুলেট করে যে কোথায় পরিবর্তন হয়েছে । তারপর সে নেক্সট স্টেপে চলে যায় কমিট করার জন্য ।\nরেন্ডারিং প্রসেসটা রিকারসিভলি হয়ে থাকে, তার মানে হলো রিয়াক্ট রেন্ডারিং এ যেই কম্পোনেন্টকে কল করেছে তার ভিতর যদি নেস্টেড আরও কোন কম্পোনেন্ট থাকে সেগুলাও রি-রেন্ডার হয়","react-commits-changes-to-the-dom-কমিটিং-স্টেপ#React Commits changes to the DOM (কমিটিং স্টেপ):":"কমিটিং ফেজে এসে রিয়াক্ট DOM মডিফাই করে । এক্ষেত্রে,\nপ্রথম রেন্ডারে রিয়াক্ট DOM এর appendChild() কল করে সমস্ত DOM Nodesগুলোকে রুট এলিমেটে এড করে দেয়\nরি-রেন্ডারের ক্ষেত্রে রিয়াক্ট তার ভার্চুয়াল ডম এ যেই অংশটুকুর পরিবর্তন ডিটেক্ট করতে পারে শুধুমাত্র সেই অংশটুকু DOMএ চেঞ্জ করে দেয়\nপ্রথমবার রেন্ডার হয়ে যাওয়ার পর রিয়াক্ট শুধু তখনি DOM এ চেঞ্জ করে যখন সে দেখতে পারে আগের রেন্ডার এবং পরের রেন্ডারে কোন পার্থক্য আছে। যেই সকল কম্পোনেন্টে কোন প্রকার চেঞ্জ দেখা যায়না রিয়াক্ট সেই সকল কম্পোনেন্টে হাত ই দেয়না।","সবশেষে-ব্রাউজার-পেইন্ট-হয়ঃ#সবশেষে ব্রাউজার পেইন্ট হয়ঃ":"রেন্ডারিং এবং কমিট হয়ে যাওয়ার পর যখন রিয়াক্ট তার DOM টাকে আপডেট করে ফেলে,তখন সে Updated DOMটা ব্রাউজারকে দিয়ে দেয়। এবং ব্রাউজার তা স্ক্রিনে রি-পেইন্ট করে দেয়।"}},"/reactive-accilarator/React-js/module-2/responding-to-event":{"title":"Responding to Event","data":{"":"রিয়াক্ট আমাদের ইভেন্ট হ্যন্ডেল করার সিস্টেম দিয়ে দিয়েছে। ইভেন্ট হ্যান্ডেলার হলো মূলত যখন কোন ইভেন্ট ট্রিগার হয়, যেমন ঃ ক্লিক,হভার,ফোকাস এসব।","adding-event-handler-to-jsx#Adding Event Handler to JSX":"রিয়াক্টে আমরা দুটি স্টেপে Event Handler এড করতে পারিঃ","হ্যান্ডেলার-ফাংশন-ডিক্লেয়ার-করা-এবং-লজিক-এড-করাঃ#হ্যান্ডেলার ফাংশন ডিক্লেয়ার করা এবং লজিক এড করাঃ":"প্রথমত একটা হ্যান্ডেলার ফাংশন ডিক্লেয়ার করতে হবে এবং এতে লজিক ইমপ্লিমেন্ট করতে হবে।\nধরুন, একটা button এ ক্লিক করলে আমরা দেখাতে চাই যে \"বাটনে ক্লিক করা হয়েছে\" সেক্ষেত্রে আমাদের হ্যান্ডেলার ফাংশন ও লজিক হবে এমনঃ\nexport default function Button(){\n    function handleClick(){ // এখনে handleClick নামে একটা হ্যন্ডেলার ফাংশন ডিক্লেয়ার করা হয়েছে এবং তার ভিতরে লজিক ইমপ্লিমেন্ট করা হয়েছে।\n        alert(\"বাটনে ক্লিক করা হয়েছে\");\n    }\n}","হ্যান্ডেলার-ফাংশনটি-বাটনে-এড-করাঃ#হ্যান্ডেলার ফাংশনটি বাটনে এড করাঃ":"এরপর হ্যান্ডেলার ফাংশনটি button এলিমেন্টে এড করতে হবেঃ\nexport default function Button(){\n    function handleClick(){\n        alert(\"বাটনে ক্লিক করা হয়েছে\");\n    }\nreturn <button onClick={handleClick}>Click Me</button> // এখনে বাটনের onClick এ হ্যান্ডেলার ফাংশনটি এড করা হয়েছে।\n}\nএছাড়াও আমরা JSX এর ইনলাইনেও Event Handler ফাংশন এড করতে পারি ।যেমনঃ\nexport default function Button(){\nreturn <button onClick={ function handleClick(){\n        alert(\"বাটনে ক্লিক করা হয়েছে\");\n    }}>Click Me</button> // এখনে বাটনের onClick এ হ্যান্ডেলার ফাংশনটি এড করা হয়েছে।\n}\nঅথবা আরও ছোট করেও লিখতে পারি Arrow Function এর সিনট্যাক্সেঃ\nexport default function Button() {\n    return (\n        <button\n            onClick={() => {\n                alert(\"বাটনে ক্লিক করা হয়েছে\");\n            }}>\n            Click Me\n        </button>\n    ); // এখনে বাটনের onClick এ হ্যান্ডেলার ফাংশনটি এড করা হয়েছে।\n}\nএখানে একটি ফাংশন ডিফাইন করা হয়েছে handleClick নামে এবং তা button এলিমেন্টে as a props পাস করা হয়েছে । handleClick ফাংশনটি একটা event handler ফাংশন।\n👉 ইভেন্ট হ্যান্ডেলার ফাংশনগুলো কম্পোনেন্ট এর ভিতরে ডিফাইন করতে হয় ।\n👉 কনভেনশন অনুযায়ী event handlerএর নামগুলোর শুরুতে handle এবং তারপর\nevent name দিয়ে লিখতে হয়। যেমনঃhandleClick handleMouseEnter\nhandleMouseLeave\nইভেন্ট হ্যান্ডেলার ফাংশনগুলো কম্পোনেন্ট এর ভিতরে পাস করতে হবে, অবশ্যই শুধুমাত্র পাস করা লাগবে, কল করা যাবেনা\nযেমনঃ\n✅ শুধুমাত্র পাস করা হয়েছে\t❌ সরাসরি কল করা হয়েছে\t<button onClick={handleClick}</button>\t<button onClick={handleClick()}</button>\t\nএই দুইটা সিস্টেমের মাঝে খুব ভালো একটা পার্থক্য আছে।\nশুধুমাত্র পাস করা <button onClick={handleClick}</button> মানে হলো - রিয়াক্ট কে বলা যে আমি তোমাকে একটা ইভেন্ট হ্যান্ডেলার দিয়ে দিলাম,তুমি এটা মনে রেখো যে যখনি ওই ইভেন্ট টা ঘটবে তখনই তুমি ফাংশন টা কল করে দিও।\nএক্ষেত্রে যেমন Click ইভেন্ট হ্যান্ডেলার ব্যাবহার করা হয়েছে,তার মানে হলো যখন Click হবে ঠিক তখনি ফাংশনটা কল হবে এবং আউটপুট দেখা যাবে ।\nকিন্তু সরাসরি কল করে দেয়া <button onClick={handleClick()}</button> মানে হলোঃ কম্পোনেন্ট রেন্ডার হওয়ার সাথে সাথেই অটোমেটিক ফাংশন কল হয়ে যাবে , এতে ক্লিক হউয়ার জন্য ওয়েট করবেনা । এতে করে যদি কখনো কোন ফাংশনের দ্বারা State ম্যানেজ করা হয়ে থাকে, তখন বার বার State চেঞ্জ হতে থাকবে আর কম্পোনেন্ট রি-রেন্ডার হতে থাকবে। এটা এপ্লিকেশন একটা infinte লুপে পড়ে যাবে।\nইনলাইনে ফাংশন ডিফাইন করার ক্ষেত্রেও এই একই বিষয় টা খেয়াল রাখতে হয়। যদিও সেখানে শুদুমাত্র আমরা ফাংশনের ডেফিনেশন টাই লিখি ফাংশনটা কল করে দেইনা। তবে IIFE-(immediately invoked function expression) সাথে সাথেই কল হয়ে যায় বলে আমরা ইনলাইনে IIFE-(immediately invoked function expression) লিখতে পারবোনা।","reading-props-in-event-handler#Reading Props in Event Handler":"ইভেন্ট হ্যান্ডেলারগুলো যেহেতু কম্পোনেন্টের ভিতরে লেখা হয় তাই কম্পোনেন্টের যেসব প্রপস আছে তা event handler functionগুলো সরাসরি এক্সেস করতে পারে ।","pass-event-handler-to-child-components-as-props#Pass Event Handler to Child Components as Props":"কখনো কখনো আমাদের প্যারেন্ট কম্পোনেন্ট থেকে চাইল্ড কম্পোনেন্ট এর ইভেন্ট কে ম্যানেজ করা লাগে। সেই ক্ষেত্রে প্যারেন্ট কম্পোনেন্টে event handler function ডিফাইন করে তা প্রপস আকারে চাইল্ড কম্পোনেন্টে পাস করা যায়।চলুন একটু বিস্তারিত বুঝিঃ\nexport default function App() {\n    function handlePlay() {\n        alert(\"Movie is playing\");\n    }\n    return <MovieCard onPlay={handlePlay} />;\n}\nexport default function MovieCard({ onPlay }) {\n    return <button onClick={onPlay}>Play</button>;\n}\nএখানে App কম্পোনেন্ট একটি প্যারেন্ট কম্পোনেন্ট এবং এর চাইল্ড হিসেবে রয়েছে একটা MovieCard কম্পোনেন্ট। এবং মুভিকার্ড কম্পোনেন্ট এ একটা প্রপ্স পাস করা হয়েছে onPlay নামে। এই onPlay প্রপস এর মাধ্যমে মূলত handlePlay নামক একটা ইভেন্ট হ্যান্ডেলার পাস করা হয়েছে ।চাইল্ড কম্পোনেন্ট MovieCard সেই প্রপস টাকে রিসিভ করেছে এবং বাটনের onClick এ তা ট্রিগার করা হয়েছে।তার মানে হলো চাইল্ড কম্পোনেন্ট MovieCard এর বাটনে ক্লিক হলে কোন হ্যন্ডেলার ফাংশন কল হবে তা আমরা প্যারেন্ট কম্পোনেন্টেই ডিফাইন করতে পারি এবং তা প্রপস আকারে পাঠাতে পারি ।","naming-conventions-of-event-handler-props#Naming Conventions of event handler props":"👉 ইভেন্ট হ্যান্ডেলার প্রপস এর নামের শুরুতে on দিয়ে শুরু করতে হয়।\n👉 যেসব রিসার্ভড কিওয়ার্ড আছে যেমনঃ onClick,onHover এসব শুধুমাত্র html এর নেটিভ ইলিমেন্টে ব্যাবহার করা উচিত।\n👉 onদিয়ে শুরু করে তারপর প্রসঙ্গত যেকোন নামেই ব্যাবহার করা যায়। যেমনঃ onClick এর পরিবর্তে onSmash ব্যাবহার করা যায় ।"}},"/reactive-accilarator/React-js/module-2/state-as-a-snapshot":{"title":"State as a Snapshot","data":{"":"স্টেট ভেরিয়েবল নরমাল জাবাস্ক্রিপ্ট ভেরিয়েবলের মতো মনে হলেও এটা মোটেও জাবাস্ক্রিপটের নরমাল ভেরিয়েবল এর মতো কাজ করেনা। চলুন বিস্তারিত জেনে নেয়া যাক।","rendering-takes-a-snapshot-in-time#Rendering takes a snapshot in time:":"এর মানে হলো রিয়াক্ট তার প্রতিটা রেন্ডারে একটা করে snapshot নেয়। এবং তা মনে রাখে। যখনি কোন স্টেট এর ভ্যালু চেঞ্জ হয় তখন রিয়াক্ট কম্পোনেন্টকে রি-রেন্ডার করে এবং পরের রেন্ডারে গিয়ে তার ভ্যালু আপডেট হয়। তার মানে হলো আমরা নরমাল ভেরিয়েবল এ যেমন কোন ভ্যালু চেঞ্জ করলে পরের লাইনেই তা এক্সেস করতে পারি কিন্তু রিয়াক্টে তা পারিনা,কেননা রিয়াক্ট ইনপ্লেস ভ্যালু চেঞ্জ করেনা। ভ্যালুটা চেঞ্জ হয় তার পরের রেন্ডারে।একটা উদাহরণের মাধ্যমে বুঝা যাকঃ\nimport { useState } from \"react\";\nexport default function App() {\n    const [number, setNumber] = useState(1);\n    function handleClick() {\n        setNumbers(number + 5);\n        console.log(number);\n    }\n    return <button onClick={handleClick}>Incriment the number</button>;\n}\nউপরের কোডটার কনসলে আউটপুট কত আশার কথা? স্বাভাবিক ভাবে দেখলে মনে হয় যে আউটপুত 6আসার কথা। কিন্তু না , এখানে আউটপুট আসবে 1। কারণ রিয়াক্ট তার স্টেট চেঞ্জ হলেই ডিরেক্ট ভ্যালু চেঞ্জ করে দেয়না, তাই সেই ভ্যালুটা পরের লাইনগুলোতে এক্সেস করা যায়না।যেই হেন্ডেলার ফাংশনে setter function কল করা হয়েছে সেই হেন্ডেলার এর পুরো কোডটা এক্সিকিউট হয়ে যাওয়ার পর রি-রেন্ডার ট্রিগার হয় এবং পরের রেন্ডারে আপডেটেড ভ্যালু পাওয়া যায়।আরেকটা উদাহরণ যদি আমারা দেখিঃ\nimport { useState } from \"react\";\nexport default function Counter() {\n    const [number, setNumber] = useState(0);\n    return (\n        <>\n            <h1>{number}</h1>\n            <button\n                onClick={() => {\n                    setNumber(number + 1);\n                    setNumber(number + 1);\n                    setNumber(number + 1);\n                }}>\n                +3\n            </button>\n        </>\n    );\n}\nএখানে একটা বাটনে তিনবার setter function কল করা হয়েছে এবং তিনবার স্টেট এর ভ্যালু আপডেট করা হয়েছে। এই কোডটা রান করে আমরা যদি বাটনে ক্লিক করি তাহলে আউটপুট কত আসার কথা- 3?কিন্তু না আউটপুট আসবে 1 ।যেহেতু স্টেট শুধুমাত্র পরের রেন্ডারে চেঞ্জ হয় তাই প্রথম রেন্ডারে স্টেট এর ভ্যালু ছিল 0। তাই প্রথম রেন্ডারে তিনবার setter function কল হলেও তিনবার এ সে স্টেটের ইনিশিয়াল ভ্যালু পাবে 0। আর তাই নাম্বার এর আউটপুট আসবে 1\n<button\n    onClick={() => {\n        setNumber(number + 1);\n        setNumber(number + 1);\n        setNumber(number + 1);\n    }}>\n    +3\n</button>\nএখানে যেটা হচ্ছে প্রথম রেন্ডারে প্রথমবার যখন setNumber(number + 1) করা হচ্ছে তখন আসলে 0 + 1 = 1 করা হচ্ছে যা পরের রেন্ডারে আউটপুটে আসবে,কিন্তু পরের রেন্ডারে যাওয়ার আগে আরও দুইবার setNumber(number + 1) করা হয়েছে,তার মানে তখনও কিন্তু 0 + 1 = 1 ই করা হচ্ছে ।তারমানে শেষবার যখন setNumber(number + 1) করা হয়েছে, তখন কিন্তু 0 + 1 = 1 ই করা হয়েছে এবং স্টেট তার মেমরিতে 1 নিয়েই পরের রেন্ডার ট্রিগার করেছে এবং আউটপুটে 1 প্রিন্ট হয়েছে ।\n<button\n    onClick={() => {\n        setNumber(0 + 1);\n        setNumber(0 + 1);\n        setNumber(0 + 1);\n    }}>\n    +3\n</button>\nআবার যদি কোডটা এমন হয়ঃ\nexport default function Counter() {\n    const [number, setNumber] = useState(0);\n    return (\n        <>\n            <h1>{number}</h1>\n            <button\n                onClick={() => {\n                    setNumber(number + 5);\n                    setTimeout(() => {\n                        alert(number);\n                    }, 3000);\n                }}>\n                +5\n            </button>\n        </>\n    );\n}\nএখানে বাটনে নাম্বারের স্টেট চেঞ্জ করা হয়েছে এবং একটা setTimeout() কল করা হয়েছে ৩ সেকেন্ডের জন্য। এবং তাতে নাম্বার এর ভ্যালুটা এলার্টে নেয়া হয়েছে।এখানেও হয়তো মনে হতে পারে যে নাম্বার এর ভ্যালু এলার্টে 5 আসবে,কেননা যতক্ষণে ৩ সেকেন্ড টাইমার শেষ হবে ততক্ষণে স্টেট রি-রেন্ডার হয়ে যাবে এবং আমরা এলার্টে আপডেটেড ভ্যালু পাবো ।কিন্তু না এখানেও ব্যাপারটাকে snapshot হিসেবে চিন্তা করতে হবে, এখানে timeOut টা তিন সেকেন্ড পরে হলেও যখন টাইমআউট শুরু হয়েছে তখন কিন্তু সে number এর ভ্যালু 0 নিয়েই গিয়েছে, তাই টাইমার যতই নিয়ে যাক প্রথম রেন্ডারে সে তাই পাবে যেটা তার ইনিশিয়াল ভ্যালু।অর্থাৎ রিয়াক্টের একটা রেন্ডারে কখনই সরাসরি ভ্যালু চেঞ্জ হয়না, বরং স্টেট চেঞ্জ হলে একটা রি-রেন্ডার ট্রিগার হয় এবং পরের রেন্ডারে গিয়ে তার আপডেটেড ভ্যালু পাওয়া যায়।"}},"/reactive-accilarator/React-js/module-2/understanding-state":{"title":"Understanding State","data":{"":"রিয়াক্ট এপ্লিকেশনে যখনি কোন এন্টারেকশনে কোনকিছু চেঞ্জ করা প্রয়োজন হয় তখনি স্টেট এর প্রয়োজন হয়।","স্টেট-state-কি-#স্টেট (State) কি ?":"State এর বাংলা মানে হলো অবস্তা । ভিন্ন ভিন্ন অবস্থার স্টেট হয় ভিন্ন ভিন্ন।ধরুন একটা Button এ ক্লিক করলে একটা Modal ওপেন হবে । এইযে Modal একবার ওপেন হবে এটা একটা অবস্থা, আবার যখন Modal ক্লোজ থাকবে সেটা আবার আরেক অবস্থা। এটাকেই বলা হয় State।রিয়াক্ট যেহেতু একটা রিয়াক্টিভ এপ্লিকেশনে সাহায্য করে তাই রিয়াক্ট যাতে বুঝতে পারে যে এপ্লিকেশনে কিছু চেঞ্জ হয়েছে,তাকে রি-রেন্ডার করতে হবে, এবং কোন অবস্থায় কি ছিল, সেটা তাকে মনে রাখতে হবে তাই তাকে এপ্লিকেশনের বিভিন্ন স্টেট ম্যানেজ করা লাগে। আর এই কাজটা রিয়াক্ট করে তার বিল্ট ইন hook useState এর মাধ্যমে।","এই-কাজগুলো-কি-আমরা-রেগুলার-ভেরিয়েবল-নিয়ে-কন্ডীশনালি-করতে-পারিনা-#এই কাজগুলো কি আমরা রেগুলার ভেরিয়েবল নিয়ে কন্ডীশনালি করতে পারিনা ?":"নাহ, রিয়াক্ট এপ্লিকেশনে আমরা সেটা পারিনা,কেননা রিয়াক্ট এপ্লিকেশনে কোনকিছু চেঞ্জ হলেই তার কম্পোনেন্টকে রি-রেন্ডার করতে হয় এবং UI আপডেট করতে হয়। কিন্তু আমরা যদি লোকাল ভ্যারিয়েবল নিয়ে তার মদ্ধে ভ্যালু চেঞ্জ করে দেই,তাহলে রিয়ায়ক্ট সেটাকে মনে রাখতে পারেনা এবং তাতে সে রি-রেন্ডার ও ট্রিগার করেনা। তাহলে হয়তো ভাবতে পারেন যে ,আমরা ম্যনুয়ালি UI আপডেট করে দিলেইতো হয়ে গেল, হ্যাঁ - কিন্তু তাহলে আমরা রিয়াক্টে কেন এসেছি ? রিয়াক্টে এসেছি কারণ যাতে আমাদের কোন কিছু চেঞ্জ হলেই যাতে UIঅটোমেটিক আপডেট হয়।","লোকাল-ভেরিয়েবল-এর-ক্ষেত্রে-যেসব-বিষয়-হয়নাঃ#লোকাল ভেরিয়েবল এর ক্ষেত্রে যেসব বিষয় হয়নাঃ":"Local variables don't persist between renders: মানে হলো যখন কম্পোনেন্ট রি-রেন্ডার হয়, তখন পুরো কম্পোনেন্টটা আবার নতুন করে রেন্ডার হয়। তখন সে তার লোকাল ভেরিয়েবল এ আগের রেন্ডারে কি চেঞ্জ হয়েছিল তা সে মনে রাখেনা ।\nChanges to local variables won't trigger renders: মানে হলো লোকাল ভেরিয়েবল চেঞ্জ হলে রিয়েক্ট বুঝতেই পারেনা যে, তাকে কম্পোনেন্ট রি-রেন্ডার করতে হবে।\nকম্পোনেন্টকে নতুন ডাটা দিয়ে আপডেট হতে হলে দুইটা জিনিস লাগেঃ\nRetain the data between renders: এর মানে হলো রি-রেন্ডারের পর কম্পোনেন্টকে জানতে হয় যে তার আগের রেন্ডারে কি চেঞ্জ হয়েছিল,যেটা সে UI তে আপডেট করবে।\nTrigger a Re-render: মানে হলো কোন স্টেট চেঞ্জ হলেই রিয়াক্টকে তার রি-রেন্ডার ট্রিগার করতে হয় ।\nuseState হুক এই দুটি জিনিস দিয়ে থাকেঃ\nA State Variable: useState হুক একটি স্টেট ভেরিয়েবল দেয় যা সে প্রতিটা রি-রেন্ডারে মনে রাখতে পারে ।\nA Setter Function:useState হুক একটি setter function দেয় যা দিয়ে সে স্টেট ভেরিয়েবলকে চেঞ্জ করতে পারে ।","usestate-হুক---কিভাবে-লিখতে-হয়-এবং-কিভাবে-ব্যাবহার-করতে-হয়-#useState হুক - কিভাবে লিখতে হয় এবং কিভাবে ব্যাবহার করতে হয় ?":"সিনট্যাক্সঃ\nconst [currentValue, setterFunction] = useState(initialValue);","রিয়াক্ট-থেকে-usestate-হুক-ইম্পোর্ট-করতে-হবেঃ#রিয়াক্ট থেকে useState হুক ইম্পোর্ট করতে হবেঃ":"import { useState } from \"react\";\nexport default function App() {\n    return (\n    <>\n        <h1>Count:  </h1>\n        <button>Click to Incriment Count</<button>\n    </>\n    );\n}","usestate-হুক-ডিক্লেয়ার-করা-#useState হুক ডিক্লেয়ার করা ।":"import { useState } from \"react\";\nexport default function App() {\nconst [count, setCount] = useState(0);\n    return (\n    <>\n         <h1>Count:  </h1>\n        <button>Click to Incriment Count</<button>\n    </>\n    );\n}","setter-function-এর-মাধ্যমে-state-variable-এর-ভ্যালু-চেঞ্জ-করা-এবং-ভ্যালু-ব্যাবহার-করা-#setter function এর মাধ্যমে State variable এর ভ্যালু চেঞ্জ করা এবং ভ্যালু ব্যাবহার করা ।":"import { useState } from \"react\";\nexport default function App() {\nconst [count, setCount] = useState(0);\n    function handleCountIncriment() {\n        setCount(count + 1);\n    }\n    return (\n    <>\n         <h1>Count: {count}  </h1>\n        <button onClick={handleCountIncriment}>Click to Incriment Count</<button>\n    </>\n    );\n}\n**রিয়াক্টে সকল ফাংশন যেগুলা শুরুতে use দিয়ে নামকরন করা হয়েছে সেগুলা প্রতিটাই হলো হুক। শুধু useState ই নয়,রিয়েক্টের এমন বিল্ট ইন আরও অনেক হুক রয়েছে যেগুলো আমরা পরে যানতে পারবো । এসব প্রতিটা হুক রিয়াক্টে আলাদা আলাদা ফিচার যুক্ত করেছে। তাই রিয়াক্টের হুকগুলো হলো একেকটা স্পেশাল ফাংশন । তাই এগুলোকে নরমাল ফাংশনের মতো চিনটা করলে হবেনা। আর রিয়াক্টের হুকগুলোকে সবসময় কম্পোনেন্টের টপ লেভেলে ব্যাবহার করতে হয় । এগুলোকে কখনওই কোন কন্দীশন,লুপ বা অন্যান্য ফাংশনের ভিতরে ব্যাবহার করা যাবেনা । **","রিয়াক্টের-usestate-হুক-কিভাবে-কাজ-করে-#রিয়াক্টের useState হুক কিভাবে কাজ করে ?":"যখনি আমরা কোন কম্পোনেন্টের ভিতরে useState লিখি,তার মনে হলো রিয়াক্টকে বলা যে, আমার এই কম্পোনেন্টে কিছু স্টেট আছে সেগুলো তোমাকে মনে রাখতে হবে ।\nconst [index, setIndex] = useState(0);\nএক্ষেত্রে আমরা স্টেট ভেরিয়েবল নিয়েছি index । তাহলে রিয়াক্ট প্রতিটা রেন্ডারে index এর ভ্যালুটাকে তার মেমরিতে মনে রাখবে।\nStateএর নেমিং কনভেনশন হলো - যেই নামে স্টেট ভেরিয়েবল নেয়া হয়েছে,\nsetterFunction এর নামটাও সেই নামটাকে ফলো করেই দেয়া উচিত । যেমন: const\n    [index, setIndex] = useState(0);","রেন্ডার-এবং-রি-রেন্ডারিং-প্রসেসঃ#রেন্ডার এবং রি-রেন্ডারিং প্রসেসঃ":"const [index, setIndex] = useState(0);\nপ্রথমবার যখন কম্পোনেন্ট রেন্ডার হয়ঃ আমারা স্টেট ভেরিয়েবলের ইনিশিয়াল যে ভ্যালু দিয়েছিলাম সেটাই রিটার্ন করে। এক্ষেত্রে initial value = 0 তাই স্টেট 0 রিটার্ন করবে ।\nযখন স্টেট ভেরিয়েবল এর ভ্যালু আপডেট করা হয়ঃ যখন ইউজারের ক্লিক বা কোন ইন্টারেকশনে setter function দিয়ে ভ্যালু আপডেট করা হয় setIndex( index + 1 ) তখন স্টেটের ভ্যালু চেঞ্জ হয়ে হয় 1 এবং রিয়েক্টকে তা মনে রাখতে বলে এবং তারপর setter function রিয়াক্টের Render() মেথড কল করে দিয়ে আরেকটা রেন্ডার ট্রিগার করে দেয় ।\nদ্বিতীয়বার যখন রেন্ডার হয়ঃ তখন কম্পোনেন্ট আবার নতুন করে রেন্ডার হয় এবং রিয়াক্ট দেখে যে useState(0) এর initial value 0  কিন্তু আগের রেন্ডারে যখন state value চেঞ্জ হয়েছে তখন রিয়াক্ট সেটাকে মনে রেখেছে, আর তাই সে তখন index এর ভ্যালু 1 রিটার্ন করবে ।\nআর এভাবেই প্রতিটা রেন্ডার চলতে থাকবে ।","যদি-একটা-কম্পোনেন্টে-মাল্টিপল-স্টেট-ভ্যারিয়েবল-নেয়ার-প্রয়োজন-হয়#যদি একটা কম্পোনেন্টে মাল্টিপল স্টেট ভ্যারিয়েবল নেয়ার প্রয়োজন হয়?":"কোন কম্পোনেন্টের যদি মাল্টিপল স্টেট ম্যানেজ করা লাগে,তাহলে মাল্টিপল useState কল করা যায়। এতে কোন সমস্যা নেই। তবে যদি একটা স্টেট আরেকটার সাথে রিলেটেড হয় তাহলে আমরা স্টেট ভ্যালু Array বা object হিসেবে রেখেও কাজ করতে পারি।","state-হলো-কম্পোনেন্টের-প্রাইভেট-ডাটা#State হলো কম্পোনেন্টের প্রাইভেট ডাটা":"রিয়াক্টের স্টেট তার কম্পোনেন্টের ভিতরেই সীমাবদ্ধ। স্টেট কে বলা হয় কম্পোনেন্টের প্রাইভেট ডাটা।ধরুন কোন কম্পোনেন্টে স্টেট ব্যাবহার করা হয়েছে। এখন যতবার ওই কম্পোনেন্টকে ব্যাবহার করা হোক না কেন,প্রতিটার জন্য তার স্টেট হবে আলাদা। এমন নয় যে,কম্পোনেন্ট রি-ইউজ করার জন্য একটার স্টেট চেঞ্জ হলে বাকিগুলোও স্টেট চেঞ্জ করে ফেলবে। এটা কক্ষনো হবেনা। কারণ প্রতিটা কম্পোনেন্টের স্টেট তার ভিতরে আইসোলেটেড অবস্থায় থাকে এবং সেগুলো ইউনিক হয়।তবে যদি আমাদের রিকোয়ারমেন্ট এমন হয় যে আমাদের প্রতিটা রি-ইউজেবল কম্পোনেন্টের স্টেট sync থাকবে বা একটায় স্টেট চেঞ্জ করলে তা প্রতিটায় এফেক্ট করবে,তাহলে আমারা lifting state up টেকনিক ব্যাবহার করতে পারি। যা নিয়ে আমরা পরে বিস্তারিত জানবো ।"}},"/reactive-accilarator/frontend-focus-topic":{"title":"Frontend Focus Topic","data":{"":"That's great! Since you've already learned React and Next.js, you're off to a solid start. To become a well-rounded frontend developer, here are some key areas to focus on next:","1-advanced-javascript#1. Advanced JavaScript":"Deepen your understanding of JavaScript (ES6+).\nLearn about asynchronous programming (Promises, Async/Await).\nStudy closures, event loops, and execution contexts.","2-state-management#2. State Management":"Learn advanced state management tools like Redux, Recoil, or Zustand.\nUnderstand context API more deeply for managing local state.","3-typescript#3. TypeScript":"Since many modern React/Next.js projects use TypeScript, learning this will make your code more robust and reduce bugs.","4-css-and-design-systems#4. CSS and Design Systems":"Explore CSS frameworks like TailwindCSS, Material-UI, or Chakra UI.\nLearn about CSS-in-JS libraries like Styled Components and Emotion.\nStudy responsive design and grid systems (Flexbox, Grid).\nUnderstand design systems and how to create or work with component libraries.","5-testing#5. Testing":"Learn to test your components using Jest, React Testing Library, or Cypress.\nUnderstand the concepts of unit testing, integration testing, and end-to-end testing.","6-version-control--collaboration#6. Version Control & Collaboration":"Improve your understanding of Git and tools like GitHub, GitLab, or Bitbucket.\nLearn about branching strategies, pull requests, and code reviews.","7-performance-optimization#7. Performance Optimization":"Learn about code-splitting, lazy loading, and optimizing images in React/Next.js.\nFocus on Lighthouse, PageSpeed Insights, and tools for optimizing web performance.","8-seo-for-frontend#8. SEO for Frontend":"Dive deeper into Next.js SEO features.\nLearn about server-side rendering (SSR), static site generation (SSG), and dynamic routing.","9-progressive-web-apps-pwa#9. Progressive Web Apps (PWA)":"Learn how to build PWAs, including service workers, caching strategies, and offline functionality.","10-build-tools#10. Build Tools":"Familiarize yourself with Webpack, Babel, Vite, or Parcel.\nUnderstand CI/CD pipelines and how to automate testing, building, and deployment.","11-authentication-and-security#11. Authentication and Security":"Explore OAuth, JWT, and integrating authentication systems (e.g., Firebase Auth, NextAuth).\nLearn about web security essentials (XSS, CSRF, HTTPS, etc.).\nBy working through these topics, you'll significantly enhance your frontend development skills and become more prepared for real-world projects."}},"/reactive-accilarator/git":{"title":"গিট এবং গিটহাব","data":{"গিট-কি-#গিট কি ?":"গিট হলো একটি ভার্সন কনট্রোল টুল।ভার্সন কনট্রোল কি ?ধরুন আপনি আপনার কম্পিউটার এ কোন ডকুমেন্ট লিখছেন,সেখানে হয়তো আজ কিছু লিখছেন আবার হয়তো অন্যদিন কিছু লিখছেন। এভাবে হয়তো আপনার কখনও মনে হলো যে আপনি গত দুইদিন যা লিখেছেন তা হয়তো সঠিক নয়, আপনি তা ডিলিট করে আবার দুই দিন আগে যা লিখেছেন সেই অবস্থায় ফিরত যেতে চান। এক্ষেত্র আপনাকে যেটা করা লাগবে তা হলো এই দুইদিনের সমস্ত লিখা মুছে ফেলতে হবে। এখন এই অবস্থায় আপনার যদি মনে না থাকে যে আপানর ঠিক কোন পর্যন্ত মুছা উচিত বা দুইদিন আগে ঠিক কতটুকু লেখা হয়েছিলো,তখন আপনি কি করবেন? ঠিক এই কাজটায় গিট হেল্প করে থাকে। গিট কোন ফাইলের প্রতিটা চেঞ্জেস গুলোকে মনিটরিং করে বা ট্র্যাক রাখে এবং প্রতিটা চেঞ্জেস গুলোকে ভার্সনাইজ করে। যাতে আপনি যেকোন সময় যেকোনো ভার্সনে সুইচ করতে পারেন ।","গিটের-কিছু-প্রয়োজনীয়-কমান্ড-যা-আমাদের-গিটের-লোকাল-রিপজিটরিতে-ফাইল-ম্যানেজ-করতে-প্রয়োজন-হবে#গিটের কিছু প্রয়োজনীয় কমান্ড যা আমাদের গিটের লোকাল রিপজিটরিতে ফাইল ম্যানেজ করতে প্রয়োজন হবে।":"গিট ইনিশিয়ালাইজ করা\n git init\nগিট এর স্ট্যাটাস চেক করা\ngit status\nফাইলকে গিটের ট্রাক করার জন্য স্টেজ এ উঠানো\ngit add <filename> //For stage any specific file\nor\ngit add --all // if you want to add all files\nor\ngit add .  // if you want to add all files in the current working directory\nকমিট করা\ngit commit -m \"<commit massage>\"\nগিট লগ চেক করা\ngit log\nor\ngit log --oneline\nএকটা কমিট থেকে অন্য কমিটের অবস্থায় ফিরে যাওয়া\ngit reset --hard <commit id>\nগিটের প্রতিটা চেঞ্জের রেফারেন্স সহ লগ দেখার জন্য\ngit reflog\nগিটের ট্র্যাক থেকে কোন ফাইল রিমূভ করা\ngit rm <filename>\nব্রাঞ্চ তৈরী করা\ngit branch <branch name eg: bugfix/fixname >\nব্রাঞ্চ লিস্ট দেখা\ngit branch --list\nএক ব্রাঞ্চ থেকে অন্য ব্রাঞ্চ এ সুইচ করা\ngit switch <branch name >\nএক ব্রাঞ্চের কোড অন্য ব্রাঞ্চে মার্জ করা\nএক্ষেত্রে যেই ব্রাঞ্চে অন্য ব্রাঞ্চের কোড আনতে হবে,প্রথমে git switch <branchname> করে প্রথমে সেই ব্রাঞ্চে যেতে হবে। তারপর কমান্ড দিতে হবে।\ngit merge <branch name >\nগিট থেকে ব্রাঞ্চ ডিলিট করা\ngit branch -d <branch name >\nব্রাঞ্চ নেম পরিবর্তন করতে চাইলে\n এক্ষেত্রে যেই ব্রাঞ্চের নাম পরিবর্তন করতে হবে আমাদেরকে প্রথমে git switch <branchname> করে প্রথমে সেই ব্রাঞ্চে যেতে হবে। তারপর কমান্ড দিতে হবে। \ngit branch -m <updated branch name >\nগিট স্ট্যাস করা (আনকমিটেড কাজ গিটের ড্রাফট এ সেভ রাখা)\ngit stash\nগিট স্ট্যাস লিস্ট চেক করা\ngit stash list\nগিটের স্ট্যাস এ কি কি সেভ রাখা হয়েছিল তা দেখতে\ngit stash show -p\nগিটের স্ট্যাস এপ্লাই করার জন্য\ngit stash apply <statsh id>\nor\ngit stash pop\nকোন ফাইল ভুলবশত গিটে এড করে ফেললে বা কমিট করার পর যদি মনে হয় ফাইলটা গিট থেকে ইগনোর করতে হবে তাহলে:","১ম-স্টেপঃ#১ম স্টেপঃ":"একটা .gitignore ফাইল বানাতে হবে এবং তাতে উক্ত ফাইলের নাম এড করা লাগবে ।","২য়-স্টেপঃ#২য় স্টেপঃ":"git rm --cached <filename>\nগিটহাব বা রিমোট রিপোজিটরিতে ফাইল এড করা বা পুশ করার জন্যঃ","১ম-স্টেপঃ-1#১ম স্টেপঃ":"git remote add <origin name eg: orgin or something > <github repository link>\nexample:git remote add origin git@github.com:Deveripon/reactive-accelarator.git","২য়-স্টেপঃ-1#২য় স্টেপঃ":"git push -u <origin name> <branch name>\nexample:git push -u origin main\nরিমোট রিপোজিটরি থেকে পুল করা\ngit pull"}},"/reactive-accilarator":{"title":"Index","data":{"কিভাবে-এই-কোর্স-থেকে-সর্বোচ্চ-ফলাফল-পেতে-পারি-#কিভাবে এই কোর্স থেকে সর্বোচ্চ ফলাফল পেতে পারি ?":"এই কোর্স থেকে সবচেয়ে ভালো ফলাফল পেতে হলে আমাদের নিচের পয়েন্টগুলো অবশ্যই মাথায় রাখতে হবে।\nধৈর্যঃ\nরিডিং পড়ার অভ্যাস\nভিডিও স্কিপ করা যাবেনা\nকুইজে অংশগ্রহণ\nআসাইন্মেন্ট জমা দেয়া\nনিজেকে পুশ করা ও মোটিভেটেড রাখা\nনিঃসংকোচে আস্ক ফর হেল্প\nএটেন্ড লাইভ সেশনস\nলজিকাল হতে হবে"}},"/reactive-accilarator/javascript-refresher":{"title":"Advanced JavaScript","data":{"scope-in-javascript#Scope in JavaScript":"","primitive-and-reference-types-value#Primitive and Reference types Value":"","primitive#Primitive":"প্রিমিটিভ এর বাংলা অর্থ হলো আদিম। জাভাস্ক্রিপ্টে যেসব DATATYPE আছে যেমনঃ\nString\nNumber\nBoolean\nNull\nUndefined\nএইগুলো হলো জাভাস্ক্রিপ্টের মূল বা একক। এগুলো ব্যাবহার করে অন্যান্য ডাটা বানানো হয়। এগুলোকে বলা হয় প্রিমিটিভ ডাটা বা ভ্যালু ।","references#References":"জাভাস্ক্রিপ্টের Array এবং Object কে বলা হয় রেফারেন্স টাইপ ডাটা বা ভ্যালু ।","প্রিমিটিভ-এবং-রেফারেন্স-টাইপ-ডাটার-পার্থক্যঃ#প্রিমিটিভ এবং রেফারেন্স টাইপ ডাটার পার্থক্যঃ":"প্রিমিটিভ এবং রেফারেন্স টাইপ ডাটার মধ্যে মূল যেই পার্থক্য রয়েছে তা হলো এর ডাটার বিহেবিয়ার নিয়ে। যেমন নিচে উদাহরণের মাধ্যমে বুঝানো হলোঃ","primitive-1#Primitive":"প্রিমিটিভ ডাটা শুধুমাত্র ভ্যালুটা শেয়ার করে। ডাটার রেফারেন্স শেয়ার করেনা।","reference#Reference":"এখানে a কে যখন b দ্বারা রি-এসাইন করা হয়েছে তখন স্বাভাবিক ভাবেই আ এর ভ্যালু চেঞ্জ হয়ে b এর যেই ভ্যালু ছিল তা হয়ে গিয়েছে। কিন্তু নিচে যখন b এর ভ্যালু চেঞ্জ করা হয়েছে সেই চেঞ্জটা a তেও এসে প্রভাব ফেলেছে এবং a সহ চেঞ্জ হয়ে গেছে। কারণ এখানে a তে যখন b এসাইন করা হয়েছিল তখন a তে b এর রেফারেন্স সহ চলে গেছিল,তাই যেকোন একটা কে চেঞ্জ করলেই দুইটাই চেঞ্জ হয়ে যাচ্ছে।এখানে যেই বিষয়টা হয়েছে তা হলোঃa আর b যখন ডিফাইন করা হয়েছে তখন মেমরিতে দুইটা Array এলোকেটেড করা হয়েছে এবং Array দুটি তাদের যেই Variables এর নাম a এবং b তার দিয়ে পয়েন্ট করে আছে। কিন্তু যখন a = b করা হয়েছে তখন দুইটা পয়েন্টার এক হয়ে b এর ভ্যালু থেকে a আর b এর দিকে পয়েন্ট হয়ে গেছে। তাই এখন a অথবা b যেইটাই চেঞ্জ করা হউক না কেন তা দুইটাকেই চেঞ্জ করবে।এটাই হলো primitives আর References ভ্যালুর মধ্যে মূল পার্থক্য ।","shallow-copy-vs-deep-copy#Shallow Copy Vs Deep Copy":"জাভাস্ক্রিপ্টে \"শ্যালো কপি\" (Shallow Copy) এবং \"ডিপ কপি\" (Deep Copy) হল দুটি আলাদা প্রক্রিয়া যেগুলো ব্যবহার করে একটি Object বা Array'র কপি তৈরি করা হয়। তবে এদের মধ্যে বড় পার্থক্য হচ্ছে কিভাবে ডেটা কপি করা হয়। নিচে প্রতিটি কনসেপ্ট বিস্তারিতভাবে ব্যাখ্যা করছি:","শ্যালো-কপি-shallow-copy#শ্যালো কপি (Shallow Copy)":"শ্যালো কপিতে কেবলমাত্র অবজেক্টের প্রথম লেভেলের ভ্যালুগুলি কপি করা হয়। এর মানে হলো, যদি অবজেক্ট বা আরে'র মধ্যে নেস্টেড অবজেক্ট থাকে, তাহলে সেগুলি রেফারেন্স হিসেবে কপি হয়। অর্থাৎ, নেস্টেড অবজেক্ট বা আরে'র জন্য একটি রেফারেন্স তৈরি হয়, নতুন অবজেক্টে একই ডেটা শেয়ার করে।","উদাহরণ#উদাহরণ:":"let originalArray = [1, 2, { a: 3, b: 4 }];\n// শ্যালো কপি তৈরি করা\nlet shallowCopy = [...originalArray];\nconsole.log(shallowCopy); // [1, 2, { a: 3, b: 4 }]\n// নেস্টেড অবজেক্ট পরিবর্তন করা\nshallowCopy[2].a = 10;\nconsole.log(originalArray); // [1, 2, { a: 10, b: 4 }]\nconsole.log(shallowCopy); // [1, 2, { a: 10, b: 4 }] // নেস্টেড অবজেক্ট রেফারেন্স একারে কপি হওয়ার কারনে কপি ডাটাতে চেঞ্জ করলেও তা মেইন ডাটাকেও চেঞ্জ করে দিয়েছে।\nএই উদাহরণে দেখা যাচ্ছে যে, originalArray এবং shallowCopy একই নেস্টেড অবজেক্ট শেয়ার করছে। যখন shallowCopy[2].a পরিবর্তন করা হয়, তখন মূল অবজেক্টেও পরিবর্তন ঘটে। এটি শ্যালো কপির একটি সীমাবদ্ধতা।","শ্যালো-কপি-তৈরি-করার-পদ্ধতি#শ্যালো কপি তৈরি করার পদ্ধতি:":"Spread Operator: let copy = [...array];","ডিপ-কপি-deep-copy#ডিপ কপি (Deep Copy)":"ডিপ কপিতে একটি অবজেক্টের প্রতিটি লেভেলের কপি তৈরি করা হয়, এমনকি নেস্টেড অবজেক্টেরও আলাদা কপি করা হয়। এর ফলে মূল অবজেক্টের কোনো পরিবর্তন নতুন কপি অবজেক্টকে প্রভাবিত করে না এবং বিপরীতও ঘটে না।","উদাহরণ-1#উদাহরণ:":"let originalArray = [1, 2, { a: 3, b: 4 }];\n// ডিপ কপি তৈরি করা (JSON পদ্ধতি ব্যবহার করে)\nlet deepCopy = JSON.parse(JSON.stringify(originalArray));\nconsole.log(deepCopy); // [1, 2, { a: 3, b: 4 }]\n// নেস্টেড অবজেক্ট পরিবর্তন করা\ndeepCopy[2].a = 10;\nconsole.log(originalArray); // [1, 2, { a: 3, b: 4 }]\nconsole.log(deepCopy); // [1, 2, { a: 10, b: 4 }]\nএখানে দেখা যাচ্ছে যে, deepCopy[2].a পরিবর্তন করার পরেও originalArray এর নেস্টেড অবজেক্ট অপরিবর্তিত রয়েছে। কারণ, ডিপ কপিতে নেস্টেড অবজেক্টের নতুন কপি তৈরি হয়।","ডিপ-কপি-তৈরি-করার-পদ্ধতি#ডিপ কপি তৈরি করার পদ্ধতি:":"JSON.parse(JSON.stringify(obj)): সহজ পদ্ধতি, তবে ফাংশন ও undefined হ্যান্ডেল করতে পারে না।\nLodash লাইব্রেরির cloneDeep মেথড Lodash একটি জনপ্রিয় জাভাস্ক্রিপ্ট লাইব্রেরি, যা অনেক ধরনের ইউটিলিটি ফাংশন সরবরাহ করে। cloneDeep হল একটি বিশেষ মেথড যা ডিপ কপি তৈরি করতে পারে।\nউদাহরণ:প্রথমে lodash ইনস্টল করতে হবে:\n npm i --save lodash\nতারপর\nconst _ = require(\"lodash\");\nlet originalObject = { a: 1, b: { c: 2, d: 3 } };\nlet deepCopiedObject = _.cloneDeep(originalObject);\ndeepCopiedObject.b.c = 10;\nconsole.log(originalObject); // { a: 1, b: { c: 2, d: 3 } }\nconsole.log(deepCopiedObject); // { a: 1, b: { c: 10, d: 3 } }\nLodash এর cloneDeep মেথড সমস্ত ডেটা টাইপ এবং নেস্টেড অবজেক্ট সঠিকভাবে হ্যান্ডেল করতে পারে। এটি ফাংশন, তারিখ, Map, Set এবং অন্যান্য জটিল ডেটা স্ট্রাকচার হ্যান্ডেল করার ক্ষেত্রে খুবই কার্যকর।","শ্যালো-কপি-বনাম-ডিপ-কপি-পার্থক্য#শ্যালো কপি বনাম ডিপ কপি পার্থক্য:":"শ্যালো কপি\tডিপ কপি\tশুধুমাত্র প্রথম লেভেলের কপি করে।\tপ্রতিটি লেভেলের জন্য নতুন কপি তৈরি করে।\tনেস্টেড অবজেক্টগুলো রেফারেন্স হিসেবে কপি হয়।\tনেস্টেড অবজেক্টগুলোর সম্পূর্ণ নতুন কপি হয়।\t\nএই দুই ধরনের কপির মধ্যে পার্থক্য নির্ভর করে আপনার প্রয়োজনের উপর।","this-এর-ব্যাবহার-কোথায়-এবং-কিভাবে-#this এর ব্যাবহার। কোথায় এবং কিভাবে ।":"","implicit-binding#Implicit Binding":"👉রুলসঃ দেখতে হবে যে,ফাংশন কল হয়েছে কোথায়, যেখানে কল হয়েছে তার সামনে কি কোন ডট আছে কিনা,যদি থাকে তাহলে তার সামনে কি আছে। যদি কিছু থাকে তাহলে সেটাই হলো this । এক্ষেত্রে এক্সেপ্সন হলো this শুধু নরমাল ফাংশনেই কাজ করবে। কিন্তু Arrow ফাংশন this বলে কিছু চিনবেনা।উদাহরণঃ\nlet player = {\n    name: \"Mashrafe\",\n    age: 38,\n    printPlayerName: function () {\n        console.log(this.name); // এখানে this দিয়ে `player` অবজেক্টটাকে পয়েন্ট করা হয়েছে।\n    },\n};\nplayer.printPlayerName();","explicitly-binding#Explicitly Binding":"","call#.call()":"👉 কখনও কখনও বাহিরের কোন ফাংশনকে অন্য কোন অবজেক্ট দিয়ে কল করার প্রয়োজন হয় । সেক্ষেত্রে সিনট্যাক্স হয় এরকমঃ\nfunction printName() {\n    // এটা একটা গ্লোবাল ফাংশন\n    console.log(this.name);\n}\nlet player = {\n    name: \"Sakib\",\n    age: 33,\n};\nprintName.call(player); // এই গ্লোবাল ফাংশনটাকে `player` অবজেক্ট দিয়ে `.call()` করা হয়েছে ।\nএক্ষেত্রে .call() এর ভিতরে যা পাস করা হয়, this সেটাকেই পয়েন্ট করে। এক্ষেত্রে explicitly বলে দেয়া হচ্ছে যে this কি হবে ।","apply#.apply()":"👉 .apply() আর .call() একই কাজ করে। সবকিছুই সেম। তবে.apply() তার second parameter এ Array নিতে পারে । যেকানে .call() Array নিতে পারেনা।\nfunction printPlayerName() {\n    console.log(`${this.name} is ${vertue} `);\n}\nlet mashrafe = {\n    name: \"Mashrafe\",\n    age: 36,\n};\nlet vartu1 = \"Honest\";\nlet vartu2 = \"Captain\";\nlet vartu3 = \"Leader\";\nlet vertue = [vartu1, vartu2, vartu3];\nprintPlayerName.apply(mashrafe, vertue);","bind#.bind()":"👉 .bind() ও .call() এর মতোই সেম কাজ করে। তবে পার্থক্য হলো .bind() ফাংশনটিকে সরাসরি কল না করে দিয়ে ফাংশনের একটা নতুন ইন্সটেন্স রিটার্ন করে। এবং সেই ইন্সটেন্সকে যেই ভেরিয়েবলে রাখা হয় সেই ভেরিয়েবল দ্বারা কল করতে হয়।উদাহরনঃ\nfunction printAPlayerName() {\n    console.log(this.name);\n}\nlet bdPlayer = {\n    name: \"Ashraful\",\n    age: 39,\n};\nlet printFunction = printAPlayerName.bind(bdPlayer);\nprintFunction();","itarables-কি-#Itarables কি ?":"Itarables বলতে মূলত সেই সমস্ত জিনিস বা অবজেক্ট কে বোঝায়,যেগুলোর মধ্যে দিয়ে লুপ eg: for...of করে স্টেপ বাই স্টেপ যাওয়া যায়। যেমনঃ Array,String,Map,Setটেকনিক্যালি বললে, যেসব অবজেক্টের প্রোটোটাইপের ভিতরে symbol.itarator প্রপার্টি রয়েছে সেটাই itarable symbol.itarator এর মাধ্যমেই জাভাস্ক্রিপ্ট ডিফাইন করে যে, কোনটা itarable আর কোনটা নয় ।\nMap,Set বলতে এখানে জাভাস্ক্রিপ্ট এর Map Set ডাটা স্ট্রাকচার কে\nবুঝানো হয়েছে","itarator-বলতে-কি-বুঝায়-#itarator বলতে কি বুঝায় ?":"itarable অবজেক্টকে যার দ্বারা itarate করা যায়,সেটাই হলো itarator","itarating-বলতে-কি-বুঝায়-#itarating বলতে কি বুঝায় ?":"itarating বলতে মূলত Itarables অবজেক্টগুলোকে লুপ করে স্টেপ বাই স্টেপ যাওয়ার যেই প্রসেস সেটাকে বুঝায় । যখন itarate করা হয় তখন সেটা হলো itarating","array-কে-itarate-করা-#Array কে itarate করা ।":"const arr = [1, 2, 3, 4, 5, 6, 7];\nfor (item of arr) {\n    console.log(item);\n}\n//Output: 1 2 3 4 5 6 7","string-কে-itarate-করা-#String কে itarate করা ।":"const str = \"Bangladesh\";\nfor (character of str) {\n    console.log(character);\n}\n// Output : B a n g l a d e s h\nজাভাস্ক্রিপ্ট হলো সিঙ্গেল থ্রেডেড প্রোগ্রামিং ল্যাঙ্গুয়েজ"}}}