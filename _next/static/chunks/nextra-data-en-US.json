{"/reactive-accilarator/React-js/module-1/React-installation-and-development-environment-setup":{"title":"React Installation and Development Environment Setup","data":{"":"রিয়াক্ট জে এস ইন্সটল করা এবং ইডীটর সেটআপ করা ।","কমান্ড-প্রমট-এর-মাদ্ধ্যমে-রিয়াক্ট-ইন্সটল-করা-#কমান্ড প্রমট এর মাদ্ধ্যমে রিয়াক্ট ইন্সটল করা ।":"npm create vite@latest --template react","follow-the-command#Follow the command":""}},"/reactive-accilarator/React-js/module-1/component-export-import":{"title":"Component Export Import","data":{"রিয়াক্টে-কিভাবে-import--export-করতে-হয়#রিয়াক্টে কিভাবে import & export করতে হয়?":"**রিয়াক্টে দুইভাবে কম্পোনেন্ট import & export করা যায়ঃ **\ndefault export and import\nnamed export and import","default-export-and-import#default export and import":"উদাহরনঃ","default-export#default export":"export default function Gallery() {\n    return; //Jsx will return\n}\nতাছাড়া আরেকভাবে default export করা যায়,\nfunction Gallery() {\n    return; //Jsx will return\n}\nexport default Gallery;","default-import#default import":"import Gallery from \"Gallery\"; // এখানে .js বা .jsx না লিখলেও কোন সমস্যা নেই\ndefault import এর ক্ষেত্রে আমরা যেকোন নামে কম্পোনেন্ট import করতে পারি। তবে, যেই নামে কম্পোনেন্ট import করা হবে সেই নামেই ব্যাবহার করতে হবে।","named-export-and-import#named export and import":"উদাহরনঃ","named-export#named export":"export function Gallery() {\n    return; //Jsx will return\n}\nnamed export এর মাধ্যমে আমরা চাইলে একটা ফাইল থেকে একাধিক কম্পোনেন্ট এক্সপোর্ট করতে পারি, যেমনঃ\nexport function Card() {\n    return; //Jsx will return\n}\nexport function Image() {\n    return; //Jsx will return\n}\nexport function Profile() {\n    return; //Jsx will return\n}","named-import#named import":"import { Card, Image, Profile } from \"Gallery\"; // এভাবে আমরা এক্লাইনেই একাধিক কম্পোনেন্ট ইম্পোর্ট করতে পারি।","alias-named-import#Alias Named Import":"named import এর ক্ষেত্রে আমরা চাইলে Alias দিয়ে রিনেম করেও কম্পোনেন্ট ইম্পোর্ট করতে পারি।\nimport { Card as ImageCard } from \"Gallery\";"}},"/reactive-accilarator/React-js/module-1/basics-of-react-component":{"title":"Basics of React Component","data":{"components-কি-#Components কি ?":"Component হলো রিয়াক্টের কোর কনসেপ্টগুলোর মধ্যে একটি । এটিকে UI বানানোর বিল্ডিং ব্লক বলা হয়ে থাকে । UI এর প্রতিটা অংশের কোড, যা বার বার রি-ইউজ করা যায় সেগুলোকে একেকটা কম্পোনেন্ট বলা যায়। একটি ছোট বাটনও একটা কম্পোনেট হতে পারে ।রিয়াক্ট আমাদের মার্কাপ গুলোকে ছোট ছোট রি-ইউজেবল কোড ব্লকে এ লিখতে সাহায্য করে,যার একেকটি ব্লক হলো একেকটি কম্পোনেন্ট।তবে কম্পোনেন্ট বানানোর জন্য কিছু নিয়ম রয়েছে যা নিচে দেখানো হয়েছে।","কিভাবে-একটি-রিয়াক্ট-component-বানাতে-হয়-#কিভাবে একটি রিয়াক্ট Component বানাতে হয় ?":"রিয়াক্ট কম্পোনেট হলো একটি জাভাস্ক্রিপ্ট ফাংশন। যাতে আমাদের মার্কাপের সাথে জাভাস্ক্রিপ্টের সংমিশ্রণ থাকে।রিয়াক্ট কম্পোনেন্টের সিনট্যাক্স\nexport default function Profile() {\n    return (\n        <img\n            src='https://i.imgur.com/MK3eW3Am.jpg'\n            alt='Katherine Johnson'\n        />\n    );\n}\nএকটি কম্পোনেন্ট বানাতে যেসব স্টেপ ফলো করতে হয়,তা হলোঃ","কম্পোনেন্টকে-এক্সপোর্ট-করা#কম্পোনেন্টকে এক্সপোর্ট করা":"export default ব্যাবহার করে একটা কম্পোনেন্টকে রি-ইউজেবল করতে হয়, যাতে আমরা অন্য ফাইলে কম্পোনেন্টটিকে import\nকরে ব্যাবহার করতে পারি।","ফাংশন-ডিফাইন-করা#ফাংশন ডিফাইন করা":"export default এর পর একটা নেমড ফাংশন ডিফাইন করতে হয়।\n    export default function Profile(){}\nReact Component বানাতে হলে অবশ্যই ফাংশনের নামের প্রথম অক্ষর Capital later এ লিখতে হবে,নাহলে তা কাজ করবেনা।","ফাংশনের-ভিতরে-মার্কাপ-যুক্ত-করা#ফাংশনের ভিতরে মার্কাপ যুক্ত করা":"ফাংশনের ভিতরে JSX (Javascript XML) সিনট্যাক্সে মার্কাপ রিটার্ন করতে হয়।\nexport default function Profile() {\n    return img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n}\nreturn Statement যদি এক লাইনের বেশি লিখতে হয় তাহলে () এর ভিতরে লিখতে হয়\nউদাহরণঃ\nexport default function Profile() {\n  return (\n  <div>\n       <img src=\"https://i.imgur.com/MK3eW3As.jpg\" alt=\"Katherine Johnson\" />\n  </div>\n  )\n}","কম্পোনেট-কিভাবে-ব্যাবহার-করতে-হয়ঃ#কম্পোনেট কিভাবে ব্যাবহার করতে হয়ঃ":"একটা কম্পোনেন্ট বানানোর পর সেম ফাইলে অন্য আরেকটা কম্পোনেন্ট এর ভিতরে অথবা চাইলে অন্য ফাইলে কম্পোনেন্ট import করে ব্যাবহার করা যায়।উদাহরনঃ\nimport Profile from \"Profile\";\nexport default function Gallery() {\n    return (\n        <section>\n            <h1>Amazing scientists</h1>\n            <Profile />\n            <Profile />\n            <Profile />\n        </section>\n    );\n}","কম্পোনেন্ট-নেস্টিং-করার-ক্ষেত্রে-যেসব-রুলস-মানতে-হয়ঃ#কম্পোনেন্ট নেস্টিং করার ক্ষেত্রে যেসব রুলস মানতে হয়ঃ":"Rules:1 - যদি এমন কম্পোনেন্ট হয়,যেটা খুব ছোট এবং রি-ইউজ হবেনা সেটা চাইলে একই ফাইলে লেখা যায়,এবং ব্যাবহার করা যায়। কিন্তু যদি কম্পোনেন্ট অনেক বড় হয় এবং interactivity বেশি হয়, এবং বিভিন্ন জায়গায় রি-ইউজ করতে হয় তাহলে আলাদা আলাদা ফাইলে কম্পোনেন্ট বানাতে হবে।Rules:2 - একটা কম্পোনেন্ট এর ভিতর আরেকটা কম্পোনেন্টকে নেস্টেড করা যাবে,কিন্তু একটা কম্পোনেট এর ভিতর অন্য আরেকটা ফাংশন ডেফিনেশন নেস্টেড করা যাবেনা।"}},"/reactive-accilarator/React-js/module-1/conditional-renderaing":{"title":"Conditional Renderaing","data":{"কন্ডিশনাল-রেন্ডারিং-কি-#কন্ডিশনাল রেন্ডারিং কি ?":"রিয়াক্টে আমরা কোন শর্তের উপর ডিপেন্ড করে কোন কিছু দেখাতে পারি। আমরা কি দেখাবো আর কি দেখাবোনা তা নির্দিষ্ট লজিকের উপর ভিত্তি করে করতে পারি। এটাকে রিয়াক্টে কন্ডিশনাল রেন্ডারিং বলা হয়।আমরা বেশ কিছু উপায়ে রিয়াক্টে কন্ডিশনাল রেন্ডারিং করতে পাড়িঃ\nif else statements\ncondition ? true : false - Ternery Operator\n&& - Logical AND Operator\n|| - Logical OR operator\n?? - Nullish Coalesing operator","if-else-statements#if else statements":"আমাদের যদি অনেক কমপ্লেক্স লজিক থাকে,এবং তার উপর ভিত্তি করে আমাদের কিছু রেন্ডার করা লাগে,তাহলে আমরা if else statements এর মাধ্যমে তা করতে পারি। সেক্ষেত্রে আমাদেরকে JSX এর বাহিরে if else statements ডিফাইন করতে হবে।** উদাহরণঃ**\nfunction Item({ name, isPacked }) {\n    if (isPacked) {\n        return <li className='item'>{name} ✅</li>;\n    }\n    return <li className='item'>{name}</li>;\n}\nexport default function PackingList() {\n    return (\n        <section>\n            <h1>Sally Ride's Packing List</h1>\n            <ul>\n                <Item\n                    isPacked={true}\n                    name='Space suit'\n                />\n                <Item\n                    isPacked={true}\n                    name='Helmet with a golden leaf'\n                />\n                <Item\n                    isPacked={false}\n                    name='Photo of Tam'\n                />\n            </ul>\n        </section>\n    );\n}","condition--true--false---ternery-operator#condition ? true : false - Ternery Operator":"আমাদের কন্ডিশন যদি অনেক বেশি কমপ্লেক্স না হয় এবং ম্যক্সিমাম ২-৩ লেবেলের বেশি ডিপ না হয় তাহলে আমরা খুব সহজেই JSX এর ভিতরেই Ternery Operator ব্যাবহার করে কন্ডিশনাল রেন্ডারিং করতে পারি।** উদাহরণঃ**\nfunction Item({ name, isPacked }) {\n    return <li className='item'>{isPacked ? name + \" ✅\" : name}</li>;\n}","---logical-and-operator#&& - Logical AND Operator":"যদি আমাদের কন্ডিশন এমন হয় যে, কন্ডিশন মিললে কিছু রেন্ডার করবো আর না মিললে কিছুই রেন্ডার করবোনা,তাহলে আমরা আরও শর্টকাটে && - Logical AND Operator ব্যাবহার করে সেটা করতে পারি।\nfunction Item({ name, isPacked }) {\n    return (\n        <li className='item'>\n            {name} {isPacked && \"✅\"}\n        </li>\n    );\n}\nলজিকাল && এর মানে হলো যে, && এর বাম পাশে truthy ভ্যালু হয় তাহলে ডান পাশের ভ্যালু রিটার্ন করবে,আর falsy হলে কিছুই রিটার্ন করবেনা।\nlet logic = \"true\";\nlogic && \"Something to Render\"; // এখানে লজিকের ভ্যালু `truthy` হলেই শুধ্যমাত্র `&&` এর ডান পাশে যা থাকবে তা রিটার্ন করবে,আর না হলে কিছুই রিটার্ন করবেনা।\nতবে এক্ষেত্র মনে রাখতে হবে যে, && এর বাম পাশের ডাটাটাইপ যেন নাম্বার না হয়,কেননা যদি নাম্বার হয় তাহলে নাম্বারের falsy ভ্যালু হিসেবে 0রিটার্ন করে দিবে।","---logical-or-operator#|| - Logical OR operator":"লজিকাল && এর মতো || - Logical OR operator ব্যাবহার করেও সেম কাজ করতে পারি।\nfunction Item({ name, isPacked }) {\n    return (\n        <li className='item'>\n            {name} {isPacked || \"✅\"}\n        </li>\n    );\n}\nতবে লজিকাল || এর মানে হলো যে, || এর বাম পাশে falsy (0,null,undefined,\"\",false,NaN) ভ্যালু হয় তাহলেই শুধুমাত্র ডান পাশের ভ্যালু রিটার্ন করবে,আর না হলে কিছুই রিটার্ন করবেনা।\nlet logic = \"false\";\nlogic || \"Something to Render\"; // এখানে লজিকের ভ্যালু `falsy` হলেই শুধ্যমাত্র `||` এর ডান পাশে যা থাকবে তা রিটার্ন করবে,আর না হলে কিছুই রিটার্ন করবেনা।","---nullish-coalesing-operator#?? - Nullish Coalesing operator":"যদি কোন ডাইনামিক ভ্যালু null অথবা undefined হয় তাহলে যদি আমরা কোন কিছু করতে চাই, তাহলে আমরা ?? - Nullish Coalesing operator ব্যাবহার করে তা করতে পারি।\nfunction Item({ name, isPacked, data }) {\n    return (\n        data ?? (\n            <li className='item'>\n                {name} {isPacked || \"✅\"}\n            </li>\n        )\n    );\n}"}},"/reactive-accilarator/React-js/module-1/introduction-to-react":{"title":"Introduction to React","data":{"react-কি-#React কি ?":"রিয়াক্ট হলো ফেসবুকের ডেভেলপ করা একটা জাভাস্ক্রিপ্ট লাইব্রেরি। যা একই সাথে ন্যটিভ এবং ওয়েব ইন্টারফেস ডিজাইন করতে সহায়তা করে থাকে। এটি জাভাস্ক্রিপ্ট এ লেখা জাভাস্ক্রিপ্ট এর ই একটা লাইব্রেরি।ফেসবুকের সফটওয়্যার ইঞ্জিনিয়ার Jordan Walke 2011 সালে PHP এর একটা Component Based Framework XHP-js থেকে ইন্সপায়ার হয়ে React.js তৈরি করেন। 2011 সালে এটা প্রথম ফেসবুকের নিউজফিডে ইম্পিলিমেন্ট করা হয় এবং ২০১২ সালে এটা ইন্সটাগ্রামে ব্যবহার করা হয়। ২০১৩ সালে React.js কে ওপেন সোর্স করে দেয় ফেসবুক কোম্পানি। রিয়্যাক্ট এর ওপেন সোর্স গিটহাব রিপোজিটরি React.js এ ভ্যানিলা জাভাস্ক্রিপ্ট ছাড়া আর কিচ্ছু নাই।","reactকেন-ব্যাবহার-করা-উচিতভ্যানিলা-জাভাস্ক্রিপ্ট-এ-কি-প্রব্লেম-#Reactকেন ব্যাবহার করা উচিত,ভ্যানিলা জাভাস্ক্রিপ্ট এ কি প্রব্লেম ?":"যখন আমরা ভ্যানিলা জাভাস্ক্রিপ্ট এ কাজ করি,তখন যেটা হয় যে, ইউজারের ইন্টারেকশনের কারনে যখন কোথাও কোন UI চেঞ্জ করা লাগে, তখন আমাদের প্রতিটা UI চেঞ্জ ম্যানুয়ালি করে দিতে হয়। কিন্তু React এ আমাদের তা করা লাগেনা। রিয়াক্টে ইউজারেরে কোন ইন্টারেকশনের কারনে যখনি কোন ডেটা বা স্টেট চেঞ্জ হয়,তখন UI টা অটোমেটিক রিয়াক্ট করে,এবং UI টা অটোমেটিক চেঞ্জ হয়। এইযে বার বার যেই UI আপডেট করার প্রসেস, এই প্রসেসটাই অটোমেটিক করার জন্যই মূলত রিয়াক্ট তৈরি করাব হয়েছে।","react-এবং-react-dom-কি-#React এবং React DOM কি ?":"একটা UI বানাতে আসলে তিনটা দিক ম্যানেজ করা লাগে,\nUI/ DOM টাকে বানানো।\nUser Interaction হ্যান্ডেল করা।\nDOM টা ব্রাউজারে রেন্ডার করা ।\nReact এবং React DOM এই দুইটা প্যাকেজ আসলে এই কাজগুলোই করে থাকে।React USER INTERFACE বানাতে হেল্প করে এবং ইউজারের ইন্টারেকশনের কারনে যদি কোন ডাটা চেঞ্জ হয় সেটা ম্যানেজ করে।React DOM এই প্যাকেজটা DOM টাকে ব্রাউজারে রেন্ডার করে,এবং একবার ব্রাউজারে রেন্ডার করানো হয়ে গেলে সে ডেটা চেঞ্জ এর জন্য অপেক্ষা করতে থাকে,যদি কোথাও কোন ডেটা চেঞ্জ হয়,তাহলে সে তার VERTUAL DOM এর সেই চেঞ্জটাকে শনাক্ত করে, UI এর যা যা চেঞ্জ করা লাগে তা করে সরাসরি ব্রাউজারে পেইন্ট করে দেয়। এবং ইউজার আপডেটেড UI তা দেখতে পারে।"}},"/reactive-accilarator/React-js/module-1/javascript-in-jsx":{"title":"JavaScript in JSX","data":{"":"JSXএ আমরা জাভাস্ক্রিপ্ট এবং HTML মার্কাপ একসাথে লিখতে পারি। যখনি মার্কাপে কোন ডাইয়ামিক ভ্যালু ব্যাবহার করতে হয়,অথবা কোন লজিকাল অপারেসন চালাতে হয় এমনকি যদি কোন ভ্যারিয়াবল বা অবজেক্টের ভ্যালু এক্সেস করার প্রয়োজন হয়,তখন তা { } ডাবল কার্লি ব্রেসেস এর ভিতরে লিখতে হয়।উদাহরনঃ\nexport default function Profile(name) {\n    let age = 30;\n    return (\n        <div className='profile-card'>\n            <h1>Hello Mr {name}</h1> // name হলো একটা ডাইনামিক ভ্যালূ যা {} দিয়ে\n            জাভাস্ক্রিপ্টের মাধ্যমে লেখা হয়েছে।\n            <p>Your age is {age}</p> // age একটা ভ্যারিয়েবল থেকে পাওয়া ডাইনামিক ভ্যালু\n            যা {} দিয়ে লেখা হয়েছে।\n            <p>\n                You are {age >= 21 ? \"Eligable\" : \"Not Eligable\"} for Marraige\n                // এই লাইনে জাভাস্ক্রিপ্টের মাধ্যমে লজিকাল অপারেশন করা হয়েছে\n            </p>\n        </div>\n    );\n}\nঅর্থাৎ { } দিয়ে এর ভিতরে আমরা জাভাস্ক্রিপ্টের এক্সপ্রেশন লিখতে পারি।","using-double-curlies-css-and-other-objects-in-jsx#Using “double curlies”: CSS and other objects in JSX":"উদাহরনঃ\nexport default function Profile(name) {\n    let age = 30;\n    return (\n        <div\n            className='profile-card'\n            style={{\n                // এই লাইনে অবজেক্ট লেখা হয়েছে\n                backgroundColor: \"gray\",\n                color: \"black\",\n                fontWeight: \"bold\",\n            }}>\n            <h1>Hello Mr {name}</h1> // name হলো একটা ডাইনামিক ভ্যালূ যা {} দিয়ে\n            জাভাস্ক্রিপ্টের মাধ্যমে লেখা হয়েছে।\n            <p>Your age is {age}</p> // age একটা ভ্যারিয়েবল থেকে পাওয়া ডাইনামিক ভ্যালু\n            যা {} দিয়ে লেখা হয়েছে।\n            <p>\n                You are {age >= 21 ? \"Eligable\" : \"Not Eligable\"} for Marraige\n                // এই লাইনে জাভাস্ক্রিপ্টের মাধ্যমে লজিকাল অপারেশন করা হয়েছে\n            </p>\n        </div>\n    );\n}\nযখন JSX এ { } এর ভিতরে কোন অবজেক্ট লিখা লাগবে তখনও একই স্টেপ ফলো করতে হবে, এতে হয়তো মনে হতে পারে যে আমরা দুইবার { } ব্যাবহার করছি, কিন্তু না, প্রথম { } টা হলো জাভাস্ক্রিপ্টের জন্য জায়গা বানানো এবং দ্বিতীয় { } টা হলো অবজেক্ট এর জন্য।"}},"/reactive-accilarator/React-js/module-1/jsx-markup":{"title":"JSX Markup","data":{"jsx-কি-#JSX কি ?":"JSX হলো জাভাস্ক্রিপ্টের একটি সিনট্যাক্স এক্সটেনশন যা আমাদেরকে HTML এর মতো মার্কাপ লিখতে সাহায্য করে । JSX এর বড় সুবিধা হলো এখানে একই জায়গায়(কম্পোনেন্টের ভিতর) জাভাস্ক্রিপ্টের লজিক ও HTML এর মার্কাপ লিখা যায়। যা পরবর্তিতে কোথাও কিছু চেঞ্জ করতে হলে আমাদের এক্সট্রা ফ্লেক্সিবিলিটি দেয়।JSX দেখতে একদম HTML এর মতো হলেও এটা কিন্তু HTML নয়,বরং HTML এর চাইতে অনেক বেশি Strict। JSX এ কোথাও কোন ভুল করলে তা সাথে সাথে Error দিয়ে দেয়।HTML এ আমরা শুধুমাত্র স্ট্যাটিক কন্টেন্ট লিখতে পারি,কিন্তু JSX এ আমারা ডাইনামিক ভ্যালু ব্যাবহার করতে পারি।","jsx-লিখার-রুলসগুলো-কি-কি-#JSX লিখার রুলসগুলো কি কি ?":"JSX এ বেশ কিছু রুলস ফলো করতে হয় তা হলোঃ","1-return-a-single-root-element#1. Return a Single root element:":"JSX এক্টিমাত্র সিঙ্গেল রুট এলিমেন্ট রিটার্ন করতে হবে, যদি মাল্টিপল এলিমেন্ট রিটার্ন করতে হয় তাহলে অবশ্যই একটি প্যারেন্ট এলিমেন্ট দিয়ে wrap করে দিতে হবে। এক্ষেত্র চাইলে <div> </div> এলিমেন্ট ব্যাবহার করা যায়। তবে <div> </div> ব্যাবহার করলে HTML এর Eliment Tree তে একটা অতিরিক্ত <div> </div> এলিমেন্ট রেন্ডার হয়।❌ ভুল\nexport default function Profile() {\n    return (\n            <h1>Hello Mr XX</h1>\n            <p>Your age is 30</p>\n        // এই কোডটা কাজ করবেনা,কারণ দুইটা এলিমেন্টকে রিটার্ন করা হয়েছে\n    );\n}\n✅ সঠিক\nexport default function Profile() {\n    return (\n        <div>\n            <h1>Hello Mr XX</h1>\n            <p>Your age is 30</p>\n        </div>\n        // এই কোডটা কাজ করবে,কারণ দুইটা এলিমেন্টকে একটা প্যারেন্ট `<div> </div>` দিয়ে wrap করা হয়েছে\n    );\n}\nতবে আপানর ইচ্ছা যদি হয় যে আপনি কোন অতিরিক্ত <div> </div> এলিমেন্ট রেন্ডার করবেন না তাহলে, <></> এভাবে ব্যাবহার করতে পারেন। এটাকে বলা হয় Fragment ট্যাগ। আবার যদি কখনও Fragment এর ভিতরে key পাস করা লাগে,তাহলে ফ্রাগমেন্ট <></> এভাবে না লিখে <Fragment></Fragment> এভাবে লিখতে হবে।","কেন-আমাদের-একটি-মূল-jsx-রিটার্ন-করতে-হয়#কেন আমাদের একটি মূল JSX রিটার্ন করতে হয়?":"Credit to : Saffaullah Shuvo\nWell, যে কোন প্রোগ্রামিং এই function থেকে কেবল একটি data type/structure এর ডেটা রিটার্ন করা যায়। যেমন একটি সিম্পল নাম্বার অথবা কোন কমপ্লেক্স ডেটা স্ট্রাকচার,\nfunction returnOne() { return 1; } // দুইটা নাম্বার রিটার্ন করা কি সম্ভব?\nfunction returnTwo() { return (100 500) } // এটা একটা syntax error // তারমানে Compiler এইরকম syntax সাপোর্ট করেনা\nতাহলে দুইটা নাম্বার কি রিটার্ন করা যাবে না? যাবে-\nfunction returnTwo() { return [100, 500]; // আরো অনেকভাবেই করা যায় }\nJSX গুলা যেহেতু javascript Object তাই\nfunction returnTwoJSX() {\nreturn (<h1>Hi</h1> <h2>Hello</h2>)\n }\n  // Behind the scene\n  function returnTwoJSX() {\n   return (\n    {type: 'h1', props: { children: 'Hi'}} // object1\n    {type: 'h2', props: { children: 'Hello'}} // object2\n    )\n    }\n     // তাই এটাও syntax error\nকিন্তু আমরা একটা Array এর ভিতরে রেখে কিংবা একটা প্যারেন্ট এলিমেন্টের ভিতরে রেখে একটা ডেটা হিসেবেই return করতে পারি।\nসল্যুশন ১ - প্যারেন্ট এলিমেন্ট দিয়ে Wrap করে দেয়া\nfunction returnParentJSX() {\n    return (\n        <div>\n            <h1>Hi</h1>\n            <h2>Hello</h2>\n        </div>\n    );\n}\n// Behind the scene\nfunction returnParentJSX() {\n    return {\n        type: \"div\",\n        props: { children: [object1, object2] },\n        // ...additional properties\n    };\n}\nসল্যুশন ২ - প্যারেন্ট হিসেবে Fragment ব্যবহার করা।\nfunction returnFragmentJSX() {\n    return (\n        <Fragment>\n            {\" \"}\n            // short form <></>\n            <h1>Hi</h1>\n            <h2>Hello</h2>\n        </Fragment>\n    );\n}\n// Behind the scene\nfunction returnFragmentJSX() {\n    return {\n        type: Symbol(react.fragment),\n        props: { children: [object1, object2] }, // ...additional property\n    };\n}\nJSX এর বদলে ডিরেক্ট Object Return করলে কি কাজ করবে? যেমনঃ\nfunction returnDirectObject() {\n    return {\n        type: \"div\",\n        props: {\n            className: \"bg-white\",\n            children: [\n                {\n                    type: \"h1\",\n                    props: { className: \"text-2xl\", children: \"Hi\" },\n                },\n                { type: \"p\", props: { children: \"Hello World\" } },\n            ],\n        },\n    };\n}\nনা, কারন এই Object টা React এর ওয়েতে বানানো হয়নি। রিয়েক্ট আরও Additional Property রাখে Object er ভিতর। রিয়েক্ট যেভাবে বানায় -\nimport { createElement } from \"react\";\nfunction returnDirectObject() {\n    return createElement(\n        \"div\",\n        { className: \"bg-white\" },\n        createElement(\"h1\", { className: \"text-2xl\" }, \"Hi\"),\n        createElement(\"p\", null, \"Hello World\")\n    );\n}","2-close-all-the-tags#2. Close all the tags:":"JSX এ ব্যাবহার করা প্রতিটা ট্যাগ অবশ্যই ক্লোজ করা লাগবে। সেলফ ক্লোজিং ট্যাগ যেগুলো আছে যেমনঃ <img>,<hr>,সেগুলোও অবশ্যই এভাবে <img />,<hr /> ক্লোজ করা লাগবে ।","3-camelcase-all-most-of-the-things#3. camelCase all most of the things!:":"JSX এ যেহেতু আমারা JavaScript লিখছি,সেহেতু আমাদের জাভাস্ক্রিপ্ট এর রুলস অনুযায়ী multiple-word এর Attribute গুলোকে camelCase এ লিখতে হবে।class Attribute টা যেহেতু জাভাস্ক্রিপ্টের রিজার্ভ কিওয়ার্ড,তাই আমরা class ব্যাবহার করতে পারবোনা। class এর পরিবর্তে আমদের className ব্যাবহার করতে হবে ।"}},"/reactive-accilarator/React-js/module-1/pure-components":{"title":"Pure Components","data":{"পিওর-ফাংশন-কী#পিওর ফাংশন কী?":"একটি ফাংশনকে পিওর (pure) বলা হয় যদি তা নিচের দুটি শর্ত পূরণ করে:\nসেম ইনপুটের জন্য সেম আউটপুট: পিওর ফাংশন সবসময় তার ইনপুট অনুযায়ী নির্দিষ্ট আউটপুট প্রদান করে। অর্থাৎ একই ইনপুটের জন্য সবসময় একই আউটপুট পাওয়া যাবে।\nসাইড-ইফেক্টের অনুপস্থিতি: পিওর ফাংশন বাইরের কোনো স্টেট বা ভ্যারিয়েবল পরিবর্তন করে না। এটি শুধুমাত্র ইনপুট অনুযায়ী কাজ করে এবং বাইরে কোনো পরিবর্তন আনে না।","পিওর-ফাংশনের-উদাহরণ#পিওর ফাংশনের উদাহরণ:":"function add(a, b) {\n    return a + b;\n}\nএখানে add ফাংশনটি পিওর, কারণ এটি কেবল তার ইনপুট অনুযায়ী আউটপুট দিচ্ছে এবং বাহ্যিক কোনো স্টেট পরিবর্তন করছে না।","ইমপিওর-ফাংশনের-উদাহরণ#ইমপিওর ফাংশনের উদাহরণ:":"let x = 10;\nfunction addWithSideEffect(a, b) {\n    x = a + b; // বাহিরের ভ্যারিয়েবল পরিবর্তন করা হচ্ছে\n    return x;\n}\nএই ফাংশনটি ইমপিওর, কারণ এটি বাহ্যিক ভ্যারিয়েবল x এর মান পরিবর্তন করছে, যা একটি সাইড-ইফেক্ট সৃষ্টি করছে।","কেন-react-এ-পিওর-ফাংশনাল-কম্পোনেন্ট-ব্যবহার-করা-উচিত#কেন React-এ পিওর ফাংশনাল কম্পোনেন্ট ব্যবহার করা উচিত?":"React কম্পোনেন্টগুলোকে পিওর রাখতে রিকমেন্ড, কারণ এতে বেশ কিছু সুবিধা রয়েছে। মূলত, পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের মাধ্যমে React এর পারফরম্যান্স ও ব্যবহারে সুবিধা পাওয়া যায়। আসুন, এই সুবিধাগুলো বিস্তারিতভাবে দেখি:","১-অপ্রয়োজনীয়-রেন্ডার-এড়ানো#১. অপ্রয়োজনীয় রেন্ডার এড়ানো":"React পিওর ফাংশনাল কম্পোনেন্টগুলোর ক্ষেত্রে ইনপুট বা প্রপসে কোনো পরিবর্তন না হলে কম্পোনেন্টটি পুনরায় রেন্ডার করে না। অর্থাৎ, ইনপুট এক থাকলে React আগের আউটপুট ব্যবহার করতে পারে, যা অ্যাপ্লিকেশনের রেন্ডারিংয়ের কার্যকারিতা বৃদ্ধি করে।","উদাহরণ#উদাহরণ:":"import React from \"react\";\nconst Greeting = React.memo(function Greeting({ name }) {\n    console.log(\"Rendering Greeting\");\n    return <h1>Hello, {name}!</h1>;\n});\nএখানে React.memo ব্যবহারের মাধ্যমে এই কম্পোনেন্টকে পিওর করা হয়েছে। যদি name প্রপসের কোনো পরিবর্তন না ঘটে, তাহলে React পূর্বের রেন্ডারকৃত আউটপুটই পুনরায় ব্যবহার করবে, নতুন করে রেন্ডার করা প্রয়োজন হবে না।","২-সহজ-এবং-ক্লিন-কোড#২. সহজ এবং ক্লিন কোড":"পিওর ফাংশনাল কম্পোনেন্টের ব্যবহারে কোড সহজ ও ক্লিন হয়। যেহেতু এগুলো শুধু ইনপুটের ওপর নির্ভরশীল এবং কোনো বাহ্যিক স্টেটের উপর নির্ভর করে না, তাই এগুলো সহজেই বোঝা যায় এবং প্রয়োগ করা যায়।","উদাহরণ-1#উদাহরণ:":"function WelcomeMessage({ user }) {\n    return <p>Welcome, {user}!</p>;\n}\nএই ধরনের কম্পোনেন্ট অত্যন্ত ক্লিন এবং সহজপাঠ্য, কারণ এটি কোনো বাহ্যিক স্টেট পরিবর্তন করে না, বরং শুধুমাত্র প্রপসের মাধ্যমে আউটপুট প্রদান করে।","৩-প্রেডিক্টেবল-আচরণ#৩. প্রেডিক্টেবল আচরণ":"পিওর ফাংশনাল কম্পোনেন্ট সবসময় নির্দিষ্ট ইনপুট অনুযায়ী নির্দিষ্ট আউটপুট দেয়। এতে করে এদের আচরণ প্রেডিক্টেবল হয়, অর্থাৎ আগেভাগেই অনুমান করা সম্ভব। এটি ডিবাগিং এবং বাগ সমাধানের ক্ষেত্রে গুরুত্বপূর্ণ, কারণ আচরণ সবসময় পূর্বানুমানযোগ্য থাকে।","৪-সহজ-টেস্টিং#৪. সহজ টেস্টিং":"পিওর ফাংশনাল কম্পোনেন্ট সহজেই টেস্ট করা যায়, কারণ এগুলো ইনপুট এবং আউটপুটের উপর নির্ভরশীল। ইনপুট অনুযায়ী আউটপুট পরীক্ষা করলেই সহজে বোঝা যায় যে ফাংশনটি সঠিকভাবে কাজ করছে কি না।","উদাহরণ-2#উদাহরণ:":"function sum(a, b) {\n    return a + b;\n}\n// টেস্টিং উদাহরণ:\nconsole.log(sum(2, 3)); // আউটপুট হবে: 5","৫-memoization-এর-সুবিধা#৫. Memoization এর সুবিধা":"React-এ পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের ফলে memoization সহজ হয়। একই ইনপুটের জন্য React আগের আউটপুট সংরক্ষণ করতে পারে, ফলে অপ্রয়োজনীয় রেন্ডার এড়িয়ে পারফরম্যান্স উন্নত করা যায়। React.memo এই কাজে বিশেষভাবে ব্যবহৃত হয়।React-এ পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের মাধ্যমে কোডের সহজ হয়, প্রেডিক্টেবিলিটি এবং পারফরম্যান্স বৃদ্ধি পায়। অপ্রয়োজনীয় রেন্ডারিং এড়ানো, সহজে টেস্ট করা, এবং কোড ক্লিন রাখার জন্য পিওর ফাংশন ব্যবহার অত্যন্ত গুরুত্বপূর্ণ। তাছাড়া, React এর memoization ফিচারের কারণে পিওর ফাংশনাল কম্পোনেন্ট ব্যবহারের মাধ্যমে অ্যাপ্লিকেশনের কার্যকারিতা উল্লেখযোগ্যভাবে বৃদ্ধি পায়।","যদি-আমাদেরকে-এমন-কোন-কাজ-করতেই-হয়-যাতে-কম্পোনেন্টের-পিওরিটি-নষ্ট-হলেও-করতে-হবেএমনবস্থায়-কি-করবো-#যদি আমাদেরকে এমন কোন কাজ করতেই হয় যাতে কম্পোনেন্টের পিওরিটি নষ্ট হলেও করতে হবে,এমনবস্থায় কি করবো ?":"হ্যা,এটা ঠিক যে সবসময় কম্পোনেন্টের পিওরিটি বজায় রাখা সম্ভব নাও হতে পারে,আমাদের এমন কিছু করা লাগতে পারে যাতে হয়তো কম্পোনেন্টের পিওরিটি নষ্ট হবে, এমন অবস্থায় আমরা দুটি কাজ করতে পাড়িঃ","manage-with-event-handler#Manage With Event Handler:":"যেসব সাইড-এফেক্টগুলো আমরা event-handler এর মাধ্যমে করতে পারবো,তা আমরা event-handler এর ভিতর করার চেষ্টা করবো। কারণ event-handler রিয়াক্টের রেন্ডারিং টাইমে একটিভ হয়না তাই event-handler পিওর হউয়ার প্রয়োজন নাই ।  event-handler Hydration (রিয়াক্টের কম্পোনেন্ট লোড হউয়ায়র পর যেই টাইমটায় জাভাস্ক্রিপ্ট একটিভ হয়, ওই প্রসেসটা হলো Hydration) টাইমে একটিভ হয়। মূল কোথা হলো যাতে রিয়াক্টের রেন্ডারিং টাইমে কোন সাইড-এফেক্ট না হয় ।","useeffect-হুকের-মাধ্যমে-সাইড-এফেক্ট-ম্যানেজ-করাঃ#useEffect হুকের মাধ্যমে সাইড-এফেক্ট ম্যানেজ করাঃ":"যদি আর কোন উপায় নাই থাকে,তাহলে একেবারে লাস্ট স্টেজ হিসেবে রিয়াক্ট সাইড-এফেক্ট হ্যান্ডেল করার জন্য একটা বিল্ট-ইন হুক দিয়ে দিয়েছে,যার নাম useEffect। এই হুক ব্যাবহার করে সাইড-এফেক্ট ম্যানেজ করতে হবে। এই হুকটাও রিয়াক্টের রেন্ডারিং শেষ হয়ে যাওয়ার পর একটিভ হয়। তাই সাইড-এফেক্ট হ্যান্ডেল করার জন্য এই হুকটা ইউজ করা যেতে পারে,তবে সেটা হলো একেবারে সর্বশেষ রাস্তা।","ফাংশনের-ভিতরের-ভ্যারিয়েবলগুলো-কি-চেঞ্জ-করা-যাবে#ফাংশনের ভিতরের ভ্যারিয়েবলগুলো কি চেঞ্জ করা যাবে?":"হ্যা,ফাংশনের ভিতরের ভ্যারিয়েবল চেঞ্জ করা যাবে। এতে কম্পোনেন্টের পিওরিটি নষ্ট হবেনা। এটাকে বলা হয় local mutation। লোকাল মিউটেশনে কোন সমস্যা নাই।"}},"/reactive-accilarator/React-js/module-1/rendering-list":{"title":"Rendering List","data":{"":"রিয়াক্টে আমাদেরকে প্রায় সময়ই লিস্ট অফ ডাটা বা ডাটা Array থেকে ডাটা রেন্ডার করার প্রয়োজন হয়। সেক্ষেত্রে আমারা map, filter ব্যাবহার করে তা দেখাতে পারি।উদাহরনঃ\nconst users = [\"Mr x\", \"Mr y\", \"Mr z\"];\nexport function ListOfUser() {\n    const user = users.map((person) => <li>{person}</li>);\n    return <ul>{user}</ul>;\n}","key-এর-ব্যাবহারঃ#key এর ব্যাবহারঃ":"লিস্ট অফ আইটেম map করে রেন্ডার করার সময় প্রতিটা লিস্ট এলিমেন্টে অবশ্যই key ব্যাবহার করতে হবে।\nconst users = [\n    {\n        id: 1,\n        name: \"Mr X\",\n    },\n    {\n        id: 2,\n        name: \"Mr XX\",\n    },\n];\nexport function ListOfUser() {\n    const user = users.map((person) => <li key={person.id}>{person.name}</li>);\n    return <ul>{user}</ul>;\n}","key-কিভাবে-পেতে-পারি-#key কিভাবে পেতে পারি ?":"বিভিন্ন ডাটা থেকে বিভিন্ন ভাবে key পেতে পারি, যেমনঃ\nডাটাবেস থেকে প্রাপ্ত ডাটাঃ যেসব ডাটা আমরা ডাটাবেস থেকে পাই সেগুলোর সাথে আমারা অটোমেটিক Id পেয়ে যাই, এই Id আমরা key হিসেবে ব্যাবহার করতে পারি।\nলোকাল ডাটার ক্ষেত্রেঃ যেসব ডাটা লোকালি অটোমেটিক জেনারেটেড হয় সেসব ডাটার ক্ষেত্রে আমারা crypto.randomUUID() অথবা uuid ব্যাবহার করে id/key জেনারেট করে সেভ করতে পারি।","রুলস-অফ-key#রুলস অফ key":"key অবশ্যই ইউনিক হতে হবে। একই লিস্টের বিভিন্ন এলিমেন্টে একই key ব্যাবহার করা যাবেনা।\nkey পরিবর্তন করা যাবেনা বা রেন্ডারিং এর সময়ে key জেনারেট করে ব্যবাহার করা যাবেনা।\nArrayর ইনডেক্সকে কখনো কি হিসেবে ব্যাবহার করা যাবেনা।","রিয়াক্টে-কেন-key-ব্যাবহার-করা-লাগে#রিয়াক্টে কেন key ব্যাবহার করা লাগে?":"রিয়াক্ট তার DOM TREEতে প্রতিটা আইটেমকে ইউনিকভাবে আইডেন্টিফাই করার জন্য keyর প্রয়োজন হয়। যাতে কখনও লিস্ট থেকে কোন আইটেম ডিলিট হয়ে গেলে,বা কখনো sort করা লাগলে যেন রিয়াক্ট সহজে বুঝতে পারে যে কোন আইটেমে পরিবর্তন হয়েছে।"}},"/reactive-accilarator/React-js/module-1/understanding-props":{"title":"Understanding Props","data":{"props-কি-#Props কি ?":"রিয়াক্টে Parent Component থেকে Child Component এ ডাটা প্রদানের জন্য Props ব্যাবহার করা হয়ে থাকে। Props অনেকটা ফাংশনের Parameters এর মতো।আমরা যেভাবে HTML এর Attributes লিখি সেভাবেই Parent Component থেকে Child Component এ Props পাঠাতে পারি।উদাহরনঃ\nexport default function Profile() {\n    return (\n        <Avater //imgurl এবং size নামে দুটি props পাঠানো হয়েছে চাইল্ড কম্পোনেন্ট Avater এ।\n            imgurl='https://example.com/image/1.png'\n            size={100}\n        />\n    );\n}\nexport default function Avater(props) {\n    // parent  Avater কম্পোনেন্ট থেকে props নামে একটা Object হিসেবে props গুলো রিসিভ করা হয়েছে\n    return (\n        <img\n            src={props.imgurl}\n            alt='Avater Image'\n            size={props.size}\n        />\n    );\n}\nProps এ আমরা যেকোন জাভাস্ক্রিপ্ট ভ্যালু পাঠাতে পারি,এমনকি ফাংশন ও পাঠাতে পারি।","কিভাবে-props-পাঠাতে-হয়-এবং-props-রিসিভ-করতে-হয়-#কিভাবে Props পাঠাতে হয় এবং Props রিসিভ করতে হয় ?":"যেভাবে Props পাঠাতে হয় এবং Props রিসিভ করতে হয় নিচে তা বিস্তারিত ব্যাখ্যা করছি।","step-1---pass-props-to-the-child-component#Step 1 :  Pass props to the child component":"export default function Profile() {\n        return (\n          <Avatar\n            person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}\n            size={100}\n          />\n        );\n      }\nএখানে Avatarকম্পোনেন্ট থেকে তার চাইল্ড কম্পোনেন্টে\nperson = যা একটি অবজেক্ট,\nsize = যা একটি নাম্বার,\nপাঠানো হয়েছে।","step-2--read-props-inside-the-child-component#Step 2 : Read props inside the child component":"export default function Avater(props) {\n    return (\n        <img\n            src={props.imgurl}\n            alt='Avater Image'\n            size={props.size}\n        />\n    );\n}\nparent Avater কম্পোনেন্ট থেকে props নামে একটা Object হিসেবে props গুলো রিসিভ করা হয়েছে","distructuring-পদ্ধতিতে-props-রিসিভ-করা-#Distructuring পদ্ধতিতে Props রিসিভ করা ।":"Distructuring পদ্ধতিতে Props রিসিভ করা যায়, সেক্ষেত্রে আমারা এভাবে করতে পারি।\nexport default function Avater({ imgurl, size }) {\n    return (\n        <img\n            src={imgurl}\n            alt='Avater Image'\n            size={size}\n        />\n    );\n}","props-এ-ডিফল্ট-ভ্যালু-ব্যাবহার-করা#Props এ ডিফল্ট ভ্যালু ব্যাবহার করা।":"কখনও কখনও Props এর ভ্যালু Undefined আসতে পারে,তখন আমাদের Props এর ডিফল্ট ভ্যালু সেট করা লাগতে পারে, সেক্ষেত্রে আমারা এভাবে = দিয়ে ডিফল্ট ভ্যালু সেট করতে পারি।\nexport default function Avater({ imgurl, size = 100 }) {\n    return (\n        <img\n            src={imgurl}\n            alt='Avater Image'\n            size={size}\n        />\n    );\n}","forwarding-props-with-the-jsx-spread-syntax#Forwarding props with the JSX spread syntax":"কখনও কখনও এমন হতে পারে যে আমরা কোন কম্পোনেন্ট এ যেই Props গুলো রিসিভ করেছি, তার সবগুলো Props ওই কম্পোনেন্টের ভিতরেই অন্য আরেকটা কম্পোনেন্টের চাইল্ড কম্পোনেন্টে পাঠানো বা ফরওয়ার্ড করা লাগতে পারে। তখন আমরা ওই Props গুলো বার বার না লিখে JSX spread syntax {...props}  পাস করে দিতে পারি।এক্ষেত্রে আমরা মেইন যে কম্পোনেন্ট এ Props গুলো রিসিভ করবো সেখানে আমাদের Distructuring Method রিসিভ না করে props নামক অবজেক্ট হিসেবে ধরতে হবে।উদাহরণঃ","step-1#Step 1:":"প্রথম App কম্পোনেন্ট থেকে Profile কম্পোনেন্টে name,age,gender নামে তিনটা Props পাস করা হয়েছে।\nexport default function App() {\n    return (\n        <div>\n            <div>\n                <Profile\n                    name='Ripon'\n                    age={30}\n                    gender='male'\n                />\n            </div>\n        </div>\n    );\n}","step-2#Step 2:":"এখানে Profile কম্পোনেন্ট এ সমস্ত propsগুলো props নামক অবজেক্ট হিসেবে রিসিভ করা হয়েছে।\nexport default function Profile(props) {\n    return (\n        <div>\n            <Card {...props} />\n        </div>\n    );\n}","step-3#Step 3:":"এখানে Card কম্পোনেন্ট এ সমস্ত propsগুলো {...props} করে Spread করে পাঠানো হয়েছে ।\nexport default function Profile(props) {\n    return (\n        <div>\n            <Card {...props} />\n        </div>\n    );\n}","চিলড্রেন-প্রপ্স-হিসেবে-jsxবা-component-পাঠানো#চিলড্রেন প্রপ্স হিসেবে JSXবা Component পাঠানো।":"আমরা একটা কম্পোনেন্ট দিয়ে wrap করে অন্য আরেকটা Component কে Props হিসেবে পাঠাতে পারি। এটাকে বলা হয় children Props। এবং রিসিভ করার সময়ও সেটাকে children নামেই রিসিভ করতে হয়।\nexport default function Profile() {\n    return (\n        <Card>\n            <Profile />\n        </Card>\n    );\n}\nexport default function Card({ children }) {\n    // এখানে `Profile` কম্পোনেন্টকে `children` হিসেবে রিসিভ করা হয়েছে।\n    return (\n        <div className='card'>\n            <h1>This is Profile Card</h1>\n            {children}\n        </div>\n    );\n}","props-are-immutable-why-#Props are Immutable: why ?":"Props গুলো সরাসরি চেঞ্জ করা যায়না। কারণ props হলো Immutable. props কে শুধুমাত্র Parent Component থেকে State দ্বারা ম্যানেজ করতে হয়। কখনো কোন ইউজারের ইন্টারেকশনের কারনে যদি props এর ভ্যালু চেঞ্জ করা লাগে, তাহলে রিয়াক্ট তখন নতুন Props পাস করে Child Component এ। কিন্তু কখনই আগের পাঠানো props কে পরিবর্তন করেনা।নতুন Props পাঠানোর পর আগের Propsটা কে জাভাস্ক্রিপ্ট মেমরি থেকে ফেলে দেয় বা গার্বেজ কালেক্টেড করে ফেলে।তাই কখনই Child Component এর ভিতর Props এর ভ্যালূ পরিবর্তন বা ওভাররাইড করা যাবেনা।"}},"/reactive-accilarator/React-js/module-1/vertual-dom":{"title":"Vertual Dom","data":{"dom-কি-আসলেই-স্লো#DOM কি আসলেই স্লো?":"নাহ, ডম কখনোই স্লো না । আসলে যদি ভালোভাবে কোড করা হয় তাহলে ডম যেকোন কিছুর থেকে ফাস্ট। কিন্তু বর্তমান বিশ্বে ওয়েব অ্যাপ্লিকেশনগুলো অনেক বেশি ইন্টারেক্টিভ,তাই যখনই ইউজার কোন ইন্টারেকশন করে তখন ব্রাউজারকে আবার তা নতুন করে পুরো ওয়েবসাইটটা রি-পেইন্ট করতে হয়। এইরকম যখন অনেকগুলো রিয়াকশনের কারনে ব্রাউজারকে বার বার রি পেইন্ট করতে হয় তখন সেই রি-পেইন্টিং প্রসেসটা স্লো হয়ে যায়,মুলত ডম কিন্তু স্লো নয় ।","ব্রাউজার-কিভাবে-dom-রেন্ডার-করে-#ব্রাউজার কিভাবে DOM রেন্ডার করে ?":"আমরা দেখতে পাচ্ছি যে উপরে একটা গ্রাফ এর মাদ্ধমে ব্রাউজার এর রেন্ডারিং প্রসেস দেখানো হয়েছে । এখানে আমরা কি দেখতে পাচ্ছি ? আমরা দেখতে পাচ্ছি যে, যখন ব্রাউজার কোন HTML CSS ফাইল পায়,তখন সেই ফাইলটা একটা পারসিং এর মদ্ধে দিয়ে নিয়ে যায়, এক্ষেত্রে HTML এর জন্য HTML PARSER ও CSS এর জন্য CSS PERSER ব্যাবহার হয়। এসব পারসার দিয়ে পারসিং এর পর ব্রাউসার HTML দিয়ে একটা DOM TREE বানায় এর CSS দিয়ে CSSOM নামে একটা STYLE RULES বানায় , এবং DOM TREE ও STYLE RULES একসাথে ATTACH হয়ে একটা RENDER TREE বানায়। এই RENDER TREE ব্রাউসারে একটা LAYOUT ফেস এর মদ্ধে দিয়ে যায়। এই LAYOUT ফেস এ DOM TREE টা ব্রাউসার এর কোথায় রেন্ডার হবে তার একটা CORDINATE রেডি হয়ে যায় । এবং ফাইনালি ব্রাউজার তার PAINTING মেকানিজম এর মাদ্ধমে তা ব্রাউসারে পেইন্ট করে দেয় এবং আমরা ফাইনাল আউটপুট দেখতে পাই।","ভার্চুয়াল-ডম-কি--কিভাবে-ভার্চুয়াল-ডম-কাজ-করে#ভার্চুয়াল ডম কি ? কিভাবে ভার্চুয়াল ডম কাজ করে?":"ভার্চুয়াল ডম রিয়াক্ট এর একটা ফান্ডামেন্টাল বিষয় । রিয়াক্ট এর ভিত্তিটাই মূলত এই ভার্চুয়াল ডম ।ব্রাউজারের রি-পেন্টিং প্রসেসটা এপ্লিকেশনকে স্লো ডাউন করে দেয়, এই সমস্যা এড়ানোর জন্য আমরা কি করতে পারি ভাবুনতো। আমরা মূলত দুইটা ভাবে এটার সমাধান করতে পারি :\nআমরা ব্যাচ আপডেট করতে পারি,\nআমরা ডম ম্যানুপুলেশন কম করতে পারি।\nরিয়াক্ট তার ভার্চুয়াল ডমের মাদ্ধমে সেই কাজটাই করে । রিয়াক্ট একেবারে মিনিমাম ডম ম্যানুপুলেশন করে ।যখন এপ্লিকেশনে কোন ইউজার কোন ইন্টারেকশন করে তখন যদি UI তে কোন চেঞ্জ করতে হয় তখন রিয়াক্ট সরাসরি HTML এর DOM TREE টাকে চেঞ্জ করে দেয়না। যখনি UI তে কোন চেঞ্জ আসে,রিয়াক্ট তার ভার্চুয়াল DOM এর সাহায্যে UI এর একটা রেপ্লিকা বা কপি বানিয়ে নেয় । তারপর রিয়াক্ট তার একটা নিজস্ব বানানো এলগরিদম Diffng বা Reconciliation এলগরিদম এর মাদ্ধমে চেক করে যে UI এর ঠিক কোন জায়গায় চেঞ্জ হয়েছে । এতে করে পুরো ওয়েবসাইটটা রি-রেন্ডার না করে শুধুমাত্র যেই অংশে পরিবর্তন হয়েছে,সেই অংশটুকু DOM এ আপডেট করে দেয়। এতে করে রিয়াক্ট মিনিমাম ডম অপারেশনের মাদ্ধমে এপ্লিকেশনএর পার্ফমেন্স ইম্প্রুভ করে ।"}},"/reactive-accilarator/React-js/module-1/your-ui-as-a-tree":{"title":"Your UI as a Tree","data":{"রেন্ডার-ট্রি-render-tree-এবং-মডিউল-ট্রি-module-tree--রিয়াক্টের-প্রেক্ষাপটে#রেন্ডার ট্রি (Render Tree) এবং মডিউল ট্রি (Module Tree) – রিয়াক্টের প্রেক্ষাপটে":"","১-রেন্ডার-ট্রি-render-tree-কী#১. রেন্ডার ট্রি (Render Tree) কী?":"রেন্ডার ট্রি হলো ডকুমেন্ট অবজেক্ট মডেল (DOM) এবং স্টাইলিং ইনফরমেশন (CSS) এর সম্মিলিত রূপ। এটি একটি ট্রি স্ট্রাকচার যেখানে প্রতিটি নোড একটি UI এলিমেন্টের প্রতিনিধিত্ব করে।রিয়াক্টে, আমরা JSX দিয়ে কম্পোনেন্ট লিখি, যা শেষে HTML DOM এ রূপান্তরিত হয়। রিয়াক্ট তখন একটি ভার্চুয়াল DOM তৈরি করে এবং সেই DOM এর ওপর কাজ করে।","রেন্ডার-ট্রি-কিভাবে-কাজ-করে#রেন্ডার ট্রি কিভাবে কাজ করে?":"DOM ও CSSOM তৈরি: প্রথমে ব্রাউজার HTML থেকে একটি DOM (ডকুমেন্ট অবজেক্ট মডেল) তৈরি করে। তারপর CSS থেকে CSSOM (CSS অবজেক্ট মডেল) তৈরি করে।\nরেন্ডার ট্রি নির্মাণ: DOM এবং CSSOM একসাথে মিলে রেন্ডার ট্রি তৈরি করে।\nলেআউট এবং পেইন্টিং: এরপর ব্রাউজার প্রতিটি এলিমেন্টকে তার যথাযথ জায়গায় বসিয়ে দেয় (লেআউট), এবং পরিশেষে সেই এলিমেন্টগুলোকে পেইন্ট করে।","রেন্ডার-ট্রির-প্রয়োজনীয়তা-ও-সুবিধা#রেন্ডার ট্রির প্রয়োজনীয়তা ও সুবিধা:":"রেন্ডার ট্রি প্রয়োজন, কারণ এটি ব্রাউজারের কাছে নির্দিষ্ট ভাবে জানায়, কিভাবে পেজটি দেখাবে।\nএর মাধ্যমে DOM এর পরিবর্তন হলে, ব্রাউজার শুধু সংশ্লিষ্ট অংশটুকু পুনরায় রেন্ডার করে। ফলে পারফরম্যান্স বৃদ্ধি পায়।\nরিয়াক্টের ভি-ডম (Virtual DOM) রেন্ডার ট্রির উপর ভিত্তি করে কাজ করে। ভি-ডম পারফরম্যান্স অপটিমাইজ করার জন্য রেন্ডার ট্রির শুধুমাত্র পরিবর্তিত অংশ পুনরায় আপডেট করে।","উদাহরণ#উদাহরণ:":"function App() {\n    return (\n        <div>\n            <h1>React Render Tree Example</h1>\n            <p>This is a paragraph.</p>\n        </div>\n    );\n}\ndiv এবং তার child nodes (h1 এবং p) একসাথে রেন্ডার ট্রি তৈরি করবে।\nযদি শুধু p ট্যাগ আপডেট হয়, রিয়াক্ট শুধুমাত্র সেই অংশে রেন্ডার করবে, বাকি অংশ অপরিবর্তিত থাকবে।","২-মডিউল-ট্রি-module-tree-কী#২. মডিউল ট্রি (Module Tree) কী?":"মডিউল ট্রি হলো আমাদের অ্যাপ্লিকেশনের সব জাভাস্ক্রিপ্ট মডিউলগুলোর একটি ডিপেনডেন্সি চেইন। এটি দেখায় কোন মডিউলটি কোন মডিউলের উপর নির্ভর করে।","মডিউল-ট্রি-কিভাবে-কাজ-করে#মডিউল ট্রি কিভাবে কাজ করে?":"রিয়াক্ট এবং অন্যান্য মডুলার ফ্রেমওয়ার্কে, বিভিন্ন ফাইল/মডিউল একে অপরের উপর নির্ভর করে কাজ করে। Webpack বা অন্য কোন মডিউল বান্ডলার, মডিউলগুলোকে একটি ট্রি স্ট্রাকচারে সাজায় যেখানে প্রতিটি মডিউল অন্য মডিউলের সাথে সম্পর্কিত হয়।","উদাহরণ-1#উদাহরণ:":"ধরা যাক, আপনার তিনটি ফাইল আছে: App.js, Header.js, এবং Footer.js। App.js তে আপনি Header.js এবং Footer.js কে ইম্পোর্ট করছেন।\n// App.js\nimport Header from \"./Header\";\nimport Footer from \"./Footer\";\nfunction App() {\n    return (\n        <>\n            <Header />\n            <Footer />\n        </>\n    );\n}\nexport default App;\nএখানে মডিউল ট্রি এরূপ হবে:\nApp.js\n  ├── Header.js\n  └── Footer.js","মডিউল-ট্রির-প্রয়োজনীয়তা-ও-সুবিধা#মডিউল ট্রির প্রয়োজনীয়তা ও সুবিধা:":"মডিউল ট্রির কারণে অ্যাপ্লিকেশনকে ছোট ছোট মডিউলে ভাগ করা সম্ভব হয়, যা রক্ষণাবেক্ষণ সহজ করে।\nএটি কোডের পুনরায় ব্যবহারযোগ্যতা বাড়ায়।\nমডিউল ডিপেনডেন্সি বুঝতে এবং অপ্রয়োজনীয় মডিউল বাদ দিতে সাহায্য করে।","রেন্ডার-ট্রি-এবং-মডিউল-ট্রির-সম্মিলিত-কাজ#রেন্ডার ট্রি এবং মডিউল ট্রির সম্মিলিত কাজ":"রিয়াক্ট অ্যাপ্লিকেশন যখন ব্রাউজারে চলে, তখন মডিউল ট্রি মডিউলগুলোকে লোড এবং রিজলভ করে এবং এরপর রেন্ডার ট্রি সেই সব মডিউল থেকে UI রেন্ডার করে।","ইলাস্ট্রেশন#ইলাস্ট্রেশন:":"রেন্ডার ট্রি: একটি গাছের মতো যেখানে প্রতিটি শাখা DOM এর একটি অংশ। শীর্ষে div থাকে এবং তার নিচে child elements।\nমডিউল ট্রি: একটি ডিপেনডেন্সি গাছ যেখানে App.js হলো মূল শাখা এবং অন্যান্য child modules তার সাথে যুক্ত থাকে।","সংক্ষেপে#সংক্ষেপে:":"রেন্ডার ট্রি UI কে ব্রাউজারে দেখানোর জন্য DOM এবং CSSOM এর সম্মিলিত অবস্থা।\nমডিউল ট্রি অ্যাপ্লিকেশনের মডিউলগুলো একে অপরের সাথে কিভাবে সংযুক্ত তা বুঝায়।"}},"/reactive-accilarator/React-js/module-2/event-propagation":{"title":"Event Propagation","data":{"ইভেন্ট-ডেলিগেশন-event-deligation-কি-#ইভেন্ট ডেলিগেশন (event deligation) কি ?":"ইভেন্ট ডেলিগেশন হলো একাধিক এলিমেন্টের জন্য একটাই ইভেন্ট লিসেনার রাখা এবং নতুন কোন এলিমেন্ট যুক্ত হলেও যেন লিসেনার কাজ করে ।ইভেন্ট ডেলিগেশন হলো এমন একটা টেকনিক যা মূলত দুইটা জিনিসে ফোকাস করেঃ-\nএকাধিক এলিমেন্টের জন্য একটাই ইভেন্ট লিসেনার থাকবে ।\nযদি কখনো নতুন এলিমেন্ট যুক্ত হয় তাতেও যেন ইভেন্ট লিসেনার ঠিকঠাক ভাবে কাজ করে।\nধরুন আমাদের একটি প্রোডাক্টের ডাটার লিস্ট আছে যা API থেকে আসতেছে। এবং আমরা চাই এই প্রতিটা ডাটার জন্য এমন একটা ফাংশনালিটি বানাতে যাতে প্রতিটা ডাটার নামে উপর ক্লিক করলেই সেই ডাটার নামের পিছনে একটা ব্যাকগ্রাউন্ড কালার যুক্ত হবে।এখন বিষয়টি এমন ভাবে করতে পারি যে আমরা প্রতিটা আইটেমকে ধরে ধরে তাতে ইভেন্ট লিসেনার লাগিয়ে কাজ করতে পারি। এতে হয়তো একটা সমাধান হতে পারে, কিন্তু যেহেতু ডাটাগুলো API থেকে আসছে তাই আমরা জানিনা হয়তো ডাটার সংখ্যা চেঞ্জ হয়ে যেতে পারে,বা ডাটা বারতে পারে। তখন কি প্রতিটা বারতি ডাটার জন্য আমরা প্রতিবার ইভেন্ট লিসেনার এড করবো ? এটা কখনই সম্ভব না। তাছাড়া প্রতিটা এলিমেন্টের জন্য আলাদা আলাদা লিসেনার এড করতে গেলেও ব্যাপারটা messy হয়ে যাবে। তাহলে উপায় ? উপায় হলো ইভেন্ট ডেলিগেশন টেকনিকচলুন জেনে নেই সেটা কিভাবে করেঃ\n<div class='list-of-item'>\n    <ul id='list'>\n        <li class='item'>Apple</li>\n        <li class='item'>Orange</li>\n        <li class='item'>Strawberry</li>\n        <li class='item'>Banana</li>\n    </ul>\n</div>\nউপরের এই লিস্ট অফ আইটেমগুলোতে আমরা ইভেন্ট ডেলিগেশন টেকনিক এপ্লাই করবো। এতে আমাদের item গুলোর প্যারেন্ট এলিমেন্ট ul এ গিয়ে ইভেন্ট লিসেনার এড করা লাগবে। যাতে আমরা একটা লিসেনার দিয়েই সমস্ত itemগুলোকে ধরতে পারি।\nconst list = document.getElimentById(\"list\");\nlist.addEventListener(\"click\", (e) => {\n    e.target.style.backgroundColor = \"yellow\";\n});\nএখানে আমরা itemগুলোর প্যারেন্ট এলিমেন্ট ulএ ইভেন্ট লিসেনার এড করেছি এবং প্রতিবার ক্লিক এ e.target করে যেটাতে ক্লিক করা হয়েছে সেটাতে ব্যাকগ্রাউন্ড কালার এড করেছি। এর মাধ্যমেই আমরা ইভেন্ট ডেলিগেশন করে ফেলেছি। মানে আমরা ইভেন্টটাকে প্যারেন্টের কাছে ডেলিগেট করেছি।এখন কথা হলো যে, এতে তো ul এর এরিয়াতে ক্লিক পড়লে ul এও ব্যকগ্রাউণ্ড কালার চেঞ্জ হয়ে যাবে।সেক্ষেত্রে আমাদের হেল্প করবে html DOM এর element.matches() মেথড।element.matches()মেথড string হিসেবে একটা ভ্যালু নেয় এবং তা ম্যাচ করে দেখে যে এলিমেন্টের সাথে ম্যাচ করেছে কিনা, এবং Boolean ভ্যালু রিটার্ন করে।তাহলে আমরা এভাবে করতে পারিঃ\nconst list = document.getElimentById(\"list\");\nlist.addEventListener(\"click\", (e) => {\n    if(e.target.matches(\"li\"){\n        e.target.style.backgroundColor = \"yellow\";\n    }\n});\nএভাবে করলে দেখবেন যদি লিস্ট এ নতুন আইটেম যুক্তও হয় তবুও এই একটা লিসেনারই ঠিকঠাক ভাবে কাজ করবে।এটাকেই মূলত ইভেন্ট ডেলিগেশন বলা হয়ে থাকে।","ইভেন্ট-প্রপাগেশন-event-propagation-কি-#ইভেন্ট প্রপাগেশন (event propagation) কি ?":"প্রপাগেশন শব্দের বাংলা অর্থ হলো বিস্তার করা বা প্রসারণ করা বা চলাচল করা।ইভেন্ট প্রপাগেশন হলো জাভাস্ক্রিপ্টের একটা টার্ম । মূলত ইভেন্ট প্রপাগেশন বলতে বুঝায়, যে যদি কোন নেস্টেড এলিমেন্ট থাকে এবং তার প্রতিটা এলিমেন্টেই একটা করে ইভেন্ড লিসেনার এড করা থাকে,তখন যদি একদম ভিতরের কোন এলিমেন্ট ইভেন্টটা ট্রিগার করা হয় তখন আসলে কি ঘটবে?যেমনঃউপরের ছবিতে আমরা তিনটা নেস্টেড এলিমেন্ট দেখতে পাচ্ছি যার প্রতিটাতেই ইভেন্ট লিসেনার এড করা আছে। এবং লিসেনার গুলো এলিমেন্টগুলোতে ক্লিক করলে ট্রিগার হবে।\n<div class='main'>\n    <div class='parent'>\n        <button>Click Me</button>\n    </div>\n</div>\nconst main = document.querySelector(\".main\");\nconst parent = main.querySelector(\".parent\");\nconst button = parent.querySelector(\"button\");\nmain.addEventListener(\"click\", listener);\nparent.addEventListener(\"click\", listener);\nbutton.addEventListener(\"click\", listener);\nfunction listener() {\n    console.log(e.target);\n}\nএখন যদি আমরা button এলিমেন্টে ক্লিক করবো তাহলে আমরা দেখতে পাবো প্রতিটা লিসেনার এ কল হয়ে গেছে এবং কনসল এ তিনটার আউটপুট এসেছে । এইযে একটা ব্যাপার যে ক্লিক করলাম একটাতে আর লিসেনার কল হয়ে গেল তিনটাই, এই ব্যাপারটাকেই বলা হয় event Propagation। মানে ইভেন্টগুলো বাকিদের মাঝেও ছড়িয়ে গেছে।","ইভেন্ট-বাবলিং-bubbling-কি-#ইভেন্ট বাবলিং (Bubbling) কি ?":"const main = document.querySelector(\".main\");\nconst parent = main.querySelector(\".parent\");\nconst button = parent.querySelector(\"button\");\nmain.addEventListener(\"click\", listener);\nparent.addEventListener(\"click\", listener);\nbutton.addEventListener(\"click\", listener);\nfunction listener() {\n    console.log(e.currentTarget);\n}\nআউটপুটঃউপরের কোডটার আউটপুট দেখলে আমরা বুঝতে পারবো যে প্রথমে button তারপর parent এবং সবশেষে main এলিমেন্টে ইভেন্ট লিসেনার ট্রিগার হয়েছে, তার মানে হলো প্রপাগেশন ভিতর থেকে শুরু হয়ে বাহিরের দিয়ে যায়। এটাই হলো প্রোপাগেশন এর ডিফল্ট বিহেবিয়ার। এই যে ভিতর থেকে শুরু হলে বাহিরের দিয়ে ছড়িয়ে যাওয়ার ব্যাপারটাকে অনেকটা বাবল এর মতো চিন্তা করা হয়, তাই একে বলা হয় ইভেন্ট বাবলিং (event bubbling)","ইভেন্ট-কেপচারিং-বা-ট্রিকলিং-capturing-or-trickling-কি-#ইভেন্ট কেপচারিং বা ট্রিকলিং (capturing or trickling) কি ?":"আমরা ইভেন্ট প্রপাগেশনের ডিফল্ট বিহেবিয়ার জানলাম যে প্রপাগেশন ভিতর থেকে শুরু হয়ে বাহিরের দিকে ছড়ায়, কিন্তু আমরা চাইলে এটাকে চেঞ্জ করতে পারি, আমরা চাইলে এটাকে পরিবর্তন করে বাহির থেকে শুরু করে ভিতর দিকে নিতে পারি।তারজন্য আমাদের ইভেন্ট লিসেনার এর তৃতীয় প্যারামিটার এ {capture:true} করে দিতে হয়। ডিফল্টভাবে {capture:false} করা থাকে।\nconst main = document.querySelector(\".main\");\nconst parent = main.querySelector(\".parent\");\nconst button = parent.querySelector(\"button\");\nmain.addEventListener(\"click\", listener, { capture: true });\nparent.addEventListener(\"click\", listener, { capture: true });\nbutton.addEventListener(\"click\", listener, { capture: true });\nfunction listener() {\n    console.log(e.currentTarget);\n}\nআউটপুটঃএইযে আমরা প্রপাগেশনকে capture করে এর ডিরেকশন চেঞ্জ করলাম এটাকে বলা হয় ইভেন্ট কেপচারিং বা ট্রিকলিং (capturing or trickling)।","propagation-in-react#Propagation in React":"রিয়াক্টে সকল ইভেন্ট ই প্রপাগেট হয়,শুধুমাত্র onScroll ইভেন্ট ছাড়া ।","কিভাবে-রিয়াক্টে-প্রপাগেশন-স্টপ-করতে-হয়-#কিভাবে রিয়াক্টে প্রপাগেশন স্টপ করতে হয় ?":"রিয়াক্টে প্রপাগেশন স্টপ করার জন্য event handler এর ভিতরে e.stopPropagation() মেথড কল করে দিতে হয় ।\nfunction Button({ onClick, children }) {\n    return (\n        <button\n            onClick={(e) => {\n                e.stopPropagation(); // এখানে প্রপাগেশন স্টপ করা হয়েছে\n                onClick();\n            }}>\n            {children}\n        </button>\n    );\n}\nexport default function Toolbar() {\n    // এই কম্পোনেন্টে তিনটা এলিমেট আছে নেস্টেড ভাবে এবং প্রতিটা এলিমেন্টেই ইভেন্ট হ্যান্ডেলার এড করা আছে। তার মানে ডিফল্ট ভাবে এখানে প্রপাগেশন হবে ।\n    return (\n        <div\n            className='Toolbar'\n            onClick={() => {\n                alert(\"You clicked on the toolbar!\");\n            }}>\n            <Button onClick={() => alert(\"Playing!\")}>Play Movie</Button>\n            <Button onClick={() => alert(\"Uploading!\")}>Upload Image</Button>\n        </div>\n    );\n}","preventing-the-default-behavior#Preventing the default behavior":"আমরা যখন কোন ফর্ম এর সাবমিট বাটনে ক্লিক করি,তখন ফর্মের ডিফল্ট বিহেবিয়ার হলো ফর্মটা সাবমিট হউয়ার সাথে সাথে ব্রাউজারে পেজটাও রিলোড হয়।আমরা যদি এই ডিফল্ট বিহেবিয়ার কে বন্ধ করতে চাই, তাহলে আমরা e.preventDefault() মেথড কল করে দিতে পারি।\nexport default function Signup() {\n    return (\n        <form\n            onSubmit={(e) => {\n                e.preventDefault();\n                alert(\"Submitting!\");\n            }}>\n            <input />\n            <button>Send</button>\n        </form>\n    );\n}"}},"/reactive-accilarator/React-js/module-2/how-rendering-works":{"title":"How Rendering Works","data":{"":"রিয়াক্ট এপ্লিকেশনে আমরা ব্রাউজার স্ক্রিনে যা কিছু দেখি তার সবকিছুই রিয়াক্টের দ্বারা রেন্ডার হয়ে আসতে হয় ।","রেন্ডার-এবং-কমিট#রেন্ডার এবং কমিট":"এই যে স্ক্রিনে আমরা UI দেখতে পাই তা রিয়াক্টের তিনটা প্রসেসের পর স্ক্রিনে ভিসিবল হয় । চলুন তাহলে জেনে নেই রিয়াক্টের রেন্ডারিং এর এই তিনটা প্রসেস কি আর কিভাবে কাজ করে ।\nTrigering a render:\nRendering the component:\nCommiting to the DOM:","trigger-a-render-ট্রিগারিং-স্টেপ#Trigger a render (ট্রিগারিং স্টেপ):":"মূলত দুইটা করনে রিয়াক্টের render মেথডটা কল হয় বা রেন্ডারিং ট্রিগার হয়ঃ\nইনিশিয়াল রেন্ডার (initial render): একদম সর্বপ্রথম যখন এপ্লিকেশন রান হয় তখন রিয়াক্ট HTML এর একটা root এলিমেন্টের ভিতর রিয়াক্টের সমস্ত কম্পোনেন্টকে রেন্ডার করে দেয় তার React.render() মেথডটাকে কল করার মাধ্যমে ।\nযখন কোন স্টেট আপডেট হয় (Re-render when state update): প্রথমবার সমস্ত কম্পোনেন্ট UI তে এসে যাওয়ার পর, যখন কোন কম্পোনেন্টের ভিতরে কোন স্টেট চেঞ্জ হয় তখন রিয়াক্ট অটেমেটিক ভাবে তার render() মেথডকে কল করে বা রি-রেন্ডার ট্রিগার হয় ।","react-render-your-component-রেন্ডারিং-স্টেপ#React render your component (রেন্ডারিং স্টেপ):":"যখন রিয়াক্টের রেন্ডারিং টা ট্রিগার হয় তখন রিয়াক্ট তার কম্পোনেন্টগুলোকে কল করে। যাতে সে বুঝতে পারে কোথায় পরিবর্তনটা হয়েছে।\nএক্ষেত্রে প্রথম রেন্ডারে রিয়াক্ট তার রুট (root) কম্পোনেন্টকে কল করে\nপরবর্তি সময়ে রি-রেন্ডার ট্রিগার হলে যেই কম্পোনেন্ট থেকে রি-রেন্ডার ট্রিগার হয়েছে সেই কম্পোনেন্টকে কল করে এবং তার প্রথম রেন্ডারের যে Render Tree তার একটা snapshot নিয়ে রাখে এবং পরবর্তি রেন্ডারেরে একটা snapshot নিয়ে তার ভার্চুয়াল ডম এ Diffing এলগরিদমের মাধ্যমে কেলকুলেট করে যে কোথায় পরিবর্তন হয়েছে । তারপর সে নেক্সট স্টেপে চলে যায় কমিট করার জন্য ।\nরেন্ডারিং প্রসেসটা রিকারসিভলি হয়ে থাকে, তার মানে হলো রিয়াক্ট রেন্ডারিং এ যেই কম্পোনেন্টকে কল করেছে তার ভিতর যদি নেস্টেড আরও কোন কম্পোনেন্ট থাকে সেগুলাও রি-রেন্ডার হয়","react-commits-changes-to-the-dom-কমিটিং-স্টেপ#React Commits changes to the DOM (কমিটিং স্টেপ):":"কমিটিং ফেজে এসে রিয়াক্ট DOM মডিফাই করে । এক্ষেত্রে,\nপ্রথম রেন্ডারে রিয়াক্ট DOM এর appendChild() কল করে সমস্ত DOM Nodesগুলোকে রুট এলিমেটে এড করে দেয়\nরি-রেন্ডারের ক্ষেত্রে রিয়াক্ট তার ভার্চুয়াল ডম এ যেই অংশটুকুর পরিবর্তন ডিটেক্ট করতে পারে শুধুমাত্র সেই অংশটুকু DOMএ চেঞ্জ করে দেয়\nপ্রথমবার রেন্ডার হয়ে যাওয়ার পর রিয়াক্ট শুধু তখনি DOM এ চেঞ্জ করে যখন সে দেখতে পারে আগের রেন্ডার এবং পরের রেন্ডারে কোন পার্থক্য আছে। যেই সকল কম্পোনেন্টে কোন প্রকার চেঞ্জ দেখা যায়না রিয়াক্ট সেই সকল কম্পোনেন্টে হাত ই দেয়না।","সবশেষে-ব্রাউজার-পেইন্ট-হয়ঃ#সবশেষে ব্রাউজার পেইন্ট হয়ঃ":"রেন্ডারিং এবং কমিট হয়ে যাওয়ার পর যখন রিয়াক্ট তার DOM টাকে আপডেট করে ফেলে,তখন সে Updated DOMটা ব্রাউজারকে দিয়ে দেয়। এবং ব্রাউজার তা স্ক্রিনে রি-পেইন্ট করে দেয়।"}},"/reactive-accilarator/React-js/module-2/queueing-state":{"title":"Queueing State","data":{"":"রিয়াক্ট প্রতিটা রেন্ডারে মাল্টিপল স্টেট আপডেটকে Queue হিসেবে নেয় এবং একসাথে ব্যাচ করে আপডেট করে । এজন্য বলা হয় React Queueing a Series of State Updates চলুন এ-ব্যাপেরে বিস্তারিত বুঝিঃ","react-batches-multiple-state-updates-রিয়াক্ট-মাল্টিপল-স্টেট-আপডেট-গুলোকে-ব্যাচ-করে#React batches multiple state updates (রিয়াক্ট মাল্টিপল স্টেট আপডেট গুলোকে ব্যাচ করে):":"চলুন একটা কোডের মাধ্যমে বুঝিঃচিন্তা করুন আপনি হোটেলে এসেছেন এবং হোটেলের ওয়েটারকে হয়তো কোন একটা ডিস অর্ডার করেছেন, এবং কিছুক্ষণ পর ওয়েটার আপনাকে আপনার ডিসের অবস্থা জানাবে বা পরিবেশন করবে ।চলুন এবার একটু কোডের দিকে তাকাই,\nimport { useState } from \"react\";\nexport default function App() {\n    const [disStatus, setDishStatus] = useState(\n        \"মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে\"\n    );\n    return (\n        <>\n            <h1>{disStatus}</h1>\n            <button\n                onClick={() => {\n                    setDishStatus(\"আপনার ডিশটি রান্না করা হচ্ছে\");\n                    setDishStatus(\"আপনার ডিসটি রান্না করা হয়ে গেছে\");\n                    setDishStatus(\n                        \"আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস\"\n                    );\n                }}>\n                আমাদের ডিসের কি অবস্থা ?\n            </button>\n        </>\n    );\n}\nআপনি যখন ওর্ডার দিয়েছেন তখন আপনার ডিশের স্টেট হলো মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে যা এই কোডে রিয়াক্টের ইনিশিয়াল স্টেট।এরপর আপনি আপনার ডিসের অবস্থা জানার জন্য আমাদের ডিসের কি অবস্থা ? button এ ক্লিক করলেন ।আপনি যখন বাটনে ক্লিক করলেন তখন বাটনের হেন্ডেলার ফাংশনের ভিতরে তিনটি ধাপে আপনার ডিসের স্ট্যাটাস চেঞ্জ হচ্ছে বা স্টেট আপডেট হচ্ছে।\nপ্রথম স্টেট আপডেটে ডিসের স্ট্যাটাস disStatus করা হয়েছে আপনার ডিশটি রান্না করা হচ্ছে\nদ্বিতীয় স্টেট আপডেটে ডিসের স্ট্যাটাস disStatus করা হয়েছে আপনার ডিসটি রান্না করা হয়ে গেছে\nতৃতীয় স্টেট আপডেটে ডিসের স্ট্যাটাস disStatus করা হয়েছে আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস\nএখন কি মনে হচ্ছে, আপনি কয়টি স্ট্যাটাস দেখতে পাবেন স্ক্রিনে ? পরপর তিনটি স্ট্যাটাস ই কি দেখতে পাওয়ার কথা যেহেতু এখানে তিনবার স্টেট চেঞ্জ হয়েছে তাহলে তিনবার কম্পোনেন্ট রি-রেন্ডার হবে এবং তিনবার এ তিনটি স্ট্যাটাস দেখতে পাওয়া যাবে ।না এখানে তা দেখতে পাবেন না । এখানে আপনি একটা স্ট্যাটাস এ দেখতে পাবেন এবং তা হলো ফাইনাল স্ট্যাটাস আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিসএবার চলুন বুঝি এমন কেন হলো বা রিয়াক্ট কিভাবে এই কাজটা করলোঃ\nরিয়াক্ট স্টেটগুলোকে ব্যাচ আপডেট করে: তারমানে হলো কোন একটা event handler function এর ভিতর যদি স্টেট আপডেট হয় এবং যদি সেই ইভেন্ট হেন্ডেলারের ভিতর মাল্টিপল স্টেট আপডেট থাকে, যেমনঃ\nexport default function App() {\n    <button\n        onClick={() => {\n            setDishStatus(\"আপনার ডিশটি রান্না করা হচ্ছে\");\n            setDishStatus(\"আপনার ডিসটি রান্না করা হয়ে গেছে\");\n            setDishStatus(\"আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস\");\n        }}>\n        আমাদের ডিসের কি অবস্থা ?\n    </button>;\n}\nএই কোডে তিনবার setDishStatus করা হয়েছে । তাহলে রিয়াক্ট শুধু প্রথম setter function পেয়েই সাথে সাথে রি-রেন্ডার ট্রিগার করেনা বরং ওই event handler function এর ভিতরের সমস্ত কোড এক্সিকিউট হউয়ার পর ট্রিগার হয় । এবং তখন ওই event handler function এর ভিতরের সমস্ত স্টেট আপডেটকে ব্যাচ করে নিয়ে যায় এবং একটা স্টেটের কিউ ম্যেনেজ করে। এবং তারপর কিউ থেকে প্রতিটা স্টেট এক এক করে চেঞ্জ করে। এবং পরের রেন্ডারে সমস্ত আউটপুট একসাথে পাওয়া যায়।এখন প্রশ্ন জাগতে পারে যে,যদি তাই হয় তাহলেতো আমরা প্রথম উদাহরণের কোডের আউটপুট হিসেবে তিনটা স্টেট চেঞ্জের আউটপুট ই পেতাম।তাহলে চলুন এটাও আরেকটু ভালোভাবে বুঝিঃ","updating-the-same-state-multiple-times-before-the-next-render#Updating the same state multiple times before the next render":"রিয়াক্ট এর স্টেট আপডেট করা জন্য যেই ফাংশনে আপরা স্টেট চেঞ্জ করি সেখানে দুইটা উপায়ে করা যায়ঃ\nReplace the value of state with setter function:\nexport default function App() {\n    const [disStatus, setDishStatus] = useState(\n        \"মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে\"\n    );\n    <button\n        onClick={() => {\n            setDishStatus(\"আপনার ডিশটি রান্না করা হচ্ছে\");\n            setDishStatus(\"আপনার ডিসটি রান্না করা হয়ে গেছে\");\n            setDishStatus(\"আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস\");\n        }}>\n        আমাদের ডিসের কি অবস্থা ?\n    </button>;\n}\nআমরা যখন এইভাবে স্টেট আপডেট করছি তখন আসলে স্টেট এর পূর্বের ভ্যালুটাকে রিপ্লেস করে দিয়ে নতুন ভ্যালু দিচ্ছি। তাই উপরের উদাহরণে যখন লাস্ট setter function কল হয়েছে তখন disStatus রিপ্লেস হয়ে গিয়েছে। তাই আমরা আউটপুটে শুধু আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস এটাই দেখতে পেয়েছি।\nUpdate the value of state with updater function:\nexport default function App() {\n    const [disStatus, setDishStatus] = useState(\n        \"মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে\"\n    );\n    <button\n        onClick={() => {\n            setDishStatus((d) => `${d} , আপনার ডিশটি রান্না করা হচ্ছে `);\n            setDishStatus((d) => `${d} , আপনার ডিসটি রান্না করা হয়ে গেছে `);\n            setDishStatus(\n                (d) => `${d} , আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস `\n            );\n        }}>\n        আমাদের ডিসের কি অবস্থা ?\n    </button>;\n}\nএখানে আমরা setDishStatus এর ভিতরে একটা anonymous Arrow ফাংশনের সিনট্যাক্স ব্যাবহার করেছি, যা প্যারামিটারে আগের স্টেট ভ্যালুটা রিসিভ করে। এবং তারপর তার সাথে নতুন ভ্যালু যোগ করে ভ্যালু আপডেট করে।এভাবে করলে প্রতিটা স্টেট আপডেট করার সময় আগের স্টেটের ভ্যালুটা পাওয়া যায়,এবং সেই ভ্যালু দিয়ে নতুন ভ্যালু আপডেট করা যায়।উপরের updater function এর উপায়ে যদি আমরা স্টেট আপডেট করি তাহলে আমরা তিনটা চেঞ্জ ভেলুই ফাইনালি দেখতে পাবো এভাবেঃ মাত্র অর্ডার রিসিভ করা হয়েছে এবং রান্নার জন্য পাঠানো হয়েছে,আপনার ডিশটি রান্না করা হচ্ছে,আপনার ডিসটি রান্না করা হয়ে গেছে,আপনার ডিসটি পরিবেশন করা হয়েছে , ইনজয় দ্যা ডিস"}},"/reactive-accilarator/React-js/module-2/state-as-a-snapshot":{"title":"State as a Snapshot","data":{"":"স্টেট ভেরিয়েবল নরমাল জাবাস্ক্রিপ্ট ভেরিয়েবলের মতো মনে হলেও এটা মোটেও জাবাস্ক্রিপটের নরমাল ভেরিয়েবল এর মতো কাজ করেনা। চলুন বিস্তারিত জেনে নেয়া যাক।","rendering-takes-a-snapshot-in-time#Rendering takes a snapshot in time:":"এর মানে হলো রিয়াক্ট তার প্রতিটা রেন্ডারে একটা করে snapshot নেয়। এবং তা মনে রাখে। যখনি কোন স্টেট এর ভ্যালু চেঞ্জ হয় তখন রিয়াক্ট কম্পোনেন্টকে রি-রেন্ডার করে এবং পরের রেন্ডারে গিয়ে তার ভ্যালু আপডেট হয়। তার মানে হলো আমরা নরমাল ভেরিয়েবল এ যেমন কোন ভ্যালু চেঞ্জ করলে পরের লাইনেই তা এক্সেস করতে পারি কিন্তু রিয়াক্টে তা পারিনা,কেননা রিয়াক্ট ইনপ্লেস ভ্যালু চেঞ্জ করেনা। ভ্যালুটা চেঞ্জ হয় তার পরের রেন্ডারে।একটা উদাহরণের মাধ্যমে বুঝা যাকঃ\nimport { useState } from \"react\";\nexport default function App() {\n    const [number, setNumber] = useState(1);\n    function handleClick() {\n        setNumbers(number + 5);\n        console.log(number);\n    }\n    return <button onClick={handleClick}>Incriment the number</button>;\n}\nউপরের কোডটার কনসলে আউটপুট কত আশার কথা? স্বাভাবিক ভাবে দেখলে মনে হয় যে আউটপুত 6আসার কথা। কিন্তু না , এখানে আউটপুট আসবে 1। কারণ রিয়াক্ট তার স্টেট চেঞ্জ হলেই ডিরেক্ট ভ্যালু চেঞ্জ করে দেয়না, তাই সেই ভ্যালুটা পরের লাইনগুলোতে এক্সেস করা যায়না।যেই হেন্ডেলার ফাংশনে setter function কল করা হয়েছে সেই হেন্ডেলার এর পুরো কোডটা এক্সিকিউট হয়ে যাওয়ার পর রি-রেন্ডার ট্রিগার হয় এবং পরের রেন্ডারে আপডেটেড ভ্যালু পাওয়া যায়।আরেকটা উদাহরণ যদি আমারা দেখিঃ\nimport { useState } from \"react\";\nexport default function Counter() {\n    const [number, setNumber] = useState(0);\n    return (\n        <>\n            <h1>{number}</h1>\n            <button\n                onClick={() => {\n                    setNumber(number + 1);\n                    setNumber(number + 1);\n                    setNumber(number + 1);\n                }}>\n                +3\n            </button>\n        </>\n    );\n}\nএখানে একটা বাটনে তিনবার setter function কল করা হয়েছে এবং তিনবার স্টেট এর ভ্যালু আপডেট করা হয়েছে। এই কোডটা রান করে আমরা যদি বাটনে ক্লিক করি তাহলে আউটপুট কত আসার কথা- 3?কিন্তু না আউটপুট আসবে 1 ।যেহেতু স্টেট শুধুমাত্র পরের রেন্ডারে চেঞ্জ হয় তাই প্রথম রেন্ডারে স্টেট এর ভ্যালু ছিল 0। তাই প্রথম রেন্ডারে তিনবার setter function কল হলেও তিনবার এ সে স্টেটের ইনিশিয়াল ভ্যালু পাবে 0। আর তাই নাম্বার এর আউটপুট আসবে 1\n<button\n    onClick={() => {\n        setNumber(number + 1);\n        setNumber(number + 1);\n        setNumber(number + 1);\n    }}>\n    +3\n</button>\nএখানে যেটা হচ্ছে প্রথম রেন্ডারে প্রথমবার যখন setNumber(number + 1) করা হচ্ছে তখন আসলে 0 + 1 = 1 করা হচ্ছে যা পরের রেন্ডারে আউটপুটে আসবে,কিন্তু পরের রেন্ডারে যাওয়ার আগে আরও দুইবার setNumber(number + 1) করা হয়েছে,তার মানে তখনও কিন্তু 0 + 1 = 1 ই করা হচ্ছে ।তারমানে শেষবার যখন setNumber(number + 1) করা হয়েছে, তখন কিন্তু 0 + 1 = 1 ই করা হয়েছে এবং স্টেট তার মেমরিতে 1 নিয়েই পরের রেন্ডার ট্রিগার করেছে এবং আউটপুটে 1 প্রিন্ট হয়েছে ।\n<button\n    onClick={() => {\n        setNumber(0 + 1);\n        setNumber(0 + 1);\n        setNumber(0 + 1);\n    }}>\n    +3\n</button>\nআবার যদি কোডটা এমন হয়ঃ\nexport default function Counter() {\n    const [number, setNumber] = useState(0);\n    return (\n        <>\n            <h1>{number}</h1>\n            <button\n                onClick={() => {\n                    setNumber(number + 5);\n                    setTimeout(() => {\n                        alert(number);\n                    }, 3000);\n                }}>\n                +5\n            </button>\n        </>\n    );\n}\nএখানে বাটনে নাম্বারের স্টেট চেঞ্জ করা হয়েছে এবং একটা setTimeout() কল করা হয়েছে ৩ সেকেন্ডের জন্য। এবং তাতে নাম্বার এর ভ্যালুটা এলার্টে নেয়া হয়েছে।এখানেও হয়তো মনে হতে পারে যে নাম্বার এর ভ্যালু এলার্টে 5 আসবে,কেননা যতক্ষণে ৩ সেকেন্ড টাইমার শেষ হবে ততক্ষণে স্টেট রি-রেন্ডার হয়ে যাবে এবং আমরা এলার্টে আপডেটেড ভ্যালু পাবো ।কিন্তু না এখানেও ব্যাপারটাকে snapshot হিসেবে চিন্তা করতে হবে, এখানে timeOut টা তিন সেকেন্ড পরে হলেও যখন টাইমআউট শুরু হয়েছে তখন কিন্তু সে number এর ভ্যালু 0 নিয়েই গিয়েছে, তাই টাইমার যতই নিয়ে যাক প্রথম রেন্ডারে সে তাই পাবে যেটা তার ইনিশিয়াল ভ্যালু।অর্থাৎ রিয়াক্টের একটা রেন্ডারে কখনই সরাসরি ভ্যালু চেঞ্জ হয়না, বরং স্টেট চেঞ্জ হলে একটা রি-রেন্ডার ট্রিগার হয় এবং পরের রেন্ডারে গিয়ে তার আপডেটেড ভ্যালু পাওয়া যায়।"}},"/reactive-accilarator/React-js/module-2/responding-to-event":{"title":"Responding to Event","data":{"":"রিয়াক্ট আমাদের ইভেন্ট হ্যন্ডেল করার সিস্টেম দিয়ে দিয়েছে। ইভেন্ট হ্যান্ডেলার হলো মূলত যখন কোন ইভেন্ট ট্রিগার হয়, যেমন ঃ ক্লিক,হভার,ফোকাস এসব।","adding-event-handler-to-jsx#Adding Event Handler to JSX":"রিয়াক্টে আমরা দুটি স্টেপে Event Handler এড করতে পারিঃ","হ্যান্ডেলার-ফাংশন-ডিক্লেয়ার-করা-এবং-লজিক-এড-করাঃ#হ্যান্ডেলার ফাংশন ডিক্লেয়ার করা এবং লজিক এড করাঃ":"প্রথমত একটা হ্যান্ডেলার ফাংশন ডিক্লেয়ার করতে হবে এবং এতে লজিক ইমপ্লিমেন্ট করতে হবে।\nধরুন, একটা button এ ক্লিক করলে আমরা দেখাতে চাই যে \"বাটনে ক্লিক করা হয়েছে\" সেক্ষেত্রে আমাদের হ্যান্ডেলার ফাংশন ও লজিক হবে এমনঃ\nexport default function Button(){\n    function handleClick(){ // এখনে handleClick নামে একটা হ্যন্ডেলার ফাংশন ডিক্লেয়ার করা হয়েছে এবং তার ভিতরে লজিক ইমপ্লিমেন্ট করা হয়েছে।\n        alert(\"বাটনে ক্লিক করা হয়েছে\");\n    }\n}","হ্যান্ডেলার-ফাংশনটি-বাটনে-এড-করাঃ#হ্যান্ডেলার ফাংশনটি বাটনে এড করাঃ":"এরপর হ্যান্ডেলার ফাংশনটি button এলিমেন্টে এড করতে হবেঃ\nexport default function Button(){\n    function handleClick(){\n        alert(\"বাটনে ক্লিক করা হয়েছে\");\n    }\nreturn <button onClick={handleClick}>Click Me</button> // এখনে বাটনের onClick এ হ্যান্ডেলার ফাংশনটি এড করা হয়েছে।\n}\nএছাড়াও আমরা JSX এর ইনলাইনেও Event Handler ফাংশন এড করতে পারি ।যেমনঃ\nexport default function Button(){\nreturn <button onClick={ function handleClick(){\n        alert(\"বাটনে ক্লিক করা হয়েছে\");\n    }}>Click Me</button> // এখনে বাটনের onClick এ হ্যান্ডেলার ফাংশনটি এড করা হয়েছে।\n}\nঅথবা আরও ছোট করেও লিখতে পারি Arrow Function এর সিনট্যাক্সেঃ\nexport default function Button() {\n    return (\n        <button\n            onClick={() => {\n                alert(\"বাটনে ক্লিক করা হয়েছে\");\n            }}>\n            Click Me\n        </button>\n    ); // এখনে বাটনের onClick এ হ্যান্ডেলার ফাংশনটি এড করা হয়েছে।\n}\nএখানে একটি ফাংশন ডিফাইন করা হয়েছে handleClick নামে এবং তা button এলিমেন্টে as a props পাস করা হয়েছে । handleClick ফাংশনটি একটা event handler ফাংশন।\n👉 ইভেন্ট হ্যান্ডেলার ফাংশনগুলো কম্পোনেন্ট এর ভিতরে ডিফাইন করতে হয় ।\n👉 কনভেনশন অনুযায়ী event handlerএর নামগুলোর শুরুতে handle এবং তারপর\nevent name দিয়ে লিখতে হয়। যেমনঃhandleClick handleMouseEnter\nhandleMouseLeave\nইভেন্ট হ্যান্ডেলার ফাংশনগুলো কম্পোনেন্ট এর ভিতরে পাস করতে হবে, অবশ্যই শুধুমাত্র পাস করা লাগবে, কল করা যাবেনা\nযেমনঃ\n✅ শুধুমাত্র পাস করা হয়েছে\t❌ সরাসরি কল করা হয়েছে\t<button onClick={handleClick}</button>\t<button onClick={handleClick()}</button>\t\nএই দুইটা সিস্টেমের মাঝে খুব ভালো একটা পার্থক্য আছে।\nশুধুমাত্র পাস করা <button onClick={handleClick}</button> মানে হলো - রিয়াক্ট কে বলা যে আমি তোমাকে একটা ইভেন্ট হ্যান্ডেলার দিয়ে দিলাম,তুমি এটা মনে রেখো যে যখনি ওই ইভেন্ট টা ঘটবে তখনই তুমি ফাংশন টা কল করে দিও।\nএক্ষেত্রে যেমন Click ইভেন্ট হ্যান্ডেলার ব্যাবহার করা হয়েছে,তার মানে হলো যখন Click হবে ঠিক তখনি ফাংশনটা কল হবে এবং আউটপুট দেখা যাবে ।\nকিন্তু সরাসরি কল করে দেয়া <button onClick={handleClick()}</button> মানে হলোঃ কম্পোনেন্ট রেন্ডার হওয়ার সাথে সাথেই অটোমেটিক ফাংশন কল হয়ে যাবে , এতে ক্লিক হউয়ার জন্য ওয়েট করবেনা । এতে করে যদি কখনো কোন ফাংশনের দ্বারা State ম্যানেজ করা হয়ে থাকে, তখন বার বার State চেঞ্জ হতে থাকবে আর কম্পোনেন্ট রি-রেন্ডার হতে থাকবে। এটা এপ্লিকেশন একটা infinte লুপে পড়ে যাবে।\nইনলাইনে ফাংশন ডিফাইন করার ক্ষেত্রেও এই একই বিষয় টা খেয়াল রাখতে হয়। যদিও সেখানে শুদুমাত্র আমরা ফাংশনের ডেফিনেশন টাই লিখি ফাংশনটা কল করে দেইনা। তবে IIFE-(immediately invoked function expression) সাথে সাথেই কল হয়ে যায় বলে আমরা ইনলাইনে IIFE-(immediately invoked function expression) লিখতে পারবোনা।","reading-props-in-event-handler#Reading Props in Event Handler":"ইভেন্ট হ্যান্ডেলারগুলো যেহেতু কম্পোনেন্টের ভিতরে লেখা হয় তাই কম্পোনেন্টের যেসব প্রপস আছে তা event handler functionগুলো সরাসরি এক্সেস করতে পারে ।","pass-event-handler-to-child-components-as-props#Pass Event Handler to Child Components as Props":"কখনো কখনো আমাদের প্যারেন্ট কম্পোনেন্ট থেকে চাইল্ড কম্পোনেন্ট এর ইভেন্ট কে ম্যানেজ করা লাগে। সেই ক্ষেত্রে প্যারেন্ট কম্পোনেন্টে event handler function ডিফাইন করে তা প্রপস আকারে চাইল্ড কম্পোনেন্টে পাস করা যায়।চলুন একটু বিস্তারিত বুঝিঃ\nexport default function App() {\n    function handlePlay() {\n        alert(\"Movie is playing\");\n    }\n    return <MovieCard onPlay={handlePlay} />;\n}\nexport default function MovieCard({ onPlay }) {\n    return <button onClick={onPlay}>Play</button>;\n}\nএখানে App কম্পোনেন্ট একটি প্যারেন্ট কম্পোনেন্ট এবং এর চাইল্ড হিসেবে রয়েছে একটা MovieCard কম্পোনেন্ট। এবং মুভিকার্ড কম্পোনেন্ট এ একটা প্রপ্স পাস করা হয়েছে onPlay নামে। এই onPlay প্রপস এর মাধ্যমে মূলত handlePlay নামক একটা ইভেন্ট হ্যান্ডেলার পাস করা হয়েছে ।চাইল্ড কম্পোনেন্ট MovieCard সেই প্রপস টাকে রিসিভ করেছে এবং বাটনের onClick এ তা ট্রিগার করা হয়েছে।তার মানে হলো চাইল্ড কম্পোনেন্ট MovieCard এর বাটনে ক্লিক হলে কোন হ্যন্ডেলার ফাংশন কল হবে তা আমরা প্যারেন্ট কম্পোনেন্টেই ডিফাইন করতে পারি এবং তা প্রপস আকারে পাঠাতে পারি ।","naming-conventions-of-event-handler-props#Naming Conventions of event handler props":"👉 ইভেন্ট হ্যান্ডেলার প্রপস এর নামের শুরুতে on দিয়ে শুরু করতে হয়।\n👉 যেসব রিসার্ভড কিওয়ার্ড আছে যেমনঃ onClick,onHover এসব শুধুমাত্র html এর নেটিভ ইলিমেন্টে ব্যাবহার করা উচিত।\n👉 onদিয়ে শুরু করে তারপর প্রসঙ্গত যেকোন নামেই ব্যাবহার করা যায়। যেমনঃ onClick এর পরিবর্তে onSmash ব্যাবহার করা যায় ।"}},"/reactive-accilarator/React-js/module-2/understanding-state":{"title":"Understanding State","data":{"":"রিয়াক্ট এপ্লিকেশনে যখনি কোন এন্টারেকশনে কোনকিছু চেঞ্জ করা প্রয়োজন হয় তখনি স্টেট এর প্রয়োজন হয়।","স্টেট-state-কি-#স্টেট (State) কি ?":"State এর বাংলা মানে হলো অবস্তা । ভিন্ন ভিন্ন অবস্থার স্টেট হয় ভিন্ন ভিন্ন।ধরুন একটা Button এ ক্লিক করলে একটা Modal ওপেন হবে । এইযে Modal একবার ওপেন হবে এটা একটা অবস্থা, আবার যখন Modal ক্লোজ থাকবে সেটা আবার আরেক অবস্থা। এটাকেই বলা হয় State।রিয়াক্ট যেহেতু একটা রিয়াক্টিভ এপ্লিকেশনে সাহায্য করে তাই রিয়াক্ট যাতে বুঝতে পারে যে এপ্লিকেশনে কিছু চেঞ্জ হয়েছে,তাকে রি-রেন্ডার করতে হবে, এবং কোন অবস্থায় কি ছিল, সেটা তাকে মনে রাখতে হবে তাই তাকে এপ্লিকেশনের বিভিন্ন স্টেট ম্যানেজ করা লাগে। আর এই কাজটা রিয়াক্ট করে তার বিল্ট ইন hook useState এর মাধ্যমে।","এই-কাজগুলো-কি-আমরা-রেগুলার-ভেরিয়েবল-নিয়ে-কন্ডীশনালি-করতে-পারিনা-#এই কাজগুলো কি আমরা রেগুলার ভেরিয়েবল নিয়ে কন্ডীশনালি করতে পারিনা ?":"নাহ, রিয়াক্ট এপ্লিকেশনে আমরা সেটা পারিনা,কেননা রিয়াক্ট এপ্লিকেশনে কোনকিছু চেঞ্জ হলেই তার কম্পোনেন্টকে রি-রেন্ডার করতে হয় এবং UI আপডেট করতে হয়। কিন্তু আমরা যদি লোকাল ভ্যারিয়েবল নিয়ে তার মদ্ধে ভ্যালু চেঞ্জ করে দেই,তাহলে রিয়ায়ক্ট সেটাকে মনে রাখতে পারেনা এবং তাতে সে রি-রেন্ডার ও ট্রিগার করেনা। তাহলে হয়তো ভাবতে পারেন যে ,আমরা ম্যনুয়ালি UI আপডেট করে দিলেইতো হয়ে গেল, হ্যাঁ - কিন্তু তাহলে আমরা রিয়াক্টে কেন এসেছি ? রিয়াক্টে এসেছি কারণ যাতে আমাদের কোন কিছু চেঞ্জ হলেই যাতে UIঅটোমেটিক আপডেট হয়।","লোকাল-ভেরিয়েবল-এর-ক্ষেত্রে-যেসব-বিষয়-হয়নাঃ#লোকাল ভেরিয়েবল এর ক্ষেত্রে যেসব বিষয় হয়নাঃ":"Local variables don't persist between renders: মানে হলো যখন কম্পোনেন্ট রি-রেন্ডার হয়, তখন পুরো কম্পোনেন্টটা আবার নতুন করে রেন্ডার হয়। তখন সে তার লোকাল ভেরিয়েবল এ আগের রেন্ডারে কি চেঞ্জ হয়েছিল তা সে মনে রাখেনা ।\nChanges to local variables won't trigger renders: মানে হলো লোকাল ভেরিয়েবল চেঞ্জ হলে রিয়েক্ট বুঝতেই পারেনা যে, তাকে কম্পোনেন্ট রি-রেন্ডার করতে হবে।\nকম্পোনেন্টকে নতুন ডাটা দিয়ে আপডেট হতে হলে দুইটা জিনিস লাগেঃ\nRetain the data between renders: এর মানে হলো রি-রেন্ডারের পর কম্পোনেন্টকে জানতে হয় যে তার আগের রেন্ডারে কি চেঞ্জ হয়েছিল,যেটা সে UI তে আপডেট করবে।\nTrigger a Re-render: মানে হলো কোন স্টেট চেঞ্জ হলেই রিয়াক্টকে তার রি-রেন্ডার ট্রিগার করতে হয় ।\nuseState হুক এই দুটি জিনিস দিয়ে থাকেঃ\nA State Variable: useState হুক একটি স্টেট ভেরিয়েবল দেয় যা সে প্রতিটা রি-রেন্ডারে মনে রাখতে পারে ।\nA Setter Function:useState হুক একটি setter function দেয় যা দিয়ে সে স্টেট ভেরিয়েবলকে চেঞ্জ করতে পারে ।","usestate-হুক---কিভাবে-লিখতে-হয়-এবং-কিভাবে-ব্যাবহার-করতে-হয়-#useState হুক - কিভাবে লিখতে হয় এবং কিভাবে ব্যাবহার করতে হয় ?":"সিনট্যাক্সঃ\nconst [currentValue, setterFunction] = useState(initialValue);","রিয়াক্ট-থেকে-usestate-হুক-ইম্পোর্ট-করতে-হবেঃ#রিয়াক্ট থেকে useState হুক ইম্পোর্ট করতে হবেঃ":"import { useState } from \"react\";\nexport default function App() {\n    return (\n    <>\n        <h1>Count:  </h1>\n        <button>Click to Incriment Count</<button>\n    </>\n    );\n}","usestate-হুক-ডিক্লেয়ার-করা-#useState হুক ডিক্লেয়ার করা ।":"import { useState } from \"react\";\nexport default function App() {\nconst [count, setCount] = useState(0);\n    return (\n    <>\n         <h1>Count:  </h1>\n        <button>Click to Incriment Count</<button>\n    </>\n    );\n}","setter-function-এর-মাধ্যমে-state-variable-এর-ভ্যালু-চেঞ্জ-করা-এবং-ভ্যালু-ব্যাবহার-করা-#setter function এর মাধ্যমে State variable এর ভ্যালু চেঞ্জ করা এবং ভ্যালু ব্যাবহার করা ।":"import { useState } from \"react\";\nexport default function App() {\nconst [count, setCount] = useState(0);\n    function handleCountIncriment() {\n        setCount(count + 1);\n    }\n    return (\n    <>\n         <h1>Count: {count}  </h1>\n        <button onClick={handleCountIncriment}>Click to Incriment Count</<button>\n    </>\n    );\n}\n**রিয়াক্টে সকল ফাংশন যেগুলা শুরুতে use দিয়ে নামকরন করা হয়েছে সেগুলা প্রতিটাই হলো হুক। শুধু useState ই নয়,রিয়েক্টের এমন বিল্ট ইন আরও অনেক হুক রয়েছে যেগুলো আমরা পরে যানতে পারবো । এসব প্রতিটা হুক রিয়াক্টে আলাদা আলাদা ফিচার যুক্ত করেছে। তাই রিয়াক্টের হুকগুলো হলো একেকটা স্পেশাল ফাংশন । তাই এগুলোকে নরমাল ফাংশনের মতো চিনটা করলে হবেনা। আর রিয়াক্টের হুকগুলোকে সবসময় কম্পোনেন্টের টপ লেভেলে ব্যাবহার করতে হয় । এগুলোকে কখনওই কোন কন্দীশন,লুপ বা অন্যান্য ফাংশনের ভিতরে ব্যাবহার করা যাবেনা । **","রিয়াক্টের-usestate-হুক-কিভাবে-কাজ-করে-#রিয়াক্টের useState হুক কিভাবে কাজ করে ?":"যখনি আমরা কোন কম্পোনেন্টের ভিতরে useState লিখি,তার মনে হলো রিয়াক্টকে বলা যে, আমার এই কম্পোনেন্টে কিছু স্টেট আছে সেগুলো তোমাকে মনে রাখতে হবে ।\nconst [index, setIndex] = useState(0);\nএক্ষেত্রে আমরা স্টেট ভেরিয়েবল নিয়েছি index । তাহলে রিয়াক্ট প্রতিটা রেন্ডারে index এর ভ্যালুটাকে তার মেমরিতে মনে রাখবে।\nStateএর নেমিং কনভেনশন হলো - যেই নামে স্টেট ভেরিয়েবল নেয়া হয়েছে,\nsetterFunction এর নামটাও সেই নামটাকে ফলো করেই দেয়া উচিত । যেমন: const\n    [index, setIndex] = useState(0);","রেন্ডার-এবং-রি-রেন্ডারিং-প্রসেসঃ#রেন্ডার এবং রি-রেন্ডারিং প্রসেসঃ":"const [index, setIndex] = useState(0);\nপ্রথমবার যখন কম্পোনেন্ট রেন্ডার হয়ঃ আমারা স্টেট ভেরিয়েবলের ইনিশিয়াল যে ভ্যালু দিয়েছিলাম সেটাই রিটার্ন করে। এক্ষেত্রে initial value = 0 তাই স্টেট 0 রিটার্ন করবে ।\nযখন স্টেট ভেরিয়েবল এর ভ্যালু আপডেট করা হয়ঃ যখন ইউজারের ক্লিক বা কোন ইন্টারেকশনে setter function দিয়ে ভ্যালু আপডেট করা হয় setIndex( index + 1 ) তখন স্টেটের ভ্যালু চেঞ্জ হয়ে হয় 1 এবং রিয়েক্টকে তা মনে রাখতে বলে এবং তারপর setter function রিয়াক্টের Render() মেথড কল করে দিয়ে আরেকটা রেন্ডার ট্রিগার করে দেয় ।\nদ্বিতীয়বার যখন রেন্ডার হয়ঃ তখন কম্পোনেন্ট আবার নতুন করে রেন্ডার হয় এবং রিয়াক্ট দেখে যে useState(0) এর initial value 0  কিন্তু আগের রেন্ডারে যখন state value চেঞ্জ হয়েছে তখন রিয়াক্ট সেটাকে মনে রেখেছে, আর তাই সে তখন index এর ভ্যালু 1 রিটার্ন করবে ।\nআর এভাবেই প্রতিটা রেন্ডার চলতে থাকবে ।","যদি-একটা-কম্পোনেন্টে-মাল্টিপল-স্টেট-ভ্যারিয়েবল-নেয়ার-প্রয়োজন-হয়#যদি একটা কম্পোনেন্টে মাল্টিপল স্টেট ভ্যারিয়েবল নেয়ার প্রয়োজন হয়?":"কোন কম্পোনেন্টের যদি মাল্টিপল স্টেট ম্যানেজ করা লাগে,তাহলে মাল্টিপল useState কল করা যায়। এতে কোন সমস্যা নেই। তবে যদি একটা স্টেট আরেকটার সাথে রিলেটেড হয় তাহলে আমরা স্টেট ভ্যালু Array বা object হিসেবে রেখেও কাজ করতে পারি।","state-হলো-কম্পোনেন্টের-প্রাইভেট-ডাটা#State হলো কম্পোনেন্টের প্রাইভেট ডাটা":"রিয়াক্টের স্টেট তার কম্পোনেন্টের ভিতরেই সীমাবদ্ধ। স্টেট কে বলা হয় কম্পোনেন্টের প্রাইভেট ডাটা।ধরুন কোন কম্পোনেন্টে স্টেট ব্যাবহার করা হয়েছে। এখন যতবার ওই কম্পোনেন্টকে ব্যাবহার করা হোক না কেন,প্রতিটার জন্য তার স্টেট হবে আলাদা। এমন নয় যে,কম্পোনেন্ট রি-ইউজ করার জন্য একটার স্টেট চেঞ্জ হলে বাকিগুলোও স্টেট চেঞ্জ করে ফেলবে। এটা কক্ষনো হবেনা। কারণ প্রতিটা কম্পোনেন্টের স্টেট তার ভিতরে আইসোলেটেড অবস্থায় থাকে এবং সেগুলো ইউনিক হয়।তবে যদি আমাদের রিকোয়ারমেন্ট এমন হয় যে আমাদের প্রতিটা রি-ইউজেবল কম্পোনেন্টের স্টেট sync থাকবে বা একটায় স্টেট চেঞ্জ করলে তা প্রতিটায় এফেক্ট করবে,তাহলে আমারা lifting state up টেকনিক ব্যাবহার করতে পারি। যা নিয়ে আমরা পরে বিস্তারিত জানবো ।"}},"/reactive-accilarator/React-js/module-2/updateing-array-in-state":{"title":"Updateing Array in State","data":{"":"জাভাস্ক্রিপ্টে Array মিউটেড করা যায়, কিন্তু যখন আপনি Array কে রিয়াক্টের কোন স্টেট ভ্যারিয়েবল এর ভ্যালু হিসেবে স্টোর করবেন তখন অবশ্যই আপনাকে ভাবতে হবে যে - Array কেও মিউটেড করা যায়না। যখনি কোন স্টেট ভ্যারিয়েবলের ভ্যালু Array থাকবে,তখন তা আপডেট করতে হলে অবশ্যই সম্পুর্ন নতুন Array অথবা আগের Array এর কপি বানিয়ে সেখানে ভ্যালু আপডেট করে তারপর স্টেট এর আপডেটেড ভ্যালু হিসেবে সেট করতে হবে।","updating-arrays-without-mutation---কিভাবে-মিউটেশন-ছাড়া-array-আপডেট-করতে-পারি#(Updating arrays without mutation) - কিভাবে মিউটেশন ছাড়া Array আপডেট করতে পারি।":"জাভাস্ক্রিপ্টে Array হলো একধরনের অবজেক্ট। রিয়াক্টের স্টেট হিসেবে Array কেও সবসময় read-only মনে করতে হবে। তাই আপনি কখনওই arr[0]= \"something\" এভাবে সরাসরি রি-এসাইন করতে পারবেন না। এবং এছাড়াও বেশ কিছু Array মেথড আছে যা পুরাতন Array কে মিউটেড করে যেমন: push ,pop,shift,unshift,splice,sort,reverse,arr[i] এইগুলো রিয়াক্টের স্টেট আপডেট করার জন্য ব্যাবহার করা উচিত নয়।চলুন জেনে নেই রিয়াক্ট এর স্টেট আপডেট করা জন্য Array ডাটা আপডেট করতে কোন কোন মেথডগুলো ব্যাবহার করা যাবে আর কোনগুলো ব্যাবহার করা উচিত নয়।\nব্যাবহারের কারণ\t❌ - পুরাতন Array কে মিউটেড করে\t✅ যেগুলো নতুন Arry রিটার্ন করে\tএড করা (Adding in Array)\tpush, unshift\tconcat, [...sprade,], array.with()\tবাদ দেয়া (Removing from Array)\tpop, shift, splice\tfilter, slice, toSpliced\tরিপ্লেস করা (Replac in Array)\tsplice, arr[0]=\"something\"\tmap, toSpliced\tসর্টিং করা (Sort in Array)\tsort, reverse\tপ্রথমে পুরাতন Array কপি করে নিয়ে sort বা reverse করা, toSorted, toReversed","adding-to-an-array-array-তে-এলিমেন্ট-এড-করা-#(Adding to an Array) Array তে এলিমেন্ট এড করা ।":"avoid push() , use concat or [...spread]Array তে কোনকিছু এড করতে হলে স্বাভাবিকভাবে push() মেথড ব্যাবহার করা যায়,কিন্তু push() মেথড মেইন Array কে মিউটেড করে ফেলে। তাই রিয়াক্টের স্টেট আপডেট করার সময় push() মেথড ব্যাবহার না করে concat অথবা [...spread] ব্যাবহার করে Array তে আইটেম এড করা উচিত।\nlet nextId = 0\nconst [artists, setArtists] = useState([{..}, {..}, {..}]);\nsetArtists([\n    ...artists, // that contains all the old items\n    { id: nextId++, name: \"Something\" }, // and one new item at the end\n]);","removing-from-an-array-array-থেকে-এলিমেন্ট-রিমুভ-করা#(Removing from an array) Array থেকে এলিমেন্ট রিমুভ করা।":"avoid pop,unshift use filter or slice or toSpliced Array থেকে কোন কিছু বাদ দিতে হলে সবচেয়ে সহজ উপায় হলো filter ব্যাবহার করা। filter মেথড মেইন Array তে হাত দেয়না, বরং একটা নতুন Array রিটার্ন করে।\nlet nextId = 0\nconst [artists, setArtists] = useState([{..}, {..}, {..}]);\nconst filteredData = artists.filter((item)=> item.id !== 2)\nsetArtists(filteredData)","transforming-an-array-array-কে-পরিবর্তন-করা#(Transforming an array) Array কে পরিবর্তন করা।":"যদি Arrayএর কোন আইটেমের মদ্ধ্যে কোনকিছু পরিবর্তন করতে হয় তাহলে map() ব্যাবহার করে করা উচিত। map() মেইন Array কে পরিবর্তন করেনা বরং একটি নতুন Array রিটার্ন করে।map() দিয়ে একটা Array এর প্রতিটা আইটেমের ভিতর দিয়ে itareate করে কন্ডিশনলি যেখানে পরিবর্তন করা প্রয়োজন,সেখানে পরিবর্তন করা যায়।","replacing-items-in-an-array--array-এর-মধ্য-থেকে-কোন-আইটেমকে-রিপ্লেস-করা-#(Replacing items in an array ) Array এর মধ্য থেকে কোন আইটেমকে রিপ্লেস করা ।":"যদি Arrayএর কোন আইটেমের মদ্ধ্যে থেকে কোন আইটেম কে রিপ্লেস করতে হয় তাহলে map() ব্যাবহার করে করা উচিত।map() দিয়ে একটা Array এর প্রতিটা আইটেমের ভিতর দিয়ে itareate করে কন্ডিশনলি যেই আইটেম টি রিপ্লেস করা প্রয়োজন,সেটি রিপ্লেস করা যায়।","inserting-into-an-array-array-এর-কোন-পজিশনে-আইটেম-ইনসার্ট-করা#(Inserting into an array) Array এর কোন পজিশনে আইটেম ইনসার্ট করা।":"Array এর কোন নির্দিষ্ট পজিশনে কোন আইটেম এড করতে চাইলে slice অথবা toSpliced ব্যাবহার করা যেতে পারে। toSpliced ECMA SCRIPT 2023 এর নতুন ফিচার। এটি মেইন Array কে পরিবর্তন করেনা এবং নতুন Array রিটার্ন করে।slice() মেথড ব্যাবহার করে ইনসার্টঃ\nimport { useState } from \"react\";\nlet nextId = 3;\nconst initialArtists = [\n    { id: 0, name: \"Marta Colvin Andrade\" },\n    { id: 1, name: \"Lamidi Olonade Fakeye\" },\n    { id: 2, name: \"Louise Nevelson\" },\n];\nexport default function List() {\n    const [name, setName] = useState(\"\");\n    const [artists, setArtists] = useState(initialArtists);\n    function handleClick() {\n        const insertAt = 1; // কোন পজিশনে ইনসার্ট হবে সেই নাম্বার\n        const nextArtists = [\n            // ইনসার্ট পজিশনের আগের আইটেমগুলো\n            ...artists.slice(0, insertAt),\n            // নতুন আইটেম\n            { id: nextId++, name: name },\n            // বাকি আইটেমগুলো ইনসার্ট পজিশনের পর\n            ...artists.slice(insertAt),\n        ];\n        setArtists(nextArtists);\n        setName(\"\");\n    }\n    return (\n        <>\n            <h1>Inspiring sculptors:</h1>\n            <input\n                value={name}\n                onChange={(e) => setName(e.target.value)}\n            />\n            <button onClick={handleClick}>Insert</button>\n            <ul>\n                {artists.map((artist) => (\n                    <li key={artist.id}>{artist.name}</li>\n                ))}\n            </ul>\n        </>\n    );\n}\ntoSpliced() মেথড ব্যাবহার করে ইনসার্টঃ\nimport { useState } from \"react\";\nlet nextId = 3;\nconst initialArtists = [\n    { id: 0, name: \"Marta Colvin Andrade\" },\n    { id: 1, name: \"Lamidi Olonade Fakeye\" },\n    { id: 2, name: \"Louise Nevelson\" },\n];\nexport default function List() {\n    const [name, setName] = useState(\"\");\n    const [artists, setArtists] = useState(initialArtists);\n    function handleClick() {\n        const insertAt = 1; // কোন পজিশনে ইনসার্ট হবে সেই নাম্বার\n        const nextArtists = artists.toSpliced(insertAt, {\n            // নতুন আইটেম এড করে নতুন অ্যারে রিটার্ন করবে\n            id: nextId++,\n            name: \"Something\",\n        });\n        setArtists(nextArtists);\n        setName(\"\");\n    }\n    return (\n        <>\n            <h1>Inspiring sculptors:</h1>\n            <input\n                value={name}\n                onChange={(e) => setName(e.target.value)}\n            />\n            <button onClick={handleClick}>Insert</button>\n            <ul>\n                {artists.map((artist) => (\n                    <li key={artist.id}>{artist.name}</li>\n                ))}\n            </ul>\n        </>\n    );\n}","sort-or-reverse-in-array---সর্ট-অথবা-রিভার্স-করা-#(sort or reverse in array) - সর্ট অথবা রিভার্স করা ।":"Array কে সরাসরি sort অথবা reverse মেথড ব্যাবহার সর্ট অথবা রিভার্স করতে গেলে তা মেইন Array পরিবর্তন করে দেয়। তাই সরাসরি sort অথবা reverse ব্যাবহার না করে প্রথমে [...spread] সিনট্যাক্স ব্যাবহার করে spread করে নিতে হয়।\nimport { useState } from \"react\";\nconst initialList = [\n    { id: 0, title: \"Big Bellies\" },\n    { id: 1, title: \"Lunar Landscape\" },\n    { id: 2, title: \"Terracotta Army\" },\n];\nexport default function List() {\n    const [list, setList] = useState(initialList);\n    function handleClick() {\n        const nextList = [...list];\n        nextList.reverse();\n        setList(nextList);\n    }\n    return (\n        <>\n            <button onClick={handleClick}>Reverse</button>\n            <ul>\n                {list.map((artwork) => (\n                    <li key={artwork.id}>{artwork.title}</li>\n                ))}\n            </ul>\n        </>\n    );\n}\nএখানে একটা বিষয় মাথায় রাখতে হবে তা হলো,[...spread] সিনট্যাক্স শুধুমাত্র প্রথম লেবেলের কপি বানায়, উপরের উদাহরণ অনুযায়ী যদি শুধুমাত্র অবজেক্টগুলোর অর্ডার টা সর্ট বা রিভার্স করা হয়,তাহলে এই পদ্ধতি ঠিক আছে, কিন্তু যদি Array এর ভিতরের অবজেক্টগুলোকে কোনকিছু করা লাগতো,তাহলে কিন্তু এইভাবে শুধু একবার [...spread] করলে চলবেনা।","updating-objects-inside-an-array---array-ভিতরের-অবজেক্টকে-আপডেট-করা-#(Updating objects inside an Array) - Array ভিতরের অবজেক্টকে আপডেট করা ।":"যখনি আমদের Arrayভিতরের অবজেক্টকে আপডেট করতে হবে তখন আমরাmap()` ব্যাবহার করে সেটা করতে পারি।যেহেতু map() Arrayর প্রতিটা আইটেমের ভিতর দিয়ে itarate করে এবং প্রতি itaration এ একেকটা আইটেম রিটার্ন করে, তাহলে map() ব্যাবহার করে কন্ডিশনালি যেকোন আইটেমকে পরিবর্তন করা যেতে পারে।\nimport { useState } from \"react\";\nlet nextId = 3;\nconst initialList = [\n    { id: 0, title: \"Big Bellies\", seen: false },\n    { id: 1, title: \"Lunar Landscape\", seen: false },\n    { id: 2, title: \"Terracotta Army\", seen: true },\n];\nexport default function BucketList() {\n    const [myList, setMyList] = useState(initialList);\n    const [yourList, setYourList] = useState(initialList);\n    function handleToggleMyList(artworkId, nextSeen) {\n        setMyList(\n            myList.map((artwork) => {\n                if (artwork.id === artworkId) {\n                    // Create a *new* object with changes\n                    return { ...artwork, seen: nextSeen };\n                } else {\n                    // No changes\n                    return artwork;\n                }\n            })\n        );\n    }\n    function handleToggleYourList(artworkId, nextSeen) {\n        setYourList(\n            yourList.map((artwork) => {\n                if (artwork.id === artworkId) {\n                    // Create a *new* object with changes\n                    return { ...artwork, seen: nextSeen };\n                } else {\n                    // No changes\n                    return artwork;\n                }\n            })\n        );\n    }\n    return (\n        <>\n            <h1>Art Bucket List</h1>\n            <h2>My list of art to see:</h2>\n            <ItemList\n                artworks={myList}\n                onToggle={handleToggleMyList}\n            />\n            <h2>Your list of art to see:</h2>\n            <ItemList\n                artworks={yourList}\n                onToggle={handleToggleYourList}\n            />\n        </>\n    );\n}\nfunction ItemList({ artworks, onToggle }) {\n    return (\n        <ul>\n            {artworks.map((artwork) => (\n                <li key={artwork.id}>\n                    <label>\n                        <input\n                            type='checkbox'\n                            checked={artwork.seen}\n                            onChange={(e) => {\n                                onToggle(artwork.id, e.target.checked);\n                            }}\n                        />\n                        {artwork.title}\n                    </label>\n                </li>\n            ))}\n        </ul>\n    );\n}","write-concise-update-logic-with-immer---immer-এর-সাহায্যে-খুব-সহজে-array-অপারেশন-চালানো#(Write concise update logic with Immer) - Immer এর সাহায্যে খুব সহজে Array অপারেশন চালানো।":"আমরা যদি মিউটেশন নিয়ে এতো টেনশন না করতে চাই,তাহলে আমরা Immer ব্যাবহার করে খুব সহজেই আমাদের সকল ধরনের Array অপারেশন করতে পারি। Immer কিভাবে ব্যাবহার করতে হয় তা স্টেপ বাই স্টেপ জানতে এখানে ক্লিক করুন","ecma-script-2023-es-2023-এর-চারটি-স্পেশাল-array-মেথডঃ#ECMA SCRIPT 2023 (ES-2023) এর চারটি স্পেশাল Array মেথডঃ":"ECMA SCRIPT 2023 (ES-2023) এর চারটি স্পেশাল Array মেথড দিয়ে আমরা খুব সহজেই মেইন Arrayকে Mutatateনা করেই বিভিন্ন Arrayঅপারেশন চালাতে পারি।\ntoSpliced()\ntoReversed()\ntoSorted()\nwith()","tospliced-মেথডঃ#toSpliced() মেথডঃ":"Array.prototype.toSpliced() মেথডের মাধ্যমে Array এর যেকোন পজিশনে যেকোন আইটেম এড করতে পারি বা ডিলিট করতে পারি। এবং এটা মেইন Arrayতে হাত দেয়না। উদাহরনঃsplice() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করে।\nconst arr = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconst arr2 = arr.splice(2, 3, \"x\", \"y\");\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"b\", \"x\", \"y\"]; // মেইন Array পরিবর্তন হয়ে গেছে\n[\"c\", \"d\", \"e\"];\ntoSpliced() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করেনা।\nconst arr = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconst arr2 = arr.toSpliced(2, 3, \"x\", \"y\");\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"b\", \"c\", \"d\", \"e\"]; // মেইন Array অপরিবর্তিত রয়েছে।\n[\"a\", \"b\", \"x\", \"y\"]; // নতুন Array রিটার্ন হয়েছে","toreversed-মেথডঃ#toReversed() মেথডঃ":"Array.prototype.toReversed() মেথডের মাধ্যমে Arrayকে রিভার্স করা যায়, এতে মেইন Array অপরিবর্তিত থাকে।reverse() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করে।\nconst arr = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconst arr2 = arr.reverse();\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"e\", \"d\", \"c\", \"b\", \"a\"]; // মেইন Array পরিবর্তন হয়ে গেছে\n[\"e\", \"d\", \"c\", \"b\", \"a\"];\ntoReversed() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করেনা।\nconst arr = [\"a\", \"b\", \"c\", \"d\", \"e\"];\nconst arr2 = arr.toReversed();\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"b\", \"c\", \"d\", \"e\"]; // মেইন Array অপরিবর্তিত রয়েছে।\n[\"e\", \"d\", \"c\", \"b\", \"a\"]; // নতুন Array রিটার্ন হয়েছে","tosorted-মেথডঃ#toSorted() মেথডঃ":"Array.prototype.toSorted() মেইন Array কে পরিবর্তন না করে Array কে sort করার জন্য ব্যাবহার করা যায়।sort() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করে।\nconst arr = [\"a\", \"d\", \"c\", \"f\", \"e\"];\nconst arr2 = arr.sort();\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"c\", \"d\", \"e\", \"f\"]; // মেইন Array পরিবর্তন হয়ে গেছে\n[\"a\", \"c\", \"d\", \"e\", \"f\"];\ntoSorted() ব্যাবহার করে উদাহরণ যা মেইন Array কে পরিবর্তন করেনা।\nconst arr = [\"a\", \"d\", \"c\", \"f\", \"e\"];\nconst arr2 = arr.toSorted();\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"d\", \"c\", \"f\", \"e\"]; // মেইন Array অপরিবর্তিত রয়েছে।\n[\"a\", \"c\", \"d\", \"e\", \"f\"]; // নতুন Array রিটার্ন হয়েছে","with-মেথডঃ#with() মেথডঃ":"Array.prototype.with() মেথডের মাধ্যমে Arrayর নির্দিষ্ট পজিশনে কোন ভ্যালুকে অন্য একটি ভ্যালু দিয়ে পরিবর্তন করে নতুন Array রিটার্ন করে।উদাহরণঃ\nconst arr = [\"a\", \"d\", \"c\", \"f\", \"e\"];\nconst arr2 = arr.with(1, \"b\");\nconsole.log(arr);\nconsole.log(arr2);\n//Output:\n[\"a\", \"d\", \"c\", \"f\", \"e\"]; // মেইন Array অপরিবর্তিত রয়েছে।\n[\"a\", \"b\", \"c\", \"f\", \"e\"]; // নতুন Array রিটার্ন হয়েছে"}},"/reactive-accilarator/React-js/module-2/updating-object-in-state":{"title":"Updating Object in State","data":{"":"রিয়াক্টে যেকোন ধরনের জাভাস্ক্রিপ্ট ভ্যালুকে তার স্টেট হিসেবে নিতে পারে। কিন্তু যখনি আমরা রিয়াক্টের স্টেট হিসেবে কোন জাভাস্ক্রিপ্ট অবজেক্ট ব্যাবহার করবো তা কখনওই আমরা সরাসরি চেঞ্জ করতে পারবোনা বা মিউটেড করতে পারবোনা। এক্ষেত্র আমাদেরকে সম্পূর্ন নতুন অবজেক্ট দিয়ে আগের অবজেক্টকে রিপ্লেস করে দিতে হবে, নাহলে আগের অবজেক্ট থেকে একটা কপি বানিয়ে সেই কপি অবজেক্ট দিয়ে আগের স্টেট এর অবজেক্ট কে রিপ্লেস করে দিতে হবে। অর্থাৎ যেভাবেই করি আমাদেরকে সবসময় স্টেট আপডেট করার সময় নতুন ভ্যালু দিয়ে আগের ভ্যালু রিপ্লেস করে দিতে হবে।","what-is-a-mutation-মিউটেশন-কি-#(What is a Mutation) মিউটেশন কি ?":"মিউটেশন মানে হলো পরিবর্তন করা । জাভাস্ক্রিপ্টের ভাষায় কোন ভেরিয়েবল এর ভ্যালুকে সরাসরি পরিবর্তন করে ফেলাকে মিউটেশন বলা হয়। রিয়াক্ট স্টেটের ভ্যালুকে সরাসরি পরিবর্তন করাকে নিরুৎসাহিত করে। রিয়াক্টে স্টেট হিসেবে যেকোন ভ্যালু স্টোর করা যায় যেমনঃ string ,number,Boolean,Array ,Object।string ,number,Boolean হলো জাভাস্ক্রিপ্টের প্রিমিটিভ ভ্যালু যা read-only বা কখনো এগুলো পরিবর্তন করা যায়না।অন্যদিকে Array ,Object হলো রেফারেন্স ভ্যালু। যা টেকনিক্যালি পরিবর্তন করা গেলেও রিয়াক্ট স্টেট-এর ভ্যালুতে সরাসরি রেফারেন্স ভ্যালুকে পরিবর্তন করতে নিষেধ করে। রিয়াক্টে স্টেট আপডেটের ক্ষেত্রে এসব ভ্যালুকেও read-only হিসেবে চিন্তা করতে বলে ।জাভাস্ক্রিপ্ট এর প্রিমিটিভ ও রেফারেন্স ভ্যালু সম্পর্কে আরও বিস্তারিত জানতে চাইলে এখানে ক্লিক করুনচলুন একটু উদাহরণের মাধ্যমে বিস্তারিত বুঝিঃ\nconst [x, setX] = useState(0);\nএখানে স্টেট ভ্যারিএবল x এর ভ্যালু হিসেবে 0 রাখা হয়েছে, 0 হলো একটি প্রিমিটিভ ভ্যালু।\nsetX(5);\nএখানে setX করে স্টেট ভ্যারিএবল x এর ভ্যালু 5 করা হয়েছে । এখানে x এর ভ্যালু 0 কে কিন্তু চেঞ্জ করা হয়নি,কেননা এটা হলো একটা প্রিমটিভ ভ্যালু যা কখনো চেঞ্জ করা যায়না বা read-only বরং 5 যা একটি নতুন ভ্যালু, তা দিয়ে আগের ভ্যালুকে রিপ্লেস করা হয়েছে ।কিন্তু যখন আমাদের স্টেট এর ভ্যালু এমন অবজেক্ট হবে,\nconst [position, setPosition] = useState({ x: 0, y: 0 });\nযদিও এটা টেকনিকালি position.x = 5; এভাবে পরিবর্তন করা সম্ভব কিন্তু এটা করলে তা মেইন অবজেক্ট কে মিউটেড করা হয়। যা রিয়াক্ট কখনওই রিকমেন্ড করেনা। আপনাকে অবশ্যই স্টেট চেঞ্জ করার সময় সম্পুর্ন নতুন ভ্যালু বা নতুন অবজেক্ট দিয়ে আগের ভ্যালুকে রিপ্লেস করে দিতে হবে।তাহলে কিভাবে করবো চলুন জেনে নেই।","treat-state-as-read-only-রিয়াক্টের-স্টেটকে-read-only-চিন্তা-করতে-হবে#(Treat state as read-only) রিয়াক্টের স্টেটকে read-only চিন্তা করতে হবে।":"import { useState } from \"react\";\nexport default function MovingDot() {\n    const [position, setPosition] = useState({\n        x: 0,\n        y: 0,\n    });\n    return (\n        <div\n            onPointerMove={(e) => {\n                position.x = e.clientX;\n                position.y = e.clientY;\n            }}\n            style={{\n                position: \"relative\",\n                width: \"100vw\",\n                height: \"100vh\",\n            }}>\n            <div\n                style={{\n                    position: \"absolute\",\n                    backgroundColor: \"red\",\n                    borderRadius: \"50%\",\n                    transform: `translate(${position.x}px, ${position.y}px)`,\n                    left: -10,\n                    top: -10,\n                    width: 20,\n                    height: 20,\n                }}\n            />\n        </div>\n    );\n}\nউপরের কোড এ একটা পয়েন্টার বানানো হয়েছে যা মাউস মুভ করার সাথে সাথে মাউসকে ফলো করে মুভ করার কথা। কিন্তু কোডটা রান করলে দেখা যাবে কোডটা কাজ করছেনা।কাজ করছেনা কারণ কোডের এই অংশে একটু ভুল আছে।\n    onPointerMove={e => {\n      position.x = e.clientX;\n      position.y = e.clientY;\n    }}\nএখানে onPointerMove event listener এ স্টেট ভ্যারিয়েবল position এর ভ্যালু একবার স্ক্রিনে রেন্ডার হয়ে যাওয়ার পর আবার সেই ভ্যালুকেই সরাসরি পরিবর্তন করা হয়েছে, এজন্যই কাজ করছেনা। কেননা চেঞ্জটা কোন setter function এ করা হচ্ছেনা, তাই রিয়েক্ট জানতেই পারছেনা যে স্টেট এর ভ্যালু চেঞ্জ হয়েছে এবং তাকে রি-রেন্ডার করতে হবে।এক্ষেত্রে এটা চেঞ্জ করতে হলে setter function এর ভিতরে চেঞ্জ করতে হবে যাতে ভ্যালু চেঞ্জ হলেই রি-রেন্ডার ট্রিগার হয়ে যায়।\nonPointerMove((e) => {\n    setPosition({\n        x: e.clientX,\n        y: e.clientY,\n    });\n});\nখেয়াল করে দেখেন, এখানে কিন্তু আগের position অবজেক্ট এর কোন ভ্যালুকে চেঞ্জ করা হয়নি,সম্পুর্ন নতুন একটা অবজেক্ট বানিয়ে আগের অবজেক্ট কে রিপ্লেস করে দেয়া হয়েছে।\nলোকাল মিউটেশন হলে সেটা ঠিক আছে।এভাবে কোড করা যাবেনা,যা স্টেটের বর্তমান অবজেক্ট position কেই সরাসরি চেঞ্জ করে।\nposition.x = e.clientX;\nposition.y = e.clientY;\nকিন্তু যদি এভাবে কোড করি, যাতে আমরা সম্পুর্ন নতুন একটা অবজেক্ট বানিয়ে আগের স্টেট ভ্যালুর অবজেক্ট কে রিপ্লেস করে দেই,তাহলে সেটা সম্পুর্নভাবে ঠিক আছে।\n    setPosition((e)=>{\n        x: e.clientX,\n        y: e.clientY\n    })\nআবার একটা লোকাল অবজেক্ট ভ্যারিয়েবল বানিয়ে সেটা দিয়েও চেঞ্জ করতে পারি, যেমনঃ\nconst nextPosition = {};\nnextPosition.x = e.clientX;\nnextPosition.y = e.clientY;\nsetPosition(nextPosition);\nএভাবে করলেও ঠিক আছে কেননা এখানে স্টেট ভ্যারিএবল এর position অবজেক্ট কে মডিফাই করা হচ্ছেনা, এখানে একটা নতুন অবজেক্ট বানিয়ে স্টেট এর আগের ভ্যালুকে রিপ্লেস করা হচ্ছে।মিউটেশন তখনই প্রব্লেম যখন আপনি কোন স্টেট এর এক্সিস্টীং অবজেক্টে সরাসরি পরিবর্তন করছেন, তা নাহলে আপনি লোকাল ভেরিয়েবল পরিবর্তন করতে পারেন,এতে কোন সমস্যা নাই","copying-objects-with-the-spread-syntax#Copying objects with the spread syntax":"আগের উদাহরণে আমরা যেমন দেখলাম যে যখনি আমরা স্টেট এর অবজেক্ট ভ্যালু পরিবর্তন করবো তখন আমাদের একটা নতুন অবজেক্ট স্টেটে দিতে হবে। তার মানে আমাদের প্রতিবার একটা করে ফ্রেশ অবজেক্ট বানাতে হচ্ছে।কিন্তু আমাদের অবজেক্ট যদি অনেক বড় হয় তাহলে যখনি স্টেট আপডেট করতে চাইবো তখনি যদি এত বড় অবজেক্ট নতুন করে লিখতে যাই তাহলে সেটা একটা সমস্যা এবং এতে ভুল হওয়ার সম্ভাবনা বেশি থাকে।এক্ষেত্রে আমরা আগের অবজেক্ট এর একটা কপি বানিয়ে নিয়ে শুধুমাত্র যেই যেই ভ্যালু পরিবর্তন করতে চাই,সেগুলো পরিবর্তন করে দিলেইতো ঝামেলা শেষ।এই কাজটা করতেই জাভাস্ক্রিপ্ট এর ... spread অপারেটর আমাদের হেল্প করে থাকে। ... spread অপারেটর ব্যাবহার করে আমরা আগের অবজেক্ট এর একটা Shallow কপি বানিয়ে নিতে পারি। তবে মনে রাখতে হবে ... spread অপারেটর নেস্টেড অবজেক্ট এর ক্ষেত্রে শুধুমাত্র এক লেবেল কপি করে। যদি ডিপলি কপি করতে চাই তাহলে ... spread অপারেটর একাধিকবার ব্যাবহার করতে হবে।Shallow Copy এবং Deep Copy সম্পর্কে আরও বিস্তারিত জানতে এই লিঙ্ক এ ক্লিক করুনধরুন আমাদের এই অবজেক্ট স্টেট ভ্যারিয়বলের firstName প্রপার্টির ভ্যালু চেঞ্জ করা লাগবে।\nconst [person, setPerson] = useState({\n    firstName: \"Barbara\",\n    lastName: \"Hepworth\",\n    email: \"bhepworth@sculpture.com\",\n});\nতাহলে আমরা এভাবে করতেই পারিঃ\nsetPerson({\n    firstName: \"Shahadat Hussain Ripon\",\n    lastName: \"Hepworth\",\n    email: \"bhepworth@sculpture.com\",\n});\nএটা খুব ভালোভাবেই কাজ করবে। কিন্তু এতে আমাদের একই জিনিস বার বার লেখা লাগছে,কিন্তু যদি আমরা ...spread অপারেটর ব্যাবহার করি তাহলে আমরা আরও সহজে এভাবে লিখতে পারি।\nsetPerson({\n    ...person, // এখানে আমাদের আগের অবজেক্টের সকল ডাটা কপি হয়ে নতুন অবজেক্ট এর প্রপার্টি হিসেবে বসে গেছে।\n    firstName: \"Shahadat Hussain Ripon\", // এখানে আমরা প্রপার্টির ভ্যালু চেঞ্জ করছি\n});","updating-a-nested-object-কিভাবে-নেস্টেড-অবজেক্টকে-স্টেট-এ-আপডেট-করতে-হয়#(Updating a nested object) কিভাবে নেস্টেড অবজেক্টকে স্টেট এ আপডেট করতে হয়?":"ধরুন আমাদের স্টেট এর স্ট্রাকচার এমনঃ\nconst [person, setPerson] = useState({\n    name: \"Niki de Saint Phalle\",\n    artwork: {\n        title: \"Blue Nana\",\n        city: \"Hamburg\",\n        image: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n    },\n});\nএবং আমরা person.artwork.city এর ভ্যালু আপডেট করতে চাই।তাহলে আমরা এভাবে করতে পারি।\nconst changedArtwork = { ...person.artwork, city: \"Narayangonj\" };\nconst changedPerson = { ...person, artwork: changedArtwork };\nsetPerson(changedPerson);\nঅথবা যদি আমরা একটা সিঙ্গেল ফাংশন কলের ভিতরেই চেঞ্জ করতে চাই, তাহলে এভাবে করতে পারি,\nsetPerson({\n    ...person, // আগের অবজেক্ট এর সমস্ত ফিল্ড কপি করা হয়েছে\n    artwork: {\n        ...person.artwork, // আগের অবজেক্ট এর artwork ফিল্ডের সমস্ত ডাটা কপি করা হয়েছে\n        city: \"Narayangonj\", // প্রপার্টির ভ্যালু পরিবর্তন করা হয়েছে\n    },\n});\nসত্যি হলো যে অবজেক্ট কখনই নেস্টেড নয়।\nlet obj = {\n    name: \"Niki de Saint Phalle\",\n    artwork: {\n        title: \"Blue Nana\",\n        city: \"Hamburg\",\n        image: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n    },\n};\nএই অবজেক্টটাকে এভাবে দেখে মনে হচ্ছে এটা নেস্টেড,কিন্তু সত্যিটা হলো যে যখন আমাদের কোড এক্সিকিউট হবে,তখন আসলে নেস্টেড অবজেক্টের কোন অস্তিত্ব নেই। তখন আসলে এটা দুইটা অবজেক্ট হয়ে যাবে।\nlet obj1 = {\n    title: \"Blue Nana\",\n    city: \"Hamburg\",\n    image: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n};\nlet obj2 = {\n    name: \"Niki de Saint Phalle\",\n    artwork: obj1,\n};\nতারপর হয়তো একটা অবজেক্ট এর রেফারেন্স নিয়ে অন্য আরেকটা অবজেক্ট তৈরি হতে পারে, এভাবেঃ\nlet obj1 = {\n    title: \"Blue Nana\",\n    city: \"Hamburg\",\n    image: \"https://i.imgur.com/Sd1AgUOm.jpg\",\n};\nlet obj2 = {\n    name: \"Niki de Saint Phalle\",\n    artwork: obj1,\n};\nlet obj3 = {\n    name: \"Something\",\n    artwork: obj1,\n};\nএমন অবস্থায় আপনি যদি obj1 এ কোন চেঞ্জ করেন তাহলে রেফারেন্স ভ্যালু হউয়ার কারনে obj3 তে গিয়েও সেই চেঞ্জটা এফেক্ট করবে।","write-concise-update-logic-with-immer-ইমার-এর-মাধ্যমে-নিশ্চিন্তে-নেস্টেড-অবজেক্ট-পরিবর্তন-করা#(Write concise update logic with Immer) ইমার এর মাধ্যমে নিশ্চিন্তে নেস্টেড অবজেক্ট পরিবর্তন করা।":"আমরা স্টেট এর নেস্টেড অবজেক্টগুলোকে খুব সহজে ,কোন কিছু চিন্তা ভাবনা ছাড়াই পরিবর্তন করতে চাইলে রিয়াক্ট একটা থার্ড পার্টি প্যাকেজ রিকমেন্ড করে Immerনামে।আমরা চাইলে Immer ব্যাবহার করেও আমাদের কমপ্লেক্স ন্যাস্টেড অবেজক্ট স্টেট গুলো খুব সহজেই পরিবর্তন করতে পারি।Immer আমাদেরকে draft নামে একটা স্পেশাল অবজেক্ট দেয়,যেটা আগের কমপ্লেক্স অবজেক্ট এর একটা Proxy অবজেক্ট বানিয়ে নেয়, এবং আমরা কি কি পরিবর্তন করি তা সে খুঁজে বের করে, আগের অবজেক্ট কে ইমিউটিভলি আপডেট করে দেয়। এক্ষেত্রে Mutation এর ব্যাপারটা Immerনিজে ম্যানেজ করে বলে আমাদের টেনশন নিতে হয়না।","immer-কিভাবে-ব্যাবহার-করতে-হয়#Immer কিভাবে ব্যাবহার করতে হয়।":"","install-immer-package#install Immer package":"npm install use-immer","import-useimmer#import useImmer":"import { useImmer } from \"use-immer\";","change-usestate-to-useimmer#change useState to useImmer":"useState কে চেঞ্জ করে useImmer হবে\nimport { useImmer } from \"use-immer\";\nconst [person, setPerson] = useState({}); // এই লাইনটিকে চেঞ্জ করতে হবে\nconst [person, updatePerson] = useImmer({}); // এভাবে স্টেট ডিফাইন করতে হবে।","update-state-like-below#Update state like below":"import { useImmer } from \"use-immer\";\nconst [person, updatePerson] = useImmer({\n    firstName: \"Barbara\",\n    lastName: \"Hepworth\",\n    contact: {\n        email: \"bhepworth@sculpture.com\",\n        phone: \"+8801913509868\",\n        github: \"deveripon\",\n    },\n});\nupdateImmer((draft) => {\n    // state updater immer function\n    draft.firstName = \"Shahadat Hussain \";\n    draft.lastName = \"Ripon\";\n    draft.contact.email = \"devripon.io@gmail.com\";\n});\nএভাবে করলে হয়তো মনে হতে পারে আমরা রিয়াক্টের রুলস ব্রেক করছি,কিন্তু না আসলে আমরা এখানে draft কে মিউটেড করলেও, আন্ডার দ্যা হুড, Immer নিজে আমাদের স্টেট টা ইমিউটিভলি আপডেট করছে।"}},"/reactive-accilarator/React-js/module-3/choosing-the-state-structure":{"title":"Choosing the State Structure","data":{"":"রিয়াক্টে স্টেট ডিজাইন করার সময় আমাদের কিছু পিন্সিপাল মনে রাখা অবশ্যই জরুরি,এতে আমরা আরও সুন্দর ও ইফিশিয়েন্ট ভাবে স্টেটগুলো ম্যানেজ করতে পারবো। চলুন জেনে নেয়া যাক সেই প্রিন্সিপালগুলো,যেগুলো রিয়াক্টের স্টেট এর স্ট্রাকচার করার সময় আমাদের অবশ্যই মাথায় রাখতে হবে\nGroup Related State\nAvoid Contradictions in State\nAvoid Redundant State\nAvoid Duplication is State\nAvoid Deeply Nested State","group-related-state-একইজাতীয়-বা-পারস্পারিক-সম্পর্কযুক্ত-স্টেটগুলোকে-একটা-স্টেটে-গ্রুপ-করে-নেয়া#Group Related State (একইজাতীয় বা পারস্পারিক সম্পর্কযুক্ত স্টেটগুলোকে একটা স্টেটে গ্রুপ করে নেয়া)":"যদি এমন হয় যে মাল্টিপল স্টেট কিন্তু একটা আরেকটার সাথে সম্পর্কযুক্ত,এবং একটা চেঞ্জ করলে অন্যটাও চেঞ্জ করার প্রয়োজন পরে সেই ক্ষেত্রে স্টেটগুলোকে একটা স্টেট হিসেবে গ্রুপ করে নেয়া উচিত। যেমন ঃ\nconst [x, setX] = useState(0);\nconst [y, setY] = useState(0);\nএখানে একটা কাস্টম কার্সর বানানোর জন্য x এবং y নামে দুইটা স্টেট নেয়া হয়েছে, এবং মাউসমুভ করার সাথে সাথে স্টেটগুলো আপডেট হতে হবে, তার মানে মাউসমুভ হলেই আমাকে x এবং y দুইটা স্টেট পরিবর্তন করতে হবে। তাহলে আমরা এভাবে দুইটা স্টেট না নিয়ে বরং একটা স্টেট নিতে পারি positionনামে এবং এর ভ্যালু হিসেবে x এবং y কে একটা অবজেক্ট আকারে রাখতে পারি।\nconst [position, setPosition] = useState({ x: 0, y: 0 });","avoid-contradictions-in-state-একই-সাথে-দুইটাই-কখনও-সত্য-অথবা-মিথ্যা-না-হলে-দুইটা-কে-একটা-স্টেট-হিসেবে-নেয়া#Avoid contradictions in state (একই সাথে দুইটাই কখনও সত্য অথবা মিথ্যা না হলে দুইটা কে একটা স্টেট হিসেবে নেয়া)":"এমন অনেক সিনারিও আসতে পারে যেখানে হয়তো দুইটা স্টেট আছে যেখানে হয়তো দুইটা স্টেট আছে,কিন্তু স্টেট দুইটা কখনোই একইসাথে সত্য অথবা একই সাথে মিথ্যা হতে পারেনা। এসব স্টেটকে বলা হয় Contradiction in State। এমন হলে দুইটা স্টেট কখনোই নেয়া উচিত না,বরং একটা স্টেট দিয়েই দুইটাকেই ম্যনেজ করা উচিত।উদাহরণসরূপ একটা লাইটের কথা চিন্তা করুনঃএকটা লাইট আছে, যার দুইটা স্টেট১। লাইট জালানো অবস্থা (isOn)২। লাইট বন্ধ অবস্থা (isOff)\nconst [isOn, setIsOn] = useState(true);\nconst [isOff, setIsOff] = useState(true);\nএখানে এই দুইটা স্টেট কি কখনো একইসাথে দুইটাই true অথবা false হতে পারে? মানে একই সাথে লাইট জালানো বা বন্ধ করা থাকতে পারে ? না সেটা কখনই হতে পারেনা, এটাকেই বলা হয় Contradiction in State। এমন অবস্থায় আমাদের একটাই স্টেট নেয়া উচিত যেমনঃ\nconst [lightStatus, setLigthStatus] = useState(\"on\");\nএভাবে আমরা একটা স্টেট দিয়েই লাইটের দুইটা অবস্থা ম্যানেজ করতে পারি।","avoid-redundant-state-অপ্রয়োজনীয়-স্টেট-না-নেয়া-বা-পরিহার-করা#Avoid redundant state (অপ্রয়োজনীয় স্টেট না নেয়া বা পরিহার করা)":"যদি আমরা কোন স্টেটকে অন্য স্টেট থেকে কেলকুলেট করে নিয়ে ব্যাভারা করতে পারি তাহলে আমাদের নতুন স্টেট না নিয়ে সেই কেলকুলেটেড স্টেট দিয়েই কাজ করা উচিত।এটাকে Derived Stateও বলা হয়ে থাকে\nDerived State: যখন কোন ভ্যালু অন্য কোন স্টেট এর ভ্যালু থেকে calculate করে ব্যাবহার করা যায়, তখন সেই Calculated ভ্যারিয়েবল কে Derived State বলা হয়\nধরুন আমাদের এমন তিনটা স্টেট ম্যানেজ করা লাগবে,firstName, lastName, fullName। এখেত্রে আমদের স্টেট গুলো হবে এমন,\nconst [firstName, setFirstName] = useState(\"Shahadat\");\nconst [lastName, setLastName] = useState(\"Hussain\");\nconst [fullName, setFullName] = useState(\"Shahadat Hussain\");\nচিন্তা করে দেখেনতো, এখানে কি আমাদের fullName স্টেট-এর কোন দরকার ছিল? আমরা চাইলেইতো firstName,এবং lastName থেকে fullName টা বানিয়ে নিতে পারতাম এভাবে,\nconst fullName = firstName + \" \" + lastName;\nএক্ষেত্রে\nconst [fullName, setFullName] = useState(\"Shahadat Hussain\");\nএই স্টেট টা ছিল Redundant বা অপ্রয়োজনীয়। আমাদের এসব Redundant স্টেটকে Avoid করতে হবে।","dont-mirror-props-in-state-প্রপ্স-মিরর-করা-এড়িয়ে-চলতে-হবে#Don't mirror props in state (প্রপ্স মিরর করা এড়িয়ে চলতে হবে)":"একটা স্টেটকে যখন প্যারেন্ট কম্পোনেন্ট এ ডিক্লেয়ার করে সেটার ভ্যালুটা চাইল্ড কম্পোনেন্টে পাস করা হয়, এবং চাইল্ড কম্পোনেন্ট সেই প্রপ্সটা নিয়ে আবার তার নিজস্ব স্টেট এর ভ্যালুকে ইনিশিয়ালাইজ করে,সেটা কে বলা হয় প্রপ্স মিরর করা।এটা করা যাবেনা, কেননা যদি আপনি একবার কোন স্টেট ভ্যালু প্যারেন্ট থেকে চাইল্ডে পাস করেছেন এবং সেটা চাইল্ডের নিজস্ব স্টেট ভ্যরিয়েবল এর ইনিশিয়াল ভ্যালু হিসেবে ব্যাবহার করেছেন,তখন যদি আপনি চাইল্ড কম্পোনেন্ট থেকে স্টেট ভ্যালু চেঞ্জ করেত চান,তখন চাইল্ড থেকে সেটা পরিবর্তন করতে পারলেও, যদি প্যারেন্ট থেকে সেট স্টেট যেটা আপনি প্রপ্স হিসেবে চাইল্ডে পাঠিয়েছেন,সেটার কোন কন্ট্রোল থাকবেনা,এবং প্যারেন্ট থেকে তা পরিবর্তন করা যাবেনা। কেননা স্টেট এর ইনিশিয়াল ভ্যালু কম্পোনেন্টের প্রথম রেন্ডারেই ইনিশিয়ালাইজ হয়, পরে আর ইনিশিয়াল ভ্যালু চেঞ্জ হয়না। শুধু setter function এর মাধ্যমেই সেই স্টেট এর ভ্যালু চেঞ্জ করা যায়।তাই এখেত্রে প্যারেন্ট কম্পোনেন্টে সেই স্টেটটা পরিবর্তন করলেও তা কিন্তু প্রপ্স হয়ে আর চাইল্ড কম্পোনেন্টে যাবেনা, কেননা প্রথম রেন্ডারেই চাইল্ডের স্টেটের ইনিশিয়াল ভ্যালু সেট হয়ে গেছে।","avoid-duplication-in-state-ডুপ্লিকেট-স্টেট-নেয়া-যাবেনা#Avoid duplication in state (ডুপ্লিকেট স্টেট নেয়া যাবেনা)":"একি ভ্যালু যদি মাল্টিপল স্টেট ভ্যারিয়েবল ব্যাবহার করে সেটাকে ডুপ্লিকেট করা বলে। আমাদের এসব ডুপ্লিকেট স্টেট এর ব্যাপারে সতর্ক থাকতে হবে।অর্থাৎ যদি এমন হয় যে আমাদের কোন স্টেট ভ্যারিয়েবল এ কিছু ভ্যালু আছে,এবং সেই একই ভ্যালু দিয়ে আমরা আরও একটা স্টেট নিয়েছি, সেটাকে ডুপ্লিকেট করা বলা হয়, স্টেট ডুপ্লিকেট করা যাবেনা,প্রয়োজনে এক্ষেত্রে Derived State ব্যাবহার করতে হবে।","avoid-deeply-nested-state-ডিপলি-নেস্টেড-অবজেক্ট-কে-স্টেট-হিসেবে-নেয়া-থেকে-বিরত-থাকতে-হবে#Avoid deeply nested state (ডিপলি নেস্টেড অবজেক্ট কে স্টেট হিসেবে নেয়া থেকে বিরত থাকতে হবে)":"যদি এমন হয় যে আমাদের এমন একটা স্টেট আছে যা একটা অবজেক্ট এবং তার প্রপারর্টি হিসেবে আরও একটা অবজেক্ট আছে, এবং সেই নেস্টেড অবজেক্ট এর-ও আরও নেস্টেড অনেক অবঞ্জেক্ট আছে, এভাবে অনেক লেয়ার ডীপ একটা নেশটেড অবজেক্ট । যা একটা কমপ্লেক্স স্ট্রাকচার।এমন স্ট্রাকচার নিয়ে কাজ করলে স্টেট আপডেট করতে হলে সেটা কোডের কপ্লেক্সিটি বাড়াবে,বাগ হতে পারে, কোডটার রিডেবিলিটি নষ্ট হবে। তাই এমন অবজেক্টকে স্টেট হিসেবে নেয়া পরিহার করতে হবে।সেক্ষেত্রে সেই অবজেক্ট ডাটাকে normalize বা flatten করে নিয়ে তারপর স্টেট হিসেবে ব্যাবহার করতে হবে।"}},"/reactive-accilarator/React-js/module-3/extracting-state-logic-into-reducer":{"title":"Extracting State Logic into Reducer","data":{"extracting-state-logic-into-a-reducer#Extracting State Logic into a Reducer":"এই লেসনে আমরা সর্বপ্রথম useReducer হুকটা নিয়ে কথা বলছি, useReducer হুকটা হলো রিয়াক্টের অনেকগুলো হুকের মধ্যে একটি আমাদের কমপ্লেক্স স্টেট ম্যানেজমেন্টকে এফিসিয়েন্টভাবে হ্যন্ডেল করতে সাহায্য করে।চলুন সবার প্রথমে useReducer হুকটা কি,কিভাবে কাজ করে এটা জেনে নেই, পরে জানবো কিভাবে এটা কোডে ব্যাবহার করতে পারি।","introduction-of-usereducer-hook#Introduction of useReducer Hook":"useReducer হলো রিয়াক্ট এর একটি হুক যা জাভাস্ক্রিপ্ট এর Array.reducer() মেথড টা ইউজ করে বানানো হয়েছে । useReducer হুকটিও আমাদের রিয়াক্টের স্টেট ম্যনেজমেন্ট করতে হেল্প করে।আমরা এতদিন স্টেট ম্যানেজমেন্ট করার জন্য যেই useState হুক ব্যাবহার করতাম সেটি মূলত এই useReducer হুকের উপর বেইসড করেই বানানো হয়েছে।তাহলে প্রশ্ন হলো কখন আমরা কোনটা ব্যাবহার করবো? - সে বিষয়ে আমরা বিস্তারিত জানবো, তবে এখন শুধু এটা মাথায় রাখতে হবে যে রিয়াক্টের কমপ্লেক্স স্টেট ম্যানেজমেন্ট করার জন্য useReducer হুকটি ব্যাবহার করা হয়।","syntax-of-usereducer-hook#Syntax of useReducer Hook":"const [updatedStateFullValue, dispatch] = useReducer(reducerFunc, initialState);","anatomy-of-usereducer-hook#Anatomy of useReducer Hook":"useReducer হুকটি দুইটা আর্গুমেন্ট নেয়,\nReducer Function: এই ফাংশনটির মাধ্যমে আমাদের স্টেট চেঞ্জ এর সমস্ত বিজনেস লজিকগুলো ম্যানেজ করা হয়ে থাকে। এটা প্যারামিটার হিসেবে দুইটা জিনিস নেয়,\nstate: এটা আমাদের স্টেট এর যেই ভ্যালু তা রিটার্ন করে, যাতে আমরা reducer function এর ভিতরে আমাদের স্টেট গুলো ম্যানেজ করতে পারি।\naction: এটার ভিতরে মূলত থাকে আমাদের একশন, আমরা কোন একশনের ভিত্তিতে স্টেট এ কি করতে চাচ্ছি, সেই একশনটা এই action প্যারামিটারের ভিতর পাই, এখানে আমরা চাইলে অবজেক্ট আকারে মাল্টিপল জিনিস এক্সেস করতে পারি।\nInitial State: এইটা হলো আমাদের স্টেট এর যেই ইনিশিয়াল ভ্যালু।\nএবং একটা টুপল রিটার্ন করে,সেই টুপলে দুইটা জিনিস থাকে,\nUpdated stateful value: আমাদের রিডিউসার ফাংশন স্টেটকে আপডেট বা মডিফাই করে যেই Updated stateful value রিটার্ন করে, সেটা এটার ভিতর থাকে যা আমরা UI তে রেন্ডার করাতে পারি।\nDispatch Method: যেসব একশন অনুযায়ী reducer function স্টেট ম্যানেজ করবে সেই সব একশন reducer function এর কাছে পাঠানোর জন্য এর Dispatch Method ব্যাবহার হয়।","how-to-use-usereducer-hook#How to use useReducer Hook?":"আমরা তিনটা স্টেপ ফলো করে useReducer ব্যাবহার করতে পারি। চলুন উদাহরনের মাধ্যমে আমরা একটা Counter বানাই আর বুঝি কিভাবে useReducer ব্যবাহার করতে পারি।উদাহরনে আমারা নিচের এই JSX টা ব্যবাহার করবো।\n        export default function App(){\n            return (\n           <div>\n              <h1> Count : 0</h1>\n              <button>Increment</button>\n              <button>Decrement</button>\n          </div>\n            )\n        }\nএখানে App.jsx এ একটা কাউন্টার বানানো হয়েছে যেটাতে দুইটা বাটন আছে যার একটায় চাপ দিলে কাউন্টারের ভ্যালু increment হবে এবং অন্যটায় চাপ দিলে decrement হবে। চলুন তাহলে এই ফাংশনালিটি আমরা useReducer ব্যাবহার করে বানাই।","create-a-reducer-function-and-to-manage-state-changing-logic#create a reducer function and to manage state changing logic":"প্রথমে একটা reducer function বানাতে হবে এবং যেখানে আমরা আমাদের সমস্ত লজিক লিখবো যে বাটনের কোন একশনে আমরা স্টেট কিভাবে পরিবর্তন করবো।\nচলুন সেটা বানাই,\nconst counterReducer = (state, action) => {\n    switch (action.type) {\n        case \"INCREMENT\": {\n            return state + 1;\n        }\n        case \"DECREMENT\": {\n            return state - 1;\n        }\n        default: {\n            return state;\n        }\n    }\n};\nএখানে আমরা counterReducer নামে একটা reducer function নিয়েছি এবং তাতে আমরা action.type (action.type কি হবে তা আমরা পরে বাটন থেকে dispatch করবো) এর উপর ভিত্তি করে switch-case দিয়ে স্টেটকে পরিবর্তন করছি। এখানে আমরা চাইলে if-elseও ব্যাবহার করতে পারতাম।","add-usereducer-to-component#Add useReducer to Component":"তারপর যেখানে আমরা স্টেট ম্যানেজ করতে চাই,(এক্ষেত্রে আমারা App কম্পোনেন্টে ব্যবাহার করছি) সেখানে useReducer হুকটাকে ইম্পোর্ট করে ডিফাইন করা লাগবে। এবং Count এর ভ্যালু ডাইনামিকভাবে useReducer হুক থেকে নিয়ে ব্যাবহার করতে হবে।\nimport { useReducer } from \"react\";\nconst initialState = 0;\nexport default function App() {\n    const [count, dispatch] = useReducer(counterReducer, initialState);\n    return (\n        <div>\n            <h1> Count : {count}</h1>\n            <button>Increment</button>\n            <button>Decrement</button>\n        </div>\n    );\n}\nতারপর useReducer এর আর্গুমেন্ট হিসেবে reducer function এবং initialState দিতে হবে। reducer function যেই আপডেটেড স্টেটটা রিটার্ন করে সেটা আমরা যেকোন নামে ধরতে পারি, কিন্তু যেহেতু আমরা কাউন্টারের স্টেট মেনেজ করছি তাই আমরা এটাকে count নামে ধরেছি","call-dispatch-method-on-event-handlers-and-connect-the-event-handlers#call dispatch method on Event handlers and connect the event handlers":"এখন আমদের শুধু একশন গুলো dispatch করা বাকি। আমরা বাটনের onClick এ যেসব ইভেন্ট হ্যান্ডেলার এড করবো সেখানে dispatch মেথড কল করবো এবং আমরা যে একশন dispatch করতে চাই সেটা একটা অবজেক্ট আকারে পাঠিয়ে দিব reducer function এর কাছে। তবে আমরা চাইলে এটা ইভেন্ট হ্যন্ডেলারের মদ্ধ্যে কল না করে সরারসরি বাটনের onClick এ কল করে দিতে পারতাম।\nimport { useReducer } from \"react\";\nconst initialState = 0;\nexport default function App() {\n    const [count, dispatch] = useReducer(counterReducer, initialState);\n    //increment handler\n    function handleIncrementClick() {\n        return dispatch({\n            type: \"INCREMENT\",\n        });\n    }\n    //decrement handler\n    function handleDecrementClick() {\n        return dispatch({\n            type: \"DECREMENT\",\n        });\n    }\n    return (\n        <div>\n            <h1> Count : {count}</h1>\n            <button onClick={handleIncrementClick}>Increment</button>\n            <button onClick={handleDecrementClick}>Decrement</button>\n        </div>\n    );\n}\nব্যাস, এই তিনটা স্টেপ ঠিকঠাক ভাবে করলেই দেখবেন আমাদের হুক কাজ করছে।","comparing-usestate-and-usereducer#Comparing useState and useReducer":"রিয়াক্ট নিজেই তার ডকুমেন্টেশনে বলেছে যে, useReducer হুকেরও কিছু ডাউনসাইড রয়েছে, এটা এমন নয় যে আমরা সবসময় শুধু useReducerই ব্যাবহার করবো, আমরা প্রয়োজন অনুযায়ী useState এবং useReducer দুইটাই ব্যবাহার করবো। তবে একটা আরেকটার সাথে তুলনা করলে কিছু পার্থক্য বুঝা যায়,সেগুলো হলোঃ\nকোডের সাইজঃ useState ব্যবহার করলে useReducer এর চাইতে তুলনামূলক কম কোড লেখা লাগে, কিন্তু যখন এপ্লিকেশন অনেক বড় হবে এবং অনেক অনেক স্টেট ম্যনেজ করা লাগবে তখন কিন্তু আবার useState সেই একই ধরেনের স্টেট এর কাজগুলোকে আলাদা করে কোডকে ম্যানেজেবল করতে সাহায্য করে থাকে।\nকোড রিডেবিলিটিঃ useState ব্যবহার করলে যখন প্রজেক্ট ছোট থাকে তখন কোডের রিডেবিলিটি ভালো থাকে কিন্তু যখনি প্রজেক্ট বড় হতে থাকে সেই সাথে কোডের রিডেবিলিটিও নষ্ট হতে থাকে, এক্ষেত্রে reducer কোডের বিজনেস লজিকগুলোকে আলাদা করে ফেলে বলে কোডের রিডেবিলিটি ঠিক থাকে।\nডীবাগীংঃ useState ব্যাবহার করলে কোড ডীবাগ করাটা কঠিন হয়ে যায়, কেননা কোথায় কোথায় setter function কল হয়েছে তা খুঁজে বের করে ডীবাগ করাটা বেশ কঠিন, কিন্তু useReducer এর ক্ষেত্রে সমস্ত বিজনেস লজিকগুলো একটা জায়গায় ম্যানেজ হয় বলে এক্ষেত্রে ডীবাগ করা সহজ হয়ে যায়।\nটেস্টিংঃ reducer ফাংশনগুলোকে পিওর ফাংশন হতে হয়, তাই পিওর ফাংশন হউয়ার কারনে চাইলেই যেকোন সময় ফাংশন গুলোকে নিয়ে আলাদা এনভাইরনমেন্টেও সহজে টেস্টিং করা যায়।\nব্যাক্তিগত পছন্দঃ অনেকেই useReducer খুব পছন্দ করে,আবার কেউ কেউ useReducer ব্যাভার-ই করেনা। এটা একটা ব্যাক্তিগত পছন্দের ব্যাপার, তবে আমাদের শুধু useState বা শুধু useReducerই ব্যাবহার না করে আমরা দুইটাকে মিলিয়ে ব্যবাহার করবো, আমাদের যখন যে জায়গায় যেটার প্রয়োজন মনে হবে,আমরা সেটাই ব্যাবহার করবো","when-should-use-usereducer#When should use useReducer?":"আমরা আমাদের প্রয়োজন অনুযায়ী যখন যেটা প্রয়োজন হবে তখন সেটাই ব্যাবহার করবো, যখন আমাদের স্টেট লজিকগুলো কমপ্লেক্স হবে তখন আমরা useReducer ব্যাবহার করবো, আবার যখন আমাদের সিম্পল লোকাল স্টেট ম্যানেজ করা লাগবে তখন আমরা useState ব্যাবহার করতে পারি।চলুন একটু দেখে নেই কখন কোনটা ব্যাবহার করা উচিত।\nযখন\tuseState\tuseReducer\tState চেঞ্জ এর সংখ্যা\tসর্বোচ্চ তিনটা হবে\tঅনেক হবে\tএকাধিক state change যদি related হয়\tনা\tহ্যাঁ\tstate এর ডাটা টাইপ যদি\tString,Number,Boolean হয়\tObject,Array হয়\tযদি কমপ্লেক্স লজিক থাকে\tনা\tহ্যাঁ\tযদি state এর scope\tLocal হয়\tGlobal হয়"}},"/reactive-accilarator/React-js/module-3/declaretive-imperative":{"title":"Declaretive Imperative","data":{"":"ডিক্লারেটিভ (Declarative) এবং ইম্পারেটিভ (Imperative) প্রোগ্রামিং এপ্রোচ দুটি প্রোগ্রামিং করার ভিন্ন ভিন্ন পদ্ধতি। আসুন, প্রথমে প্রতিটি এপ্রোচের মূল ধারণা বুঝি, তারপরে কোডের উদাহরণ দেখি।","১-ইম্পারেটিভ-imperative-এপ্রোচ#১. ইম্পারেটিভ (Imperative) এপ্রোচ:":"ইম্পারেটিভ প্রোগ্রামিংয়ে আপনি কীভাবে কিছু করবেন তা ধাপে ধাপে বলে দেন। আপনি প্রতিটি পদক্ষেপ নির্দিষ্টভাবে বর্ণনা করেন এবং কম্পিউটার সেই পদক্ষেপগুলি ঠিকমতো অনুসরণ করে। এটি অনেকটা রান্নার রেসিপির মতো, যেখানে প্রতিটি ধাপ স্টেপ বাই স্টেপ বলে দেয়া থাকে।","উদাহরণ#উদাহরণ:":"ধরুন, আমাদের একটি অ্যারের উপাদানগুলিকে ২ দিয়ে গুণ করতে হবে।\n// Imperative approach\nconst numbers = [1, 2, 3, 4, 5];\nconst doubledNumbers = [];\nfor (let i = 0; i < numbers.length; i++) {\n    doubledNumbers.push(numbers[i] * 2);\n}\nconsole.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]\nএখানে আমরা একটি লুপ দিয়ে প্রতিটি উপাদানকে ২ দিয়ে গুণ করে নতুন অ্যারেতে পুশ করছি। প্রতিটি পদক্ষেপ যেমনঃ\nলুপিং,\nগুণ,\nপুশ\nস্পষ্টভাবে বলে দেয়া হয়েছে।","২-ডিক্লারেটিভ-declarative-এপ্রোচ#২. ডিক্লারেটিভ (Declarative) এপ্রোচ:":"ডিক্লারেটিভ প্রোগ্রামিংয়ে আপনি কী করতে চান সেটি বলেন, তবে কীভাবে করবেন তা নির্দিষ্টভাবে উল্লেখ করেন না। কম্পিউটারকে নির্দিষ্টভাবে প্রতিটা স্টেপ বলে দিতে হয় না।এই এপ্রোচে আপনি মূলত কী চান শুধু তা বলে দেন, আর ভেতরের ইম্প্লিমেন্টেশন কম্পিউটার নিজেই বোঝে নেয় ।","উদাহরণ-1#উদাহরণ:":"উপরে যে একই কাজ করলাম, এবার ডিক্লারেটিভ এপ্রোচে করবো:\n// Declarative approach\nconst numbers = [1, 2, 3, 4, 5];\nconst doubledNumbers = numbers.map((num) => num * 2);\nconsole.log(doubledNumbers); // Output: [2, 4, 6, 8, 10]\nএখানে .map() ফাংশন ব্যবহার করেছি, যা প্রত্যেকটি উপাদানকে ২ দিয়ে গুণ করছে এবং নতুন অ্যারে তৈরি করছে। তবে, কোন লুপের উল্লেখ নেই—অ্যারের উপরে কাজ করতে কীভাবে গুণ করতে হবে, তা সরাসরি বলিনি। শুধু বলেছি, \"প্রতিটি উপাদানকে ২ দিয়ে গুণ করো\"।","প্রধান-পার্থক্য#প্রধান পার্থক্য:":"ইম্পারেটিভ: প্রতিটি ধাপ স্টেপ বাই স্টেপ বলে দিতে হয়,কীভাবে কাজটি সম্পন্ন হবে তা নির্দিষ্টভাবে উল্লেখ করতে হয়।\nডিক্লারেটিভ: শুধু কী করতে হবে তা বলে দিতে হয়, আর কীভাবে করতে হবে তা গোপন থাকে বা কম্পিউটার নিজেই বুঝে নেয়।","রিয়াক্ট-কি-এপ্রোচে-তার-ইউ-আই-চেঞ্জ-করে#রিয়াক্ট কি এপ্রোচে তার ইউ আই চেঞ্জ করে?":"React মূলত ডিক্লারেটিভ (Declarative) এপ্রোচে তার UI পরিবর্তন করে। এর অর্থ হলো, React-এ আপনি কীভাবে UI আপডেট হবে তা নিয়ে চিন্তা করার পরিবর্তে, UI-র বর্তমান অবস্থা কেমন হবে তা বর্ণনা করেন, আর React নিজেই সেই UI-টি আপডেট করার জন্য ভেতরে ভেতরে প্রয়োজনীয় কাজ করে নেয়।","react-এর-ডিক্লারেটিভ-এপ্রোচ-কীভাবে-কাজ-করে#React-এর ডিক্লারেটিভ এপ্রোচ কীভাবে কাজ করে?":"Declarative Components: React-এ আপনি প্রতিটি UI অংশ (component) তৈরি করার সময়, প্রতিটি কম্পোনেন্টকে বলে দেন কীভাবে সেটা দেখতে হবে। আপনি UI এর শেষ অবস্থা (final state) বলে দেন, কিন্তু সেই অবস্থা কীভাবে পরিবর্তন হবে তা নির্দিষ্টভাবে বলে দিতে হয় না।উদাহরণ:\nfunction Greeting({ name }) {\n    return <h1>Hello, {name}!</h1>;\n}\nএখানে আমরা শুধু বলে দিচ্ছি, \"এই component-টি কেমন দেখতে হবে,\" কিন্তু কীভাবে render হবে বা কতবার হবে তা চিন্তা করতে হচ্ছে না। React সেই কাজগুলো নিজের মতো করে করে নিচ্ছে।\nState Changes: React-এর ডিক্লারেটিভ এপ্রোচের আরেকটি গুরুত্বপূর্ণ বিষয় হলো state। আপনি যখন কোনো state পরিবর্তন করেন, React সেই state অনুযায়ী UI-কে আপডেট করে।উদাহরণ:\nimport React, { useState } from \"react\";\nfunction Counter() {\n    const [count, setCount] = useState(0);\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={() => setCount(count + 1)}>Click me</button>\n        </div>\n    );\n}\nএখানে, আমরা state (count) এর মান পরিবর্তন করলে, React সেই অনুযায়ী UI-কে রি-রেন্ডার করে। আমরা শুধু জানাচ্ছি UI কেমন দেখতে হবে যখন state পরিবর্তন হবে, কিন্তু কিভাবে DOM ম্যানিপুলেট হবে বা পরিবর্তনগুলো কীভাবে ঘটবে, তা React-এর দায়িত্ব।\nVirtual DOM: React-এর ডিক্লারেটিভ UI পরিবর্তনের আরেকটি বড় বিষয় হলো Virtual DOM। যখন state বা props পরিবর্তিত হয়, React প্রথমে সেই পরিবর্তনগুলোকে Virtual DOM-এর মাধ্যমে চেক করে, এবং তারপর প্রয়োজনীয় স্থানে শুধুমাত্র প্রয়োজনীয় UI অংশটুকু আপডেট করে।\nReact নিজেই Virtual DOM ব্যবহার করে কীভাবে পরিবর্তন করতে হবে, সেটি নির্ধারণ করে নেয়। ফলে ডেভেলপারকে DOM নিয়ে চিন্তা করতে হয় না।React-এর UI আপডেটিং পদ্ধতি ডিক্লারেটিভ এপ্রোচে কাজ করে। এর ফলে ডেভেলপাররা কেবল UI-র শেষ অবস্থা কী হবে তা বলে দেয়, আর React ভেতরে ভেতরে কীভাবে সেই পরিবর্তনগুলো ঘটাবে তা নিজে থেকেই করে।"}},"/reactive-accilarator/React-js/module-3/lifting-state-up":{"title":"Lifting State Up","data":{"":"lifting state up বা স্টেটকে উপরে নিয়ে যাওয়া, এটা হচ্ছে রিয়াক্টের বেস্ট ডিজাইন প্যাটার্নগুলোর মধ্যে একটা","লিফটং-স্টেট-আপ-বলতে-কি-বুঝায়-#লিফটং স্টেট আপ বলতে কি বুঝায় ?":"রিয়াক্টে কোন স্টেট কে কম্পোনেন্টের লোকাল জায়গায় না রেখে সেটাকে লিফট করে প্যারেন্ট কম্পোনেন্ট এ নিয়ে যাওয়াকে লিফটিং স্টেট আপ বা স্টেট উপরে নিয়া যাওয়া বুঝায়।","লিফটিং-স্টেট-আপ-কেন-করতে-হয়#লিফটিং স্টেট আপ কেন করতে হয়?":"আমরা জানি যে, রিয়াক্ট কম্পোনেন্টের স্টেটগুলো সেই কম্পোনেন্টের ভিতর আইসোলেটেড থাকে, মানে তা হলো তার নিজস্ব কম্পোনেন্ট। সেই কম্পোনেন্ট একাধিকবার ব্যাবহার করা হলেও প্রতিটা ইউজে সে আলাদা আলাদা স্টেট মেন্টেইন করবে, কখনো একটা আরেকটার সাথে সিঙ্ক থাকবেনা। আবার এমনও হতে পারে যে কোন একটা কম্পোনেন্টে দুইটা বা তিনটা Sibling কম্পোনেন্ট আছে, যেমনঃ\nconst App = () => {\n    return (\n        <div>\n            <Product />\n            <Cart />\n        </div>\n    );\n};\nexport default App;\nএখানে App নামে একটা প্যারেন্ট কম্পোনেন্ট আছে, যার দুইটা চাইল্ড কম্পোনেন্ট হলো Product এবং Cart। Product এবং Cart এরা নিজেরা আবার Siblingএখন ধরুন আমাদের Product কম্পোনেন্টের একটা লোকাল স্টেট আছে সেই কম্পোনেন্টের ভিতরে। এখন যদি সেই স্টেট টা আমাদের চাইল্ড কম্পোনেন্টের ভিতরে প্রয়োজন হয় তাহলে আমরা কি করতে পারি? আমরা কিভাবে Product এর লোকাল স্টেট কে Cart এ পাঠাবো?এই ক্ষেত্রেই কাজে লাগে lifting state up প্যাটার্ণ। আমরা Productকম্পোনেন্টের লোকাল স্টেটকে তাদের ইমিডিয়েট প্যারেন্ট কম্পোনেন্ট App এ নিয়ে আসতে পারি। এবং App থেকে Props পাস করার মাধ্যমে আমরা একই স্টেট Product এবং Cart দুটো কম্পোনেন্টেই পাঠাতে পারি।","controlled-and-uncontrolled-components#Controlled and Uncontrolled Components":"Controlled and Uncontrolled Components এটা সম্পূর্ন রিয়াক্টের একটা টার্ম,এটা কোন প্রোগ্রামিং এর টেকনিক্যাল টার্ম না।","controlled-components#Controlled Components":"রিয়াক্টে Controlled Component বলতে বুঝায় যেসব কম্পোনেন্টের কনট্রোল সম্পুর্নভাবে প্যারেন্টের কাছে থাকে, মানে প্যারেন্ট তার নিজস্ব স্পেসে স্টেট ম্যানেজ করছে, এবং শুধু ডাটাগুলো Props এর মাধ্যমে চাইল্ডে পাঠিয়ে দিচ্ছে, এমন কম্পোনেন্ট কে রিয়াক্টে Controlled Component বলা হয়।অর্থাৎ Controlled Component গুলো Props এর উপর নির্ভর করে।","uncontrolled-components#UnControlled Components":"যেসব রিয়াক্ট কম্পোনেন্ট তার নিজ লোকাল স্পেসে স্টেট নিয়ে সেই স্টেট দিয়ে কাজ করে,সেটা হলো UnControlled Componentমানে হলো সেই কম্পোনেন্টের উপর প্যারেন্টের কোন কনট্রোল নেই,সে তার নিজস্ব স্টেট ডাটার উপর নির্ভর করে, প্যারেন্টর Propsএর উপর নির্ভর করেনা।"}},"/reactive-accilarator/React-js/module-3/preserving-and-reseting-state":{"title":"Preserving and Reseting State","data":{"preserving-and-resetting-state#Preserving and Resetting State":"রিয়াক্টের স্টেটগুলো তার কম্পোনেন্টের মধ্যে isolated থাকে, এবং রিয়াক্ট তার কম্পোনেন্টগুলোকে যখন রেন্ডার করে তখন সে তার কম্পোনেন্টগুলোকে তার রেন্ডার ট্রি তে কম্পোনেন্টগুলোর স্টেট সহ মনে রাখে, যাতে যখন প্রয়োজন সে চাইলে স্টেট রিসেট করতে পারে, অথবা চাইলে স্টেট রিসেট করতে পারে।রিয়াক্ট কখন স্টেট প্রিসার্ভ করে আর কখন স্টেটগুলো রিসেট করে ফেলে,তা বিস্তারিত জেনে নেওয়া যাকঃরিয়াক্ট মূলত তিনটা রুলস মানেঃ👉1.State is tied to a position in the render tree (রিয়াক্টের স্টেটগুলো কম্পোনেটের পজিশনের সাথে যুক্ত থাকে)👉2.Same component at the same position preserves state (সেম কম্পোনেন্ট সেম পজিশনে স্টেট ধরে রাখে)👉3.Different components at the same position reset state (একই পজিশনে আলাদা আলাদা কম্পোনেন্ট আসলে স্টেট রিসেট হয়ে যায়)","state-is-tied-to-a-position-in-the-render-tree#State is tied to a position in the render tree":"রিয়াক্ট তার কম্পোনেন্টগুলোকে রেন্ডার করার পর সকল কম্পোনেন্ট গুলোকে একটা ট্রি আকারে চিন্তা করে, এবং ট্রি এর প্রতিটা আলাদা আলাদা পজিশনে যেসব কম্পোনেন্ট গুলো আছে সেগুলোকেও সে সেই পজিশনের সাথে যুক্ত রাখে।মানে হলো রিয়াক্টের রেন্ডার ট্রি এর আলাদা আলাদা পজিশনে যদি একই কম্পোনেন্ট রি-ইউজ করা হয়, তাতে কিন্তু আলাদা আলাদা পজিশন হউয়ার কারনে প্রতিটা পজিশনের কম্পোনেটের স্টেট টাও আলাদা হয়। এবং সেই কারণেই একটায় স্টেট চেঞ্জ করলেও অন্যটায় স্টেট চেঞ্জ হয়না।\nimport { useState } from \"react\";\nexport default function App() {\n    const counter = <Counter />;\n    return (\n        <div>\n            {counter}\n            {counter}\n        </div>\n    );\n}\nfunction Counter() {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>{score}</h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nউপরে একটা কাউন্টার কম্পোনেন্ট কে দুইবার রি-ইউজ করা হয়েছে,\nexport default function App() {\n    const counter = <Counter />;\n    return (\n        <div>\n            {counter}\n            {counter}\n        </div>\n    );\n}\nএকানে একই কম্পোনেট দুইবার ব্যাবহার করা হলেও দুইটা কিন্তু দুই পজিশনে আছে, আমরা যদি উপরের কোডটার UI দেখি তাহলে এমন দেখতে পাবো এখানে দেখা যাচ্ছে দুইটা একই কম্পোনেট পাশাপাশি বসে আছে, পাশাপাশি বসে থাকলেও এই কম্পোনেট দুইটার রেন্ডার ট্রি-রিপ্রেজেটেশন হলো এমনঃ এখন তাহলে পরিষ্কার বুঝা যাচ্ছে যে, যদিও দুইটা একই কম্পোনেট কিন্তু রিয়াক্টের ট্রি তে তাদের পজিশন আলাদা আলাদা। আর এজন্যই একটা কম্পোনেন্টে স্টেট চেঞ্জ করলেও অন্য কম্পোনেন্টে কোন ধরনের কোন স্টেট পরিবর্তন হয়না। এজন্যই বলা হয় State is tied to a positionআমরা এটা আরও ভালো করে বুঝতে পারবো যদি নিচের উদাহরণগুলো একটু দেখি।চলুন একটা চেকবক্স এড করি,যাতে আমরা চাইলে দ্বিতীয় কাউন্টার কম্পোনেন্টকে চাইলে রেন্ডার করতে পারি আবার চাইলে রিমুভ করে দিতে পারি।\nimport { useState } from \"react\";\nexport default function App() {\n    const [showB, setShowB] = useState(true);\n    return (\n        <div>\n            <Counter />\n            {showB && <Counter />}\n            <label>\n                <input\n                    type='checkbox'\n                    checked={showB}\n                    onChange={(e) => {\n                        setShowB(e.target.checked);\n                    }}\n                />\n                Render the second counter\n            </label>\n        </div>\n    );\n}\nfunction Counter() {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>{score}</h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nআউটপুট: এখানে আমরা দুইটা কাউন্টারের সাথে একটা চেকবক্স দেখতে পাচ্ছি, আমরা কাউন্টারের স্টেট গুলো আপডেট করতে পারছি এবং চেকবক্স এ চাপ দিয়ে আনচেক করে দিলে দ্বিতীয় কাউন্টারটি রিমুভ হয়ে যাচ্ছে, এবং আবার চেক করলে চলে আসছে।কিন্তু খেয়াল করুন দ্বিতীয়বার যখন কম্পোনেন্টটি ফেরত আসলো তখন কিন্তু তার স্টেট রিসেট হয়ে গেছে, তাহলে এটা কেন হলো ?এটা এজন্য হলো যে, যখন চেকবক্স আনচেক করা হয়েছে তখন কম্পনেন্টটি তার পজিশন থেকে সমস্ত স্টেট সহ ডিলিট হয়ে গেছে, তাই দ্বিতীয়বার যখন আবার ফেরত আনা হচ্ছে তখন সে সম্পুর্ন নতুন কম্পোনেন্ট হয় আসছে।একানে রেন্ডার ট্রি তে যা ঘটছে তা হলোঃঅর্থাৎ কম্পোনেট ট্রি থেকে রিমুভ হয়ে গেলে ট্রি স্ট্রাকচার টা পরিবর্তন হয়ে যাচ্ছে, তাই কম্পোনেন্টের সকল স্টেট ডেস্ট্রয় হয়ে যাচ্ছে।সুতরাং কোন কম্পোনেন্ট যতক্ষণ তার নিজ পজিশনে বসে থাকে ততক্ষণ রিয়াক্ট স্টেট কে ধরে রাখে, যদি সেটি তার পজিশন থেকে রিমুভ হয়ে যায়,তাহলে স্টেট ও রিসেট হয় যায়।","same-component-at-the-same-position-preserves-state#Same component at the same position preserves state":"একই কম্পোনেট যতক্ষণ তার একই পজিশনে বসে থাকবে ততক্ষণ সে তার নিজস্ব স্টেট ধরে রাখবে। যদি এমনও হয় যে আপনি প্যারেন্ট কম্পোনেন্ট থেকে কোন স্টেট চেঞ্জ করছেন বা কন্ডীশনালি কিছু করছেন তবুও সেই কম্পোনেন্ট যতক্ষন তার নিজস্ব পজিশনে বসে থাকবে,ততক্ষণ সে তার লোকাল স্টেট ধরে রাখবে।\nimport { useState } from \"react\";\nexport default function App() {\n    const [isFancy, setIsFancy] = useState(false);\n    return (\n        <div>\n            {isFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />}\n            <label>\n                <input\n                    type='checkbox'\n                    checked={isFancy}\n                    onChange={(e) => {\n                        setIsFancy(e.target.checked);\n                    }}\n                />\n                Use fancy styling\n            </label>\n        </div>\n    );\n}\nfunction Counter({ isFancy }) {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    if (isFancy) {\n        className += \" fancy\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>{score}</h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nউপরের এই কোডে একটা কাউন্টার কম্পোনেন্টকে একটা কন্ডিশন দিয়ে রেন্ডার করা হয়েছে,\nconst [isFancy, setIsFancy] = useState(false);\nisFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />;\nএখানে দেখা যাচ্ছে যে একটি isFancy স্টেট এর উপর বেস করে এখানে কন্ডিশনালি কম্পোনেন্ট কে রেন্ডার করা হয়েছে, এবং একটা চেকবক্স রাখা হয়েছে যেখানে ক্লিক করলে isFancy এই স্টেট টার ভ্যালু চেঞ্জ হয়।এখন স্বাভাবিকভাবে মনে হতে পারে যখন চেকবক্স এ ক্লিক করা হবে তখন আগের কম্পোনেন্ট রিমুভ হয়ে নতুন কম্পোনেন্ট আসবে এবং তার স্টেট রিসেট হয়ে যাবে।কিন্তু না, তা হবেনা । কেননা কন্ডিশনালি প্রপ্স চেঞ্জ হলেও একই কাউন্টার কম্পোনেন্ট কিন্তু রেন্ডার ট্রি এর একই পজিশনে আছে। তাই তার স্টেট রিসেট হবেনা।\nআমরা যখন পজিশনের কথা বলছি,মনে রাখতে হবে এটা হলো রিয়াক্ট এর রেন্ডার ট্রি। এটা\nকিন্তু JSX ট্রি নয়। যতক্ষণ পর্যন্ত রিয়াক্ট এর রেন্ডার ট্রি-তে কোন পরিবর্তন\nনা হবে ততক্ষণ সে কম্পোনেন্টগুলোর স্টেট ধরে রাখবে, যদি কোন কম্পোনেন্ট রিয়াক্ট\nএর রেন্ডার ট্রি থেকে রিমুভ হয় বা কোনকারনে ওই পজিশনে অন্য কোন কম্পোনেন্ট বসে\nতাহলে সেই কম্পোনেন্টের স্টেট রিসেট হয়ে যাবে।","different-components-at-the-same-position-reset-state#Different components at the same position reset state":"একই পজিশনে যদি আগের রেন্ডারে যেই কম্পোনেন্ট ছিল, পরের রেন্ডারে সেই কম্পোনেন্ট না থাকে, বা পরের রেন্ডারে ওই পজিশনে অন্য কোন কম্পোনেন্ট বসে তাহলে রিয়াক্ট স্টেট রিসেট করে দেয়।\nimport { useState } from \"react\";\nexport default function App() {\n    const [isPaused, setIsPaused] = useState(false);\n    return (\n        <div>\n            {isPaused ? <p>See you later!</p> : <Counter />}\n            <label>\n                <input\n                    type='checkbox'\n                    checked={isPaused}\n                    onChange={(e) => {\n                        setIsPaused(e.target.checked);\n                    }}\n                />\n                Take a break\n            </label>\n        </div>\n    );\n}\nfunction Counter() {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>{score}</h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nএখানে খেয়াল করলে দেখবেন যে,\n    const [isPaused, setIsPaused] = useState(false);\n    return (\n        <div>\n            {isPaused ? <p>See you later!</p> : <Counter />}\n            <label>\n                <input\n                    type='checkbox'\n                    checked={isPaused}\n                    onChange={(e) => {\n                        setIsPaused(e.target.checked);\n                    }}\n                />\n                Take a break\n            </label>\n        </div>\nএখানে কন্ডিশনালি একই পজিশনে দুইটা কম্পোনেন্ট দেখানো হচ্ছে, যখন চেকবক্স এ ক্লিক করা হচ্ছে তখন কাউন্টার কম্পোনেন্ট এর পজিশনে একটা <p>...</p> ট্যাগ বসছে, যখনি <p>...</p> ট্যাগ বসছে,তখনি দ্বিতীয় রেন্ডারে রিয়াক্ট তার রেন্ডার ট্রি এর ওই পজিশনে আর কাউন্টারকে পাচ্চেনা,তাই কাউন্টার কম্পোনেন্ট রিমুভ হওয়ার সাথে সাথে তার স্টেট সহ রিসেট হয়ে যাচ্ছে। তাই পরেরবার আবার যখন চেকবক্স আনচেক করে কাউন্টার কম্পোনেন্ট আবার আনা হচ্ছে, তখন সে একটা ফ্রেশ কম্পোনেন্ট হিসেবে আসছে।সর্বশেষে মোট কথা হলো যদি একটা রেন্ডার থেকে পরবর্তি রেন্ডারে কম্পোনেন্টগুলোর স্টেট ধরে রাখতে হয়, তাহলে রেন্ডার ট্রি এর স্ট্রাকচার দুইটা রেন্ডারেই সেম থাকতে হবে।"}},"/reactive-accilarator/React-js/module-3/reseting-state-at-same-position":{"title":"Reseting State at Same Position","data":{"resetting-state-at-the-same-position#Resetting state at the same position":"আমরা জানি কোন কম্পনেন্ট একই পজিশনে যতক্ষণ থাকবে ততক্ষণ রিয়াক্ট তার স্টেট ধরে রাখবে।কিন্তু যদি আমাদের এমন প্রয়োজন হয় যে আমরা একই পজিশনে কম্পনেন্টের স্টেট রিসেট করবো। তাহলে দুইটা উপায়ে আমরা সেটা করতে পারিঃ\nRendering a component in different positions\nGive each component an explicit identity with key","rendering-a-component-in-different-positions#Rendering a component in different positions":"import { useState } from \"react\";\nexport default function Scoreboard() {\n    const [isPlayerA, setIsPlayerA] = useState(true);\n    return (\n        <div>\n            {isPlayerA ? (\n                <Counter person='Taylor' />\n            ) : (\n                <Counter person='Sarah' />\n            )}\n            <button\n                onClick={() => {\n                    setIsPlayerA(!isPlayerA);\n                }}>\n                Next player!\n            </button>\n        </div>\n    );\n}\nfunction Counter({ person }) {\n    const [score, setScore] = useState(0);\n    const [hover, setHover] = useState(false);\n    let className = \"counter\";\n    if (hover) {\n        className += \" hover\";\n    }\n    return (\n        <div\n            className={className}\n            onPointerEnter={() => setHover(true)}\n            onPointerLeave={() => setHover(false)}>\n            <h1>\n                {person}'s score: {score}\n            </h1>\n            <button onClick={() => setScore(score + 1)}>Add one</button>\n        </div>\n    );\n}\nএখানে একটা কম্পোনেন্টে প্লেয়ারের স্কোর কাউন্ট করা হচ্ছে, আমরা যখন Add One বাটনে চাপ দিয়ে স্কোর বারাচ্ছি,তখন স্কোর এর স্টেট চেঞ্জ হচ্ছে, আবার আমরা নিচে একটা বাটন রেখেছি Next Player নামে, এবং আমরা চাইছি যে বাটনে চাপ দিলে প্লেয়ার এর নাম চেঞ্জ হবে এবং স্কোরটা রিসেট হয়ে যাবে। কিন্তু এখানে সেটা হচ্ছেনা, কারণ হলো এখানে একই পজিশনে কাউন্টার কম্পোনেন্ট তার পজিশনে ধরে রেখছে,তাই স্টেট রিসেট হচ্ছে।কিন্তু যদি আমরা কোডটা এভাবে লিখি,\n// প্রথম কোড যা স্টেট ধরে রাখবে\n{\n    isPlayerA ? <Counter person='Taylor' /> : <Counter person='Sarah' />;\n}\n{\n    isPlayerA && <Counter person='Taylor' />; // এখানে যদি isPlayerA না হয় তাহলে এই পজিশনে null রিটার্ন হবে\n}\n{\n    !isPlayerA && <Counter person='Sarah' />; // এখানে যদি isPlayerA হয় তাহলে এই পজিশনে null রিটার্ন হবে\n}\nএকানে রেন্ডার ট্রি-এর স্ট্রাকচার টা হয় এমনঃ তাহলে দেখা যাচ্ছে যে isPlayerA না হয় তাহলে নিচের কম্পোনেন্ট রেন্ডার হবে। এখানে কিন্তু দুইটা কম্পোনেন্ট দুইটা আলাদা পজিশনে আছে, কেননা একটা যদি true না হয় সেই পজিশনে কিন্তু একটা null রিটার্ন হয়, এবং অন্য কম্পোনেন্ট টা আলাদা একটা পজিশনে রেন্ডার হয়।","resetting-state-with-a-key#Resetting state with a key":"আরেকটা সবচাইতে এফিসিয়েন্ট উপায় হলো key প্রপ্স ব্যাবহার করা, আমরা লিস্ট রেন্ডার করার সময় keyপ্রপ্স এর সাথে পরিচিত হয়েছিলাম,key প্রপ্স শুধুমাত্র লিস্ট রেন্ডারিং এর জন্য ব্যবহার হয়না। key প্রপ্স এর মানে হলো সেই কম্পোনেন্টকে রিয়াক্টের কাছে একটা আলাদা কম্পোনেন্ট হিসেবে রিপ্রেজেন্ট করা।তাই আমরা যদি আগের মতো করেই কোড করি এবং শুধু স্টেটগুলো রিসেট করতে চাই তাহলে আমরা এভাবে key প্রপ্স ব্যাবহার করতে পারি।\n{\n    isPlayerA ? (\n        <Counter\n            key='Taylor'\n            person='Taylor'\n        />\n    ) : (\n        <Counter\n            key='Sarah'\n            person='Sarah'\n        />\n    );\n}\nএখানে key প্রপ্স এর মানে হলো একই পজিশনে দুইটা সম্পুর্ন আলাদা কম্পোনেন্ট ।"}},"/reactive-accilarator/React-js/module-3/thinking-about-ui":{"title":"Thinking about UI","data":{"ইউ-আই-কে-ডিক্লারেটিভলি-ভাবা-thinking-about-ui-declaratively#ইউ আই-কে ডিক্লারেটিভলি ভাবা (Thinking about UI declaratively)":"আমরা যখনি রিয়াক্টের কোন UI কে পরিবর্তন বা ম্যানেজ করতে চাইবো তখন আমাদের স্টেট দিয়ে তা ম্যানেজ করা লাগবে । একটা কম্পোনেন্টে কি কি স্টেট থাকতে পারে বা কিভাবে খুব সুন্দর করে স্টেটগুলো ম্যনেজ করতে হবে তা খুব ভালোভাবে বুঝতে হলে আমাদের কয়েকটা স্টেপ অবশ্যই ফলো করতে হবে। নিচে এই স্টেপগুলো নিয়ে বিস্তারিত আলোচনা করবো। এই স্টেপগুলো খুব ভালোভাবে বুঝতে পারলে যেকোন কমপ্লেক্স UI এর স্টেট ম্যানেজমেন্ট খুব সহজেই করে ফেলা সম্ভব। চলুন স্টেপগুলো জানি,\nIdentify Components differnet visual states\nDetermine What trigger those state changes\nRepresent the state in memory useing useState\nRemove any not-essential state variables\nConnent the event handlers to set the state","identify-components-differnet-visual-states-কম্পোনেন্টের-কি-কি-পরিবর্তন-বা-অবস্থা-হতে-পারেতা-নির্ধারণ-করা#Identify Components differnet visual states (কম্পোনেন্টের কি কি পরিবর্তন বা অবস্থা হতে পারে,তা নির্ধারণ করা)":"প্রথমেই আমাদের বুঝতে হবে যে আমাদের UI তে কি কি পরিবর্তন হতে পারে। মানে UI টা কি কি অবস্থায় স্ক্রিনে দেখা যাবে।উদাহরণ হিসেবে, ধরুন আমারা একটা ফর্ম এর কথা ভাবি, ফরমটা একটা প্রশ্নের উত্তর নেয়, এবং উত্তর সঠিক হলে সাকসেস মেসেজ দেখায় আর ভুল হলে ইরর মেসেজ দেখায়। আর ফর্ম টায় কোন কিছু না লিখা হলে ফর্মটা ডিসেবল থাকে, আর কিছু লিখে ফর্মটা সাবমিট করা হলে একটা লোডীং দেখায়।তাহলে চলুন একটু ভিজুয়ালাইজ করি আমাদের এর কম্পোনেন্টের কি কি ভিজুয়াল স্টেট হতে পারে:১।  ২।  ৩। ৪।  ৫। তাহলে এখানে আমরা UI তে পাচটি স্টেট দেখতে পাচ্ছি,empty, typing, submitting, success, error এতে আমরা ক্লিয়ার ধারনা পাই যা আমাদের UI তে কি কি পরিবর্তন হবে আর কখন কোন স্টেট এ থাকবে। এই ভাবে একটা কম্পোনেন্টের প্রতিটা ভিজুয়াল চেঞ্জকে রিপ্রেজেন্ট করা কে স্টোরিবুকস বলা হয়","determine-what-triggers-those-state-changes-কোন-কোন-কারনে-স্টেট-এর-পরিবর্তনগুলো-ট্রিগার-হবে-তা-নির্ধারন-করা#Determine what triggers those state changes (কোন কোন কারনে স্টেট এর পরিবর্তনগুলো ট্রিগার হবে তা নির্ধারন করা)":"UI তে যেই স্টেট এর পরিবর্তনগুলো হবে,সেগুলো কিভাবে ট্রিগার হবে তা নির্ধারন করতে হবে। স্টেট এর পরিবর্তনগুলো কি ইউজারেরে কোন ইন্টারেকশনের কারনে হবে নাকি কম্পিউটার অটোমেটিক করবে তা নির্ধারন করতে হবে।এক্ষেত্রে যেমন ইউজার ইনপুট ফিল্ডে কিছু লিখলে স্টেট হবে টাইপিং,আর সাবমিট করলে হবে সাবমিটিং।আর ইরর হবে নাকি সাকসেস হবে সেটা কম্পিউটার নিজে ডিসিশন নিবে।অর্থাৎ দ্বিতীয় স্টেপে আমাদের বুঝতে হবে যে, কখন কিভাবে স্টেট চেঞ্জ গুলো ট্রিগার হবে।এই স্টেট চেঞ্জের স্টেপগুলোকে আমরা একটা ডায়াগ্রামে রিপ্রেজেন্ট করতে পারলে পুরো স্টেট চেঞ্জের ফ্লো-টা বোঝা অনেক সহজ হয়ে যায়। যেমনঃ","represent-the-state-in-memory-with-usestate-usestateব্যবহার-করে-স্টেটগুলো-কে-রিপ্রেজেন্ট-করা#Represent the state in memory with useState (useStateব্যবহার করে স্টেটগুলো কে রিপ্রেজেন্ট করা)":"এই স্টেপে আমাদের যেসব স্টেটগুলো প্রয়োজন হবে সেগুলো কে useState হুক দিয়ে ইনিশিয়ালিজ করতে হবে বা ডিফাইন করতে হবে। এই উদাহরণে স্বাভাবিকভাবে দেখলে আমাদের পাঁচটা স্টেট লাগবে,\nconst [isEmpty, setIsEmpty] = useState(true);\nconst [isTyping, setIsTyping] = useState(false);\nconst [isSubmitting, setIsSubmitting] = useState(false);\nconst [isSuccess, setIsSuccess] = useState(false);\nconst [isError, setIsError] = useState(false);\nএছাড়াও আমাদেরকে ফর্মের ইনপুট হ্যান্ডেল করা আর ইরর হয়েছে কিনা তা বুঝার জন্য আরও দুইটা স্টেট অবশ্যই নেয়া লাগতে পারে।\nconst [answer, setAnswer] = useState(\"\");\nconst [error, setError] = useState(null);","remove-any-non-essential-state-variablesঅপ্রয়োজনীয়-স্টেট-ভ্যারিয়েবল-রিমুভ-করে-দেয়া#Remove any non-essential state variables(অপ্রয়োজনীয় স্টেট ভ্যারিয়েবল রিমুভ করে দেয়া)":"এই পর্যায়ে আমাদের বুঝতে হবে যে আমরা যেই state গুলো ডিফাইন করেছি তার প্রত্যেকটাই কি আমাদের লাগবে কিনা, কোন একটা স্টেট ভ্যারিয়েবল দিয়ে অন্যটার কাজ হয়ে যাচ্ছে কিনা বা কোন স্টেট ডুপ্লিকেট হচ্ছে কিনা এবং একই সময়ে দুইটা স্টেট কখনো সত্যি অথবা মিথ্যা (Paradox) হতে পারেনা এমন ক্ষেত্রে একই স্টেট নেয়াঅর্থাৎ এই পর্যায়ে আমাদের স্টেটকে ক্লিনাপ করা লাগবে, অপ্রয়োজনীয় স্টেট ভ্যরিয়েবলগুলোকে রিমুভ করে দিতে হবে।এক্ষেত্রে যেমন আমরা empty আর typing দুইটা ইনফরমেশনএর স্টেট দুইটা বাদ দিয়ে শুধুমাত্র answer স্টেট থেকেই সবকিছু ম্যনেজ করতে পারি। যেমন answer.length == 0 মানে হলো empty আর 0 না হলে typing তাহলে আমরা খুব সহজেই empty আর typing এই দুইটা স্টেট রিমুভ করে দিতে পারি।আবার বাকি তিনটা অবস্থা submitting successঅথবা error আমরা শুধু একটা স্টেট ভ্যারিয়েবল status নিয়েই আমরা মেনেজ করতে পারি।\nconst [status, setStatus] = useState(\"typing\"); // 'submitting', or 'success / error'\nতাহলে এখানে আমাদের শুধু তিনটা স্টেট নিলেই সমস্ত কিছু পারফেক্টলি হয়ে যাচ্ছে,\nconst [answer, setAnswer] = useState(\"\");\nconst [error, setError] = useState(null);\nconst [status, setStatus] = useState(\"typing\"); // 'submitting', or 'success / error'","connect-the-event-handlers-to-set-stateস্টেটগুলো-চেঞ্জ-করার-জন্য-ইভেন্ট-হ্যন্ডেলারগুলো-কানেক্ট-করিয়ে-দিতে-হবে#Connect the event handlers to set state(স্টেটগুলো চেঞ্জ করার জন্য ইভেন্ট হ্যন্ডেলারগুলো কানেক্ট করিয়ে দিতে হবে)":"এই পর্যায়ে আমাদের শুধু স্টেট এর সেটার ফাংশনগুলোকে ইভেন্ট হ্যান্ডেলারের সাথে কানেক্ট করিয়ে দিতে হবে, যাতে ইভেন্ট ট্রিগার হলেই স্টেটগুলো আপডেট হতে থাকে।"}},"/reactive-accilarator/frontend-focus-topic":{"title":"Frontend Focus Topic","data":{"":"That's great! Since you've already learned React and Next.js, you're off to a solid start. To become a well-rounded frontend developer, here are some key areas to focus on next:","1-advanced-javascript#1. Advanced JavaScript":"Deepen your understanding of JavaScript (ES6+).\nLearn about asynchronous programming (Promises, Async/Await).\nStudy closures, event loops, and execution contexts.","2-state-management#2. State Management":"Learn advanced state management tools like Redux, Recoil, or Zustand.\nUnderstand context API more deeply for managing local state.","3-typescript#3. TypeScript":"Since many modern React/Next.js projects use TypeScript, learning this will make your code more robust and reduce bugs.","4-css-and-design-systems#4. CSS and Design Systems":"Explore CSS frameworks like TailwindCSS, Material-UI, or Chakra UI.\nLearn about CSS-in-JS libraries like Styled Components and Emotion.\nStudy responsive design and grid systems (Flexbox, Grid).\nUnderstand design systems and how to create or work with component libraries.","5-testing#5. Testing":"Learn to test your components using Jest, React Testing Library, or Cypress.\nUnderstand the concepts of unit testing, integration testing, and end-to-end testing.","6-version-control--collaboration#6. Version Control & Collaboration":"Improve your understanding of Git and tools like GitHub, GitLab, or Bitbucket.\nLearn about branching strategies, pull requests, and code reviews.","7-performance-optimization#7. Performance Optimization":"Learn about code-splitting, lazy loading, and optimizing images in React/Next.js.\nFocus on Lighthouse, PageSpeed Insights, and tools for optimizing web performance.","8-seo-for-frontend#8. SEO for Frontend":"Dive deeper into Next.js SEO features.\nLearn about server-side rendering (SSR), static site generation (SSG), and dynamic routing.","9-progressive-web-apps-pwa#9. Progressive Web Apps (PWA)":"Learn how to build PWAs, including service workers, caching strategies, and offline functionality.","10-build-tools#10. Build Tools":"Familiarize yourself with Webpack, Babel, Vite, or Parcel.\nUnderstand CI/CD pipelines and how to automate testing, building, and deployment.","11-authentication-and-security#11. Authentication and Security":"Explore OAuth, JWT, and integrating authentication systems (e.g., Firebase Auth, NextAuth).\nLearn about web security essentials (XSS, CSRF, HTTPS, etc.).\nBy working through these topics, you'll significantly enhance your frontend development skills and become more prepared for real-world projects."}},"/reactive-accilarator/git":{"title":"গিট এবং গিটহাব","data":{"গিট-কি-#গিট কি ?":"গিট হলো একটি ভার্সন কনট্রোল টুল।ভার্সন কনট্রোল কি ?ধরুন আপনি আপনার কম্পিউটার এ কোন ডকুমেন্ট লিখছেন,সেখানে হয়তো আজ কিছু লিখছেন আবার হয়তো অন্যদিন কিছু লিখছেন। এভাবে হয়তো আপনার কখনও মনে হলো যে আপনি গত দুইদিন যা লিখেছেন তা হয়তো সঠিক নয়, আপনি তা ডিলিট করে আবার দুই দিন আগে যা লিখেছেন সেই অবস্থায় ফিরত যেতে চান। এক্ষেত্র আপনাকে যেটা করা লাগবে তা হলো এই দুইদিনের সমস্ত লিখা মুছে ফেলতে হবে। এখন এই অবস্থায় আপনার যদি মনে না থাকে যে আপানর ঠিক কোন পর্যন্ত মুছা উচিত বা দুইদিন আগে ঠিক কতটুকু লেখা হয়েছিলো,তখন আপনি কি করবেন? ঠিক এই কাজটায় গিট হেল্প করে থাকে। গিট কোন ফাইলের প্রতিটা চেঞ্জেস গুলোকে মনিটরিং করে বা ট্র্যাক রাখে এবং প্রতিটা চেঞ্জেস গুলোকে ভার্সনাইজ করে। যাতে আপনি যেকোন সময় যেকোনো ভার্সনে সুইচ করতে পারেন ।","গিটের-কিছু-প্রয়োজনীয়-কমান্ড-যা-আমাদের-গিটের-লোকাল-রিপজিটরিতে-ফাইল-ম্যানেজ-করতে-প্রয়োজন-হবে#গিটের কিছু প্রয়োজনীয় কমান্ড যা আমাদের গিটের লোকাল রিপজিটরিতে ফাইল ম্যানেজ করতে প্রয়োজন হবে।":"গিট ইনিশিয়ালাইজ করা\n git init\nগিট এর স্ট্যাটাস চেক করা\ngit status\nফাইলকে গিটের ট্রাক করার জন্য স্টেজ এ উঠানো\ngit add <filename> //For stage any specific file\nor\ngit add --all // if you want to add all files\nor\ngit add .  // if you want to add all files in the current working directory\nকমিট করা\ngit commit -m \"<commit massage>\"\nগিট লগ চেক করা\ngit log\nor\ngit log --oneline\nএকটা কমিট থেকে অন্য কমিটের অবস্থায় ফিরে যাওয়া\ngit reset --hard <commit id>\nগিটের প্রতিটা চেঞ্জের রেফারেন্স সহ লগ দেখার জন্য\ngit reflog\nগিটের ট্র্যাক থেকে কোন ফাইল রিমূভ করা\ngit rm <filename>\nব্রাঞ্চ তৈরী করা\ngit branch <branch name eg: bugfix/fixname >\nব্রাঞ্চ লিস্ট দেখা\ngit branch --list\nএক ব্রাঞ্চ থেকে অন্য ব্রাঞ্চ এ সুইচ করা\ngit switch <branch name >\nএক ব্রাঞ্চের কোড অন্য ব্রাঞ্চে মার্জ করা\nএক্ষেত্রে যেই ব্রাঞ্চে অন্য ব্রাঞ্চের কোড আনতে হবে,প্রথমে git switch <branchname> করে প্রথমে সেই ব্রাঞ্চে যেতে হবে। তারপর কমান্ড দিতে হবে।\ngit merge <branch name >\nগিট থেকে ব্রাঞ্চ ডিলিট করা\ngit branch -d <branch name >\nব্রাঞ্চ নেম পরিবর্তন করতে চাইলে\n এক্ষেত্রে যেই ব্রাঞ্চের নাম পরিবর্তন করতে হবে আমাদেরকে প্রথমে git switch <branchname> করে প্রথমে সেই ব্রাঞ্চে যেতে হবে। তারপর কমান্ড দিতে হবে। \ngit branch -m <updated branch name >\nগিট স্ট্যাস করা (আনকমিটেড কাজ গিটের ড্রাফট এ সেভ রাখা)\ngit stash\nগিট স্ট্যাস লিস্ট চেক করা\ngit stash list\nগিটের স্ট্যাস এ কি কি সেভ রাখা হয়েছিল তা দেখতে\ngit stash show -p\nগিটের স্ট্যাস এপ্লাই করার জন্য\ngit stash apply <statsh id>\nor\ngit stash pop\nকোন ফাইল ভুলবশত গিটে এড করে ফেললে বা কমিট করার পর যদি মনে হয় ফাইলটা গিট থেকে ইগনোর করতে হবে তাহলে:","১ম-স্টেপঃ#১ম স্টেপঃ":"একটা .gitignore ফাইল বানাতে হবে এবং তাতে উক্ত ফাইলের নাম এড করা লাগবে ।","২য়-স্টেপঃ#২য় স্টেপঃ":"git rm --cached <filename>\nগিটহাব বা রিমোট রিপোজিটরিতে ফাইল এড করা বা পুশ করার জন্যঃ","১ম-স্টেপঃ-1#১ম স্টেপঃ":"git remote add <origin name eg: orgin or something > <github repository link>\nexample:git remote add origin git@github.com:Deveripon/reactive-accelarator.git","২য়-স্টেপঃ-1#২য় স্টেপঃ":"git push -u <origin name> <branch name>\nexample:git push -u origin main\nরিমোট রিপোজিটরি থেকে পুল করা\ngit pull"}},"/reactive-accilarator":{"title":"Index","data":{"কিভাবে-এই-কোর্স-থেকে-সর্বোচ্চ-ফলাফল-পেতে-পারি-#কিভাবে এই কোর্স থেকে সর্বোচ্চ ফলাফল পেতে পারি ?":"এই কোর্স থেকে সবচেয়ে ভালো ফলাফল পেতে হলে আমাদের নিচের পয়েন্টগুলো অবশ্যই মাথায় রাখতে হবে।\nধৈর্যঃ\nরিডিং পড়ার অভ্যাস\nভিডিও স্কিপ করা যাবেনা\nকুইজে অংশগ্রহণ\nআসাইন্মেন্ট জমা দেয়া\nনিজেকে পুশ করা ও মোটিভেটেড রাখা\nনিঃসংকোচে আস্ক ফর হেল্প\nএটেন্ড লাইভ সেশনস\nলজিকাল হতে হবে"}},"/reactive-accilarator/javascript-refresher":{"title":"Advanced JavaScript","data":{"scope-in-javascript#Scope in JavaScript":"","primitive-and-reference-types-value#Primitive and Reference types Value":"","primitive#Primitive":"প্রিমিটিভ এর বাংলা অর্থ হলো আদিম। জাভাস্ক্রিপ্টে যেসব DATATYPE আছে যেমনঃ\nString\nNumber\nBoolean\nNull\nUndefined\nএইগুলো হলো জাভাস্ক্রিপ্টের মূল বা একক। এগুলো ব্যাবহার করে অন্যান্য ডাটা বানানো হয়। এগুলোকে বলা হয় প্রিমিটিভ ডাটা বা ভ্যালু ।","references#References":"জাভাস্ক্রিপ্টের Array এবং Object কে বলা হয় রেফারেন্স টাইপ ডাটা বা ভ্যালু ।","প্রিমিটিভ-এবং-রেফারেন্স-টাইপ-ডাটার-পার্থক্যঃ#প্রিমিটিভ এবং রেফারেন্স টাইপ ডাটার পার্থক্যঃ":"প্রিমিটিভ এবং রেফারেন্স টাইপ ডাটার মধ্যে মূল যেই পার্থক্য রয়েছে তা হলো এর ডাটার বিহেবিয়ার নিয়ে। যেমন নিচে উদাহরণের মাধ্যমে বুঝানো হলোঃ","primitive-1#Primitive":"প্রিমিটিভ ডাটা শুধুমাত্র ভ্যালুটা শেয়ার করে। ডাটার রেফারেন্স শেয়ার করেনা।","reference#Reference":"এখানে a কে যখন b দ্বারা রি-এসাইন করা হয়েছে তখন স্বাভাবিক ভাবেই আ এর ভ্যালু চেঞ্জ হয়ে b এর যেই ভ্যালু ছিল তা হয়ে গিয়েছে। কিন্তু নিচে যখন b এর ভ্যালু চেঞ্জ করা হয়েছে সেই চেঞ্জটা a তেও এসে প্রভাব ফেলেছে এবং a সহ চেঞ্জ হয়ে গেছে। কারণ এখানে a তে যখন b এসাইন করা হয়েছিল তখন a তে b এর রেফারেন্স সহ চলে গেছিল,তাই যেকোন একটা কে চেঞ্জ করলেই দুইটাই চেঞ্জ হয়ে যাচ্ছে।এখানে যেই বিষয়টা হয়েছে তা হলোঃa আর b যখন ডিফাইন করা হয়েছে তখন মেমরিতে দুইটা Array এলোকেটেড করা হয়েছে এবং Array দুটি তাদের যেই Variables এর নাম a এবং b তার দিয়ে পয়েন্ট করে আছে। কিন্তু যখন a = b করা হয়েছে তখন দুইটা পয়েন্টার এক হয়ে b এর ভ্যালু থেকে a আর b এর দিকে পয়েন্ট হয়ে গেছে। তাই এখন a অথবা b যেইটাই চেঞ্জ করা হউক না কেন তা দুইটাকেই চেঞ্জ করবে।এটাই হলো primitives আর References ভ্যালুর মধ্যে মূল পার্থক্য ।","shallow-copy-vs-deep-copy#Shallow Copy Vs Deep Copy":"জাভাস্ক্রিপ্টে \"শ্যালো কপি\" (Shallow Copy) এবং \"ডিপ কপি\" (Deep Copy) হল দুটি আলাদা প্রক্রিয়া যেগুলো ব্যবহার করে একটি Object বা Array'র কপি তৈরি করা হয়। তবে এদের মধ্যে বড় পার্থক্য হচ্ছে কিভাবে ডেটা কপি করা হয়। নিচে প্রতিটি কনসেপ্ট বিস্তারিতভাবে ব্যাখ্যা করছি:","শ্যালো-কপি-shallow-copy#শ্যালো কপি (Shallow Copy)":"শ্যালো কপিতে কেবলমাত্র অবজেক্টের প্রথম লেভেলের ভ্যালুগুলি কপি করা হয়। এর মানে হলো, যদি অবজেক্ট বা আরে'র মধ্যে নেস্টেড অবজেক্ট থাকে, তাহলে সেগুলি রেফারেন্স হিসেবে কপি হয়। অর্থাৎ, নেস্টেড অবজেক্ট বা আরে'র জন্য একটি রেফারেন্স তৈরি হয়, নতুন অবজেক্টে একই ডেটা শেয়ার করে।","উদাহরণ#উদাহরণ:":"let originalArray = [1, 2, { a: 3, b: 4 }];\n// শ্যালো কপি তৈরি করা\nlet shallowCopy = [...originalArray];\nconsole.log(shallowCopy); // [1, 2, { a: 3, b: 4 }]\n// নেস্টেড অবজেক্ট পরিবর্তন করা\nshallowCopy[2].a = 10;\nconsole.log(originalArray); // [1, 2, { a: 10, b: 4 }]\nconsole.log(shallowCopy); // [1, 2, { a: 10, b: 4 }] // নেস্টেড অবজেক্ট রেফারেন্স একারে কপি হওয়ার কারনে কপি ডাটাতে চেঞ্জ করলেও তা মেইন ডাটাকেও চেঞ্জ করে দিয়েছে।\nএই উদাহরণে দেখা যাচ্ছে যে, originalArray এবং shallowCopy একই নেস্টেড অবজেক্ট শেয়ার করছে। যখন shallowCopy[2].a পরিবর্তন করা হয়, তখন মূল অবজেক্টেও পরিবর্তন ঘটে। এটি শ্যালো কপির একটি সীমাবদ্ধতা।","শ্যালো-কপি-তৈরি-করার-পদ্ধতি#শ্যালো কপি তৈরি করার পদ্ধতি:":"Spread Operator: let copy = [...array];","ডিপ-কপি-deep-copy#ডিপ কপি (Deep Copy)":"ডিপ কপিতে একটি অবজেক্টের প্রতিটি লেভেলের কপি তৈরি করা হয়, এমনকি নেস্টেড অবজেক্টেরও আলাদা কপি করা হয়। এর ফলে মূল অবজেক্টের কোনো পরিবর্তন নতুন কপি অবজেক্টকে প্রভাবিত করে না এবং বিপরীতও ঘটে না।","উদাহরণ-1#উদাহরণ:":"let originalArray = [1, 2, { a: 3, b: 4 }];\n// ডিপ কপি তৈরি করা (JSON পদ্ধতি ব্যবহার করে)\nlet deepCopy = JSON.parse(JSON.stringify(originalArray));\nconsole.log(deepCopy); // [1, 2, { a: 3, b: 4 }]\n// নেস্টেড অবজেক্ট পরিবর্তন করা\ndeepCopy[2].a = 10;\nconsole.log(originalArray); // [1, 2, { a: 3, b: 4 }]\nconsole.log(deepCopy); // [1, 2, { a: 10, b: 4 }]\nএখানে দেখা যাচ্ছে যে, deepCopy[2].a পরিবর্তন করার পরেও originalArray এর নেস্টেড অবজেক্ট অপরিবর্তিত রয়েছে। কারণ, ডিপ কপিতে নেস্টেড অবজেক্টের নতুন কপি তৈরি হয়।","ডিপ-কপি-তৈরি-করার-পদ্ধতি#ডিপ কপি তৈরি করার পদ্ধতি:":"JSON.parse(JSON.stringify(obj)): সহজ পদ্ধতি, তবে ফাংশন ও undefined হ্যান্ডেল করতে পারে না।\nLodash লাইব্রেরির cloneDeep মেথড Lodash একটি জনপ্রিয় জাভাস্ক্রিপ্ট লাইব্রেরি, যা অনেক ধরনের ইউটিলিটি ফাংশন সরবরাহ করে। cloneDeep হল একটি বিশেষ মেথড যা ডিপ কপি তৈরি করতে পারে।\nউদাহরণ:প্রথমে lodash ইনস্টল করতে হবে:\n npm i --save lodash\nতারপর\nconst _ = require(\"lodash\");\nlet originalObject = { a: 1, b: { c: 2, d: 3 } };\nlet deepCopiedObject = _.cloneDeep(originalObject);\ndeepCopiedObject.b.c = 10;\nconsole.log(originalObject); // { a: 1, b: { c: 2, d: 3 } }\nconsole.log(deepCopiedObject); // { a: 1, b: { c: 10, d: 3 } }\nLodash এর cloneDeep মেথড সমস্ত ডেটা টাইপ এবং নেস্টেড অবজেক্ট সঠিকভাবে হ্যান্ডেল করতে পারে। এটি ফাংশন, তারিখ, Map, Set এবং অন্যান্য জটিল ডেটা স্ট্রাকচার হ্যান্ডেল করার ক্ষেত্রে খুবই কার্যকর।","শ্যালো-কপি-বনাম-ডিপ-কপি-পার্থক্য#শ্যালো কপি বনাম ডিপ কপি পার্থক্য:":"শ্যালো কপি\tডিপ কপি\tশুধুমাত্র প্রথম লেভেলের কপি করে।\tপ্রতিটি লেভেলের জন্য নতুন কপি তৈরি করে।\tনেস্টেড অবজেক্টগুলো রেফারেন্স হিসেবে কপি হয়।\tনেস্টেড অবজেক্টগুলোর সম্পূর্ণ নতুন কপি হয়।\t\nএই দুই ধরনের কপির মধ্যে পার্থক্য নির্ভর করে আপনার প্রয়োজনের উপর।","this-এর-ব্যাবহার-কোথায়-এবং-কিভাবে-#this এর ব্যাবহার। কোথায় এবং কিভাবে ।":"","implicit-binding#Implicit Binding":"👉রুলসঃ দেখতে হবে যে,ফাংশন কল হয়েছে কোথায়, যেখানে কল হয়েছে তার সামনে কি কোন ডট আছে কিনা,যদি থাকে তাহলে তার সামনে কি আছে। যদি কিছু থাকে তাহলে সেটাই হলো this । এক্ষেত্রে এক্সেপ্সন হলো this শুধু নরমাল ফাংশনেই কাজ করবে। কিন্তু Arrow ফাংশন this বলে কিছু চিনবেনা।উদাহরণঃ\nlet player = {\n    name: \"Mashrafe\",\n    age: 38,\n    printPlayerName: function () {\n        console.log(this.name); // এখানে this দিয়ে `player` অবজেক্টটাকে পয়েন্ট করা হয়েছে।\n    },\n};\nplayer.printPlayerName();","explicitly-binding#Explicitly Binding":"","call#.call()":"👉 কখনও কখনও বাহিরের কোন ফাংশনকে অন্য কোন অবজেক্ট দিয়ে কল করার প্রয়োজন হয় । সেক্ষেত্রে সিনট্যাক্স হয় এরকমঃ\nfunction printName() {\n    // এটা একটা গ্লোবাল ফাংশন\n    console.log(this.name);\n}\nlet player = {\n    name: \"Sakib\",\n    age: 33,\n};\nprintName.call(player); // এই গ্লোবাল ফাংশনটাকে `player` অবজেক্ট দিয়ে `.call()` করা হয়েছে ।\nএক্ষেত্রে .call() এর ভিতরে যা পাস করা হয়, this সেটাকেই পয়েন্ট করে। এক্ষেত্রে explicitly বলে দেয়া হচ্ছে যে this কি হবে ।","apply#.apply()":"👉 .apply() আর .call() একই কাজ করে। সবকিছুই সেম। তবে.apply() তার second parameter এ Array নিতে পারে । যেকানে .call() Array নিতে পারেনা।\nfunction printPlayerName() {\n    console.log(`${this.name} is ${vertue} `);\n}\nlet mashrafe = {\n    name: \"Mashrafe\",\n    age: 36,\n};\nlet vartu1 = \"Honest\";\nlet vartu2 = \"Captain\";\nlet vartu3 = \"Leader\";\nlet vertue = [vartu1, vartu2, vartu3];\nprintPlayerName.apply(mashrafe, vertue);","bind#.bind()":"👉 .bind() ও .call() এর মতোই সেম কাজ করে। তবে পার্থক্য হলো .bind() ফাংশনটিকে সরাসরি কল না করে দিয়ে ফাংশনের একটা নতুন ইন্সটেন্স রিটার্ন করে। এবং সেই ইন্সটেন্সকে যেই ভেরিয়েবলে রাখা হয় সেই ভেরিয়েবল দ্বারা কল করতে হয়।উদাহরনঃ\nfunction printAPlayerName() {\n    console.log(this.name);\n}\nlet bdPlayer = {\n    name: \"Ashraful\",\n    age: 39,\n};\nlet printFunction = printAPlayerName.bind(bdPlayer);\nprintFunction();","itarables-কি-#Itarables কি ?":"Itarables বলতে মূলত সেই সমস্ত জিনিস বা অবজেক্ট কে বোঝায়,যেগুলোর মধ্যে দিয়ে লুপ eg: for...of করে স্টেপ বাই স্টেপ যাওয়া যায়। যেমনঃ Array,String,Map,Setটেকনিক্যালি বললে, যেসব অবজেক্টের প্রোটোটাইপের ভিতরে symbol.itarator প্রপার্টি রয়েছে সেটাই itarable symbol.itarator এর মাধ্যমেই জাভাস্ক্রিপ্ট ডিফাইন করে যে, কোনটা itarable আর কোনটা নয় ।\nMap,Set বলতে এখানে জাভাস্ক্রিপ্ট এর Map Set ডাটা স্ট্রাকচার কে\nবুঝানো হয়েছে","itarator-বলতে-কি-বুঝায়-#itarator বলতে কি বুঝায় ?":"itarable অবজেক্টকে যার দ্বারা itarate করা যায়,সেটাই হলো itarator","itarating-বলতে-কি-বুঝায়-#itarating বলতে কি বুঝায় ?":"itarating বলতে মূলত Itarables অবজেক্টগুলোকে লুপ করে স্টেপ বাই স্টেপ যাওয়ার যেই প্রসেস সেটাকে বুঝায় । যখন itarate করা হয় তখন সেটা হলো itarating","array-কে-itarate-করা-#Array কে itarate করা ।":"const arr = [1, 2, 3, 4, 5, 6, 7];\nfor (item of arr) {\n    console.log(item);\n}\n//Output: 1 2 3 4 5 6 7","string-কে-itarate-করা-#String কে itarate করা ।":"const str = \"Bangladesh\";\nfor (character of str) {\n    console.log(character);\n}\n// Output : B a n g l a d e s h\nজাভাস্ক্রিপ্ট হলো সিঙ্গেল থ্রেডেড প্রোগ্রামিং ল্যাঙ্গুয়েজ"}},"/reactive-accilarator/React-js/module-3/passing-data-deeply-with-context":{"title":"Passing Data Deeply with Context","data":{"passing-data-deeply-with-context#Passing Data Deeply with Context":"সাধারণত আমরা প্যারেন্ট কম্পোনেন্ট থেকে ডাটা চাইল্ড কম্পোনেন্টে Props এর মাধ্যমে পাস করে থাকি। কিন্তু যদি এমন এমন হয় যে আমরা যেই কম্পোনেন্টে ডাটা পাস করতে চাঁচছিসে কম্পোনেন্টটা কম্পোনেন্ট ট্রি এর অনেক ভিতরে নেস্টেড অবস্থায় রয়েছে, সেই ক্ষেত্রে আমাদের ডাটা কে সেই কাঙ্খিত কম্পোনেন্টে পাঠানোর জন্য আমাদের অনেকগুলো কম্পনেন্টকে শুধুমাত্র একটা কেরিয়ার হিসেবে ব্যাবহার করতে হচ্চে,এবং যেই কম্পোনেন্টের সেই ডাটা-টি দরকার নেই সেখানেও আমাদের ডাটা পাস করতে হচ্ছে। এইযে এভাবে এক কম্পোনেন্ট থেকে অন্য কম্পোনেন্টে ডাটা পাস করতে হচ্ছে শুধুমাত্র ডাটাকে কাঙ্খিত কম্পোনেন্টে পৌঁছানোর জন্য, এটাকে বলা হয় Props Drilling।তাহলে আমরা বুঝতে পারছি যে, এভাবে শুধুমাত্র কেরিয়ার হসেবে এতগুলো কম্পোনেন্টকে ব্যবহার করে ডাটাকে একটা নির্দিষ্ট কম্পোনেন্টে নিয়ে যাওয়া এটা খুবই ঝামেলার এমনকি অনেকসময় এটা বাগ তৈরি করতেও পারে। আর এই Props Drilling সমস্যার সমাধান করার জন্যই useContext এসেছে।","context-is-an-alternative-to-passing-props#Context is an alternative to passing props":"Context হলো Props Drilling এর অল্টারনেটিভ। Context এর সাহায্যে আমরা যেসকল ডাটা কোন নেস্টেড কম্পোনেন্ট এ পাঠাতে চাই, সেগুলোকে আমরা একটা আলাদা জায়গায় মেনেজ করে Context এর Provider এর মাধ্যমে কমোনেন্টের কাছে পাঠিয়ে দিতে পারি।","how-to-use-context#How to use Context":"আমরা তিনটা স্টেপ ফলো করে useContext হুক ব্যাবহার করতে পারি।\nকনটেক্সট তৈরি করা (Create a Context)\nপ্রভাইডারের মাধ্যমে কনটেক্সট এর ডাটা প্রভাইড করা (Provide Context data by provider)\nকম্পোনেন্টের ভিতর কনটেক্সট ব্যাবহার করা (Use Context in Component)","কনটেক্সট-তৈরি-করা-create-a-context#কনটেক্সট তৈরি করা (Create a Context)":"প্রথমে আমাদের এভাবে একটি কনটেক্সট তৈরি করতে হবে ।\nimport {createContext} from \"react\"\nexport const CounterContext = createContext(0)\nআমরা এখানে একটা কাউন্টার এপ্লিকেশনের জন্য Context তৈরি করে নিয়েছি এবং Context এর ডিফল্ট ভ্যালু দিয়েছি 0","প্রভাইডারের-মাধ্যমে-কনটেক্সট-এর-ডাটা-প্রভাইড-করা-provide-context-data-by-provider#প্রভাইডারের মাধ্যমে কনটেক্সট এর ডাটা প্রভাইড করা (Provide Context data by provider)":"তারপর যেই কম্পোনেন্টে আমরা Context এর ভ্যালু এক্সেস করতে চাই তার প্যারেন্ট কম্পোনেন্ট কে Context.Provider দিয়ে wrap করে দিতে হবে, এবং ভ্যালু হিসেবে যেসব ডাটা পাঠানো দরকার সেগুলো value={} Attribute এর মাধ্যমে পাস করে দিতে হবে।\nimport { CounterContext } from \"./counterContext.js\";\nconst countValue = 3;\nexport default function App() {\n    return (\n        <section className='section'>\n            <CounterContext.Provider value={countValue}>\n                {children}\n            </CounterContext.Provider>\n        </section>\n    );\n}","কম্পোনেন্টের-ভিতর-কনটেক্সট-ব্যাবহার-করা-use-context-in-component#কম্পোনেন্টের ভিতর কনটেক্সট ব্যাবহার করা (Use Context in Component)":"এরপর আমরা যেই কম্পোনেন্ট এ আমাদের ডাটা প্রয়োজন হবে সেই কম্পোনেন্ট এ useContext কল করে ডাটা এক্সেস করতে পারি।\nimport { useContext } from \"react\";\nconst countValue = useContext();\nexport default function App() {\n    return (\n        <div>\n            <h1> Count Value is : {countValue}</h1>\n        </div>\n    );\n}\nএভাবে আমরা যেই পেরেন্টকে Context.Provider দিয়ে wrap করে দিব তার সকল চাইল্ড কম্পোনেন্ট থেকে আমরা Context এর ডাটা এক্সেস করতে পারবো।","using-and-providing-context-from-the-same-component#Using and providing context from the same component":"আগের উদাহরণে আমরা দেখেছিলাম যে আমরা প্যারেন্ট কম্পোনেন্টে Context.Provider দিয়ে ডাটা পাস করছিলাম এবং চাইল্ড কম্পোনেন্টে useContext ব্যাবহার করার মাধ্যমে ডাটা এক্সেস করতে পারছিলাম,আমরা কিন্তু চাইলে একই কম্পোনেন্টে useContext ব্যাবহার করে ডাটা ধরতেও পারি,আবার সেই কম্পোনেন্ট থেকেই আবার ডাটা চাইল্ড কম্পোনেন্ট এ পাঠাতেও পারি।\nimport { CounterContext } from \"./counterContext.js\";\nimport { useContext } from \"react\";\nexport default function App() {\n    const count = useContext(CounterContext);\n    return (\n        <section className='section'>\n            <CounterContext.Provider value={count+1}>\n                {children}\n            </CounterContext.Provider>\n        </section>\n    );\n}","context-passes-through-intermediate-components-or-nestating-multiple-context#Context passes through intermediate components or Nestating multiple Context":"আমাদের যদি একাধিক Context থাকে এবং তা যদি আমাদের একই কম্পোনেন্টে ব্যবাহার করতে হয় তাহলে আমরা তা এভাবে নেস্টেড করতে পারি।\nimport { CounterContext } from \"./counterContext.js\";\nimport { OtherContext } from \"./otherContext.js\";\nimport { useContext } from \"react\";\nexport default function App() {\n    const count = useContext(CounterContext);\n    return (\n        <section className='section'>\n            <CounterContext.Provider value={count+1}>\n                <OtherContext.Provider value={something}>\n                    {children}\n                </OtherContext.Provider>\n            </CounterContext.Provider>\n        </section>\n    );\n}\nএখানে এইযে আমরা একটি Context কে অন্য আরেকটি দিয়ে Nested করেছি এতে কিন্তু একটার কারণে অন্যটায় কোন এফেক্ট পরবেনা।","before-you-use-context-কনটেক্সট-ব্যাবহার-করার-আগে-আমদের-যে-বিষয়গুলো-অবশ্যই-মাথায়-রাখতে-হবে#Before you use context (কনটেক্সট ব্যাবহার করার আগে আমদের যে বিষয়গুলো অবশ্যই মাথায় রাখতে হবে)":"Context এর সহজ ব্যবাহার এবং বার বার Props পাস করার ঝামেলা থেকে বাচার জন্য ম্যক্সিমাম টাইম আমাদের Context ব্যাবহার করার ইচ্ছা করতে পারে। কিন্তু শুধুমাত্র কিছু কম্পোনেন্টে ডাটা পাস করার ঝমেলা থেকে বাচার জন্য কখনই Context ব্যাবহার করা উচিত না।আমাদের এপ্লিকেশনের শুরুতে আমরা নিচের এর দুইভাবে কনটেক্সট ব্যাবহার ছাড়া কাজ করতে পারি।\nStart by passing props (প্রপ্স পাস করে শুরু করা) যদি আমদের কম্পোনেন্ট মারাত্মক লেভেলের কমপ্লেক্স না হয় তাহলে আমাদের Props পাস করেই কাজ করা উচিত। এতে যতগুলো প্রপ্স পাস করা লাগে লাগুক,এটা মোটেও কোন সমস্যা না।\nExtract components and pass JSX as children (চিলড্রেন প্রপ আকারে JSX পাস করে কম্পোনেন্টের নেস্টং কমিয়া আনা) আমরা যদি চিলড্রেন প্রপ এর ব্যাবহার বাড়িয়ে খুব সুন্দর করে আমদের কম্পোনেন্টগুলোকে কম্পোস করতে পারি,তাহলে দেখা যাবে যে আমদের কম্পোনেন্টগুলোর নেস্টিং অনেক কমে এসেছে, এবং আমরা খুব সহজেই ডাটা পাস করতে পারছি।","use-cases-for-context-কখন-কখন-context-ব্যাবহার-করা-উচিত#Use cases for context (কখন কখন Context ব্যাবহার করা উচিত)":"Context কে যখন তখন যেকোন জায়গায় ব্যাবহার করা উচিত না। যদি এমন কোন ডাটা হয় যেটা আমদের পুরো এপ্লিকেশনের যেকোন জায়গায় যখন তখন লাগতে পারে, প্রায় সকল কম্পোনেন্টেই ডাটার প্রয়োজন হচ্ছে, সেক্ষেত্রে মরা Context ব্যাবহারের কথা ভাবতে পারি। তাছাড়াও,\nTheming আমদের এপ্লকেশনে কোন ব্যাবহার হবে,বা ইউজারের ইন্টারেকশনের কিভাবে থিম ম্যানেজ হবে এজন্য আমাদের থিম এর ডাটাটা কম্পোনেন্ট এর যেকোন জায়গায় ব্যাবহার হতে পারে, তাই Theming এর ক্ষেত্রে Context ব্যাবহার হতে পারে।\nAuthentication এপ্লিকেশনের বিভিন্ন জায়গা থেকে আমদের ইউজারের ইনফরমেশন বা অথেনটিকেশন এর ডাটা প্রয়োজন হতে পারে,তাই Authentication ম্যানেজ করার জন্য Context ব্যাবহার করা যেতে পারে।\nRouting রাউটিং এর জন্য বেশিরভাগ লাইব্রেরিগুলোই বিহাইন্ড দ্যা সিন Context ব্যবাহার করে থাকে।\nComplex State with Reducer যখন আমদের এপ্লিকেশনের অনেক কমপ্লেক্স লজিক আমাদের ম্যানেজ করা লাগবে এবং তা কম্পোনেন্ট এর অনেক ডীপলি নেস্টেড কম্পোনেন্ট এ পাস করা লাগবে তখন useREducer হুক এর সাথে useContext ব্যাবহার করা যেতে পারে।"}},"/reactive-accilarator/React-js/module-3/scaling-up-with-reducer-and-context":{"title":"Scaling up with Reducer and Context","data":{"scaling-up-with-reducer-and-context#Scaling Up with Reducer and Context":"reducer আমদের কম্পোনেন্ট এর কমপ্লেক্স স্টেট লজিকগুলোকে কম্পোনেন্ট থেকে আলাদা করে একটা ফাংশনের ভিতরে ম্যানেজ করতে দেয়। এবং Context আমাদের props drilling ছাড়াই ডিপলি ডাটা পাস করতে দেয়। আমরা reducer এবং Context দুইটাকে একসাথে কমবাইন করে কমপ্লেক্স কম্পোনেন্টগুলোকে অনেক সিম্পল এবং সুন্দর করতে পারি।","combining-a-reducer-with-context#Combining a reducer with context":"আমরা তিনটা স্টেপে Context এবং Reducer কে একসাথে করে ব্যাবহার করে এপ্লিকেশনের যেকোন কম্পোনেন্ট এ ডাটা পাস করতে পারি।\nCreate the context.\nCreate a Reducer and Provide the state and dispatch via Provider\nUse context anywhere in the tree.","create-the-context-একটি-কনটেক্সট-তৈরি-করা#Create the context (একটি কনটেক্সট তৈরি করা)":"একটা আলাদা ফাইলে একটি কনটেক্সট তৈরি করে নিতে হবে এবং তা এক্সপোর্ট করে দিতে হবে যাতে অন্যান্য ফাইল থেকে তা ইম্পোর্ট করে কাজ করা যায়।\nimport {createContext} from \"react\"\nconst CounterContext = createContext(0)\nexport default CounterContext","create-a-reducer-and-provide-the-state-and-dispatch-via-provider-একটি-রিডিওসার-তৈরি-করতে-হবে-এবং-রিডিওসারের-state-এবং-dispatch-ফাংশন-প্রভাইডারে-মাধ্যমে-প্রভাইড-করা#Create a Reducer and Provide the state and dispatch via Provider (একটি রিডিওসার তৈরি করতে হবে এবং রিডিওসারের state এবং dispatch ফাংশন প্রভাইডারে মাধ্যমে প্রভাইড করা)":"আমাদেরকে একটি রিডিউসার বানাতে হবে সেই রিডিওসারের state এবং dispatch ফাংশন যেগুলো আমাদের কম্পোনেন্টের দরকার পরবে সেগুলো আমরা যেই কম্পোনেন্ট ট্রি তে ডাটা পাস করবো তাদের মেইন প্যারেন্টে পাস করবো, এতে সকল নেস্টেড চাইল্ড কম্পোনেন্ট সেই ডাটা এক্সেস করতে পারবে।কিভাবে Reducer বানাতে হয় তা না জানলে এখানে ক্লিক করুন\n    import React from 'react'\n    import Counter from \"./Counter\"\n    import counterReducer from \"./CounterReducer.js\"\n    import CounterContext from \"./CounterContext.js\"\n    const App = () => {\n    const initialState = 0\n    const [count,dispatch] = useReducer(counterReducer,initialState)\n      return (\n        <div>\n        <CounterContext.Provider value={{count,dispatch}}>\n          <Counter/>\n        </CounterContext.Provider>\n        </div>\n      )\n    }\n    export default App\n       export default function Counter(){\n      return <button>\n          <h1> Count : 0</h1>\n          <button>Incriment</button>\n          <button>Decriment</button>\n      </>\n   }\n   import {createContext} from \"react\"\n    const CounterContext = createContext(0)\n    export default CounterContext\nexport const counterReducer = (state, action) => {\nswitch (action.type) {\n    case \"INCRIMENT\": {\n        return state + 1;\n    }\n    case \"DECRIMENT\": {\n        return state - 1;\n    }\n    default: {\n        return state;\n    }\n}\n};","use-context-anywhere-in-the-treeকম্পোনেন্ট-ট্রি-এর-যেকোন-জায়গায়-কনটেক্সট-ব্যাবহার-করে-ডাটা-রিসিভ-করা-#Use context anywhere in the tree.(কম্পোনেন্ট ট্রি এর যেকোন জায়গায় কনটেক্সট ব্যাবহার করে ডাটা রিসিভ করা )":"এই স্টেপে আমাদের যেসকল কম্পোনেন্টে ডাটা প্রয়োজন হবে সেখানে সেখানে আমরা useContext এর মাধ্যমে ডাটা রিসিভ করতে পারবো। এই উদাহরণের সাপেক্ষে আমাদের শুধুমাত্র Counter কম্পোনেন্টে ডাটা প্রয়োজন, তাই আমরা এখন Counter কম্পোনেন্ট থেকে ডাটা রিসিভ করে ব্যাবহার করবো।\n   import {useContext} from \"react\"\n   import CounterContext from \"./CounterContext.js\"\n   export default function Counter(){\n       const {state,dispatch} = useContext(CounterContext)\n      return <button>\n          <h1> Count : {count}</h1>\n          <button onClick={()=> dispatch({type:\"INCRIMENT\"})}>Incriment</button>\n          <button onClick={()=> dispatch({type:\"DECRIMENT\"})}>Decriment</button>\n      </>\n   }\n    import React from 'react'\n    import Counter from \"./Counter\"\n    import counterReducer from \"./CounterReducer.js\"\n    import CounterContext from \"./CounterContext.js\"\n    const App = () => {\n    const initialState = 0\n    const [count,dispatch] = useReducer(counterReducer,initialState)\n      return (\n        <div>\n        <CounterContext.Provider value={{count,dispatch}}>\n          <Counter/>\n        </CounterContext.Provider>\n        </div>\n      )\n    }\n    export default App\n   import {createContext} from \"react\"\n    const CounterContext = createContext(0)\n    export default CounterContext\nexport const counterReducer = (state, action) => {\nswitch (action.type) {\n    case \"INCRIMENT\": {\n        return state + 1;\n    }\n    case \"DECRIMENT\": {\n        return state - 1;\n    }\n    default: {\n        return state;\n    }\n}\n};\nএখন যদি আমাদের কোড রান করি,দেখবো এটা পারফেক্টলি কাজ করছে। এই হলো মূলত তিনটা স্টেপ, এই তিনটা স্টেপেই আমরা Reducer উইথ Context ব্যাবহার করতে পারি।","moving-all-wiring-into-a-single-file---a-better-approach#Moving all wiring into a single file - A Better Approach":"এবার আমরা আরেকটু সুন্দর এপ্রোচে Reducer with Context ব্যাবহার করবো। আমরা আমাদের Context রিলেটেড সমস্ত কাজ আলাদা একটা ফাইলে ম্যানেজ করবো এবং স্টেটগুলোও সেই ফাইল থেকে ম্যনেজ করবো।\n    import React from 'react'\n    import Counter from \"./Counter\"\n    import CounterProvider from \"./CounterProvider\"\n    const App = () => {\n      return (\n        <div>\n        <CounterProvider>\n          <Counter/>\n        </CounterProvider>\n        </div>\n      )\n    }\n    export default App\nimport React from 'react'\nimport {createContext,useReducer} from \"react\"\nimport counterReducer from \"./counterReducer.js\"\nconst CounterContext = createContext(0)\nconst initialState = 0\n const CounterProvider = ({children}) => {\n    const [count,dispatch] = useReducer(counterReducer,initialState)\n      return (\n        <CounterContext.provider value={{count,dispatch}}>\n            {children}\n        </CounterContext.provider>\n      )\n    }\n export default CounterProvider\nexport const counterReducer = (state, action) => {\nswitch (action.type) {\n    case \"INCRIMENT\": {\n        return state + 1;\n    }\n    case \"DECRIMENT\": {\n        return state - 1;\n    }\n    default: {\n        return state;\n    }\n}\n};\n   import {useContext} from \"react\"\n   import CounterContext from \"./CounterContext.js\"\n   export default function Counter(){\n       const {state,dispatch} = useContext(CounterContext)\n      return <button>\n          <h1> Count : {count}</h1>\n          <button onClick={()=> dispatch({type:\"INCRIMENT\"})}>Incriment</button>\n          <button onClick={()=> dispatch({type:\"DECRIMENT\"})}>Decriment</button>\n      </>\n   }\nএভাবে আমাদের মেইন প্যারেন্ট কম্পোনেন্ট থেকে সমস্ত কিছু সরিয়ে নিয়ে আমরা একটা আলদা ফাইলে ম্যানেজ করতে পারি।\nএছাড়াও আমরা\n   const {state,dispatch} = useContext(CounterContext)\nএইভাবে Context কে বার বার কল না করে একটা আলাদা কাস্টম হুক বানিয়ে নিয়ে ব্যবাহার করতে পারি,\nimport {useContext} from \"react\"\nimport CounterContext from \"./CounterContext.js\"\nexport default function useCounterContext(){\n    return  useContext(CounterContext)\n}\n   import {useContext} from \"react\"\n   import useCounterContext from \"./hooks.js\"\n   export default function Counter(){\n       const {state,dispatch} = useCounterContext()\n      return <button>\n          <h1> Count : {count}</h1>\n          <button onClick={()=> dispatch({type:\"INCRIMENT\"})}>Incriment</button>\n          <button onClick={()=> dispatch({type:\"DECRIMENT\"})}>Decriment</button>\n      </>\n   }"}}}